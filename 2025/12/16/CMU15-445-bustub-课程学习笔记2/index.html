

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Chengxiang">
  <meta name="keywords" content="">
  
    <meta name="description" content="第十三讲：Query Processing I1. 概述：从 SQL 到执行SQL 是一种声明式语言（Declarative），你告诉数据库“我想要什么”，而不是“怎么做”。DBMS 的工作就是将这种声明转换为可执行的查询计划 (Query Plan) 。  查询计划的本质：它是一个操作符（Operators）构成的有向无环图（DAG），通常组织成树状结构 。  数据流向：数据从树的叶子节点（Le">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15-445(bustub):课程学习笔记2">
<meta property="og:url" content="http://example.com/2025/12/16/CMU15-445-bustub-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/index.html">
<meta property="og:site_name" content="TARScn">
<meta property="og:description" content="第十三讲：Query Processing I1. 概述：从 SQL 到执行SQL 是一种声明式语言（Declarative），你告诉数据库“我想要什么”，而不是“怎么做”。DBMS 的工作就是将这种声明转换为可执行的查询计划 (Query Plan) 。  查询计划的本质：它是一个操作符（Operators）构成的有向无环图（DAG），通常组织成树状结构 。  数据流向：数据从树的叶子节点（Le">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/CMU15-445-Bustub-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/Iterator.png">
<meta property="og:image" content="http://example.com/img/CMU15-445-Bustub-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/Materialization.png">
<meta property="og:image" content="http://example.com/img/CMU15-445-Bustub-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/Vectorized.png">
<meta property="article:published_time" content="2025-12-16T15:56:09.000Z">
<meta property="article:modified_time" content="2025-12-19T09:28:06.183Z">
<meta property="article:author" content="Chengxiang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/CMU15-445-Bustub-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/Iterator.png">
  
  
  
  <title>CMU15-445(bustub):课程学习笔记2 - TARScn</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TARScn</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15-445(bustub):课程学习笔记2"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Chengxiang
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-12-16 23:56" pubdate>
          2025年12月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          137 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15-445(bustub):课程学习笔记2</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第十三讲：Query-Processing-I"><a href="#第十三讲：Query-Processing-I" class="headerlink" title="第十三讲：Query Processing I"></a>第十三讲：Query Processing I</h1><h2 id="1-概述：从-SQL-到执行"><a href="#1-概述：从-SQL-到执行" class="headerlink" title="1. 概述：从 SQL 到执行"></a>1. 概述：从 SQL 到执行</h2><p>SQL 是一种声明式语言（Declarative），你告诉数据库“我想要什么”，而不是“怎么做”。DBMS 的工作就是将这种声明转换为可执行的<strong>查询计划 (Query Plan)</strong> 。</p>
<ul>
<li><p><strong>查询计划的本质</strong>：它是一个操作符（Operators）构成的有向无环图（DAG），通常组织成树状结构 。</p>
</li>
<li><p><strong>数据流向</strong>：数据从树的叶子节点（Leaves）流向根节点（Root），根节点的输出即为查询结果 。</p>
</li>
<li><p><strong>操作符 (Operators)</strong>：通常是二元的（1-2个子节点），负责具体的数据处理逻辑（如过滤、连接、排序）。</p>
</li>
</ul>
<h3 id="关键概念：流水线与阻断-Pipeline-Breakers"><a href="#关键概念：流水线与阻断-Pipeline-Breakers" class="headerlink" title="关键概念：流水线与阻断 (Pipeline &amp; Breakers)"></a>关键概念：流水线与阻断 (Pipeline &amp; Breakers)</h3><p>理解查询执行的核心在于理解数据是如何流动的：</p>
<ul>
<li><p><strong>流水线 (Pipeline)</strong>：理想情况下，操作符之间应该像流水线一样。上游算子产生一个元组（Tuple），下游算子立即处理，中间不需要落盘存储 。</p>
</li>
<li><p><strong>流水线阻断器 (Pipeline Breaker)</strong>：某些操作符必须等待所有子节点的数据全部到达后才能开始工作。这就像生产线上的“路障” 。</p>
</li>
<li><p><strong>例子</strong>：<code>JOIN</code> 的构建阶段（必须先构建完哈希表才能探测）、<code>ORDER BY</code>（必须拿到所有数据才能排序）、子查询 。</p>
</li>
</ul>
<hr>
<h2 id="2-处理模型-Processing-Models"><a href="#2-处理模型-Processing-Models" class="headerlink" title="2. 处理模型 (Processing Models)"></a>2. 处理模型 (Processing Models)</h2><p>DBMS 处理模型定义了系统如何执行查询计划，特别是操作符之间如何传递数据（是一个个传、一批批传，还是全部传）。主要有三种模型：</p>
<h3 id="1-迭代器模型-Iterator-Model-Volcano-Model-Pipeline-Model"><a href="#1-迭代器模型-Iterator-Model-Volcano-Model-Pipeline-Model" class="headerlink" title="(1) 迭代器模型 (Iterator Model) &#x2F; Volcano Model &#x2F; Pipeline Model"></a>(1) 迭代器模型 (Iterator Model) &#x2F; Volcano Model &#x2F; Pipeline Model</h3><p>这是最常见的模型，几乎所有的行存储（Row-based）数据库都使用它 。</p>
<ul>
<li><strong>原理</strong>：每个操作符实现一个 <code>Next()</code> 函数。<ul>
<li><p>父节点调用子节点的 <code>Next()</code>。</p>
</li>
<li><p>子节点返回<strong>一个元组 (Tuple)</strong> 或空标记（null&#x2F;EOF）。</p>
</li>
<li><p>是一个“拉取”（Pull）数据的过程，从 Root 到底部循环调用 。</p>
</li>
</ul>
</li>
</ul>
<img src="/img/CMU15-445-Bustub-课程学习笔记2/Iterator.png" srcset="/img/loading.gif" lazyload alt="迭代器" style="display: block; margin: 0 auto; width: 70%; height:70%;">


<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><p><strong>流控制友好</strong>：非常适合基于磁盘的系统，内存用量可控 。</p>
</li>
<li><p><strong>易于实现</strong>：操作符之间解耦，容易组合 。</p>
</li>
<li><p><strong>支持 Limit</strong>：只要父节点拿够了数据，就可以停止调用 <code>Next()</code> 。</p>
</li>
</ul>
</li>
<li><p><strong>缺点</strong>：函数调用开销大（每个 Tuple 调用一次），不利于 CPU 流水线和缓存优化。</p>
</li>
</ul>
<h3 id="2-物化模型-Materialization-Model"><a href="#2-物化模型-Materialization-Model" class="headerlink" title="(2) 物化模型 (Materialization Model)"></a>(2) 物化模型 (Materialization Model)</h3><p>这种模型是迭代器模型的一种特化，区别在于它不流式传输，而是“一次性交货”。</p>
<ul>
<li><p><strong>原理</strong>：每个操作符实现一个 <code>Output()</code> 函数。该函数一次性处理所有输入，并将<strong>所有结果</strong>物化（存储）后一次性返回给父节点 。</p>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li><p><strong>OLTP (联机事务处理)</strong>：适合，因为 OLTP 查询通常只涉及少量数据，减少了函数调用次数 。</p>
</li>
<li><p><strong>不适合 OLAP</strong>：如果中间结果集很大，必须溢写到磁盘，效率极低 。</p>
</li>
</ul>
</li>
</ul>
<img src="/img/CMU15-445-Bustub-课程学习笔记2/Materialization.png" srcset="/img/loading.gif" lazyload alt="物化模型" style="display: block; margin: 0 auto; width: 70%; height:70%;">


<h3 id="3-向量化-批处理模型-Vectorized-Batch-Model"><a href="#3-向量化-批处理模型-Vectorized-Batch-Model" class="headerlink" title="(3) 向量化&#x2F;批处理模型 (Vectorized &#x2F; Batch Model)"></a>(3) 向量化&#x2F;批处理模型 (Vectorized &#x2F; Batch Model)</h3><p>这是现代分析型数据库（如 Snowflake, Redshift, DuckDB）的标准。</p>
<ul>
<li><p><strong>原理</strong>：结合了迭代器的流式思想和物化的批量思想。每个操作符也有 <code>Next()</code> 函数，但它每次返回<strong>一批元组 (Batch&#x2F;Vector)</strong>，而不是一个 。</p>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><p><strong>减少开销</strong>：将函数调用的开销分摊到一批数据上 。</p>
</li>
<li><p><strong>硬件加速</strong>：非常适合利用 CPU 的 <strong>SIMD</strong> (单指令多数据) 指令集来并行处理数据 。</p>
</li>
<li><p><strong>OLAP 理想选择</strong>：特别是对于列式存储，扫描大量数据极其高效 。</p>
</li>
</ul>
</li>
</ul>
<img src="/img/CMU15-445-Bustub-课程学习笔记2/Vectorized.png" srcset="/img/loading.gif" lazyload alt="批处理模型" style="display: block; margin: 0 auto; width: 70%; height:70%;">


<hr>
<h2 id="3-访问方法-Access-Methods"><a href="#3-访问方法-Access-Methods" class="headerlink" title="3. 访问方法 (Access Methods)"></a>3. 访问方法 (Access Methods)</h2><p>访问方法是 DBMS 从表中读取数据的方式。主要有两种路径：全表扫描或通过索引。</p>
<h3 id="1-顺序扫描-Sequential-Scan"><a href="#1-顺序扫描-Sequential-Scan" class="headerlink" title="(1) 顺序扫描 (Sequential Scan)"></a>(1) 顺序扫描 (Sequential Scan)</h3><p>DBMS 遍历表中的每一页，从缓冲池（Buffer Pool）获取数据并检查是否符合条件 。这通常是效率最低的方法，但有很多优化手段：</p>
<ul>
<li><p><strong>预取 (Prefetching)</strong>：提前加载后续页面，掩盖 I&#x2F;O 延迟 。</p>
</li>
<li><p><strong>绕过缓冲池 (Buffer Pool Bypass)</strong>：扫描大量数据时不污染热数据缓存，直接在局部内存处理 。</p>
</li>
<li><p><strong>并行化 (Parallelization)</strong>：多线程同时扫 。</p>
</li>
<li><p><strong>Zone Map (区域映射 &#x2F; Lossless Data Skipping)</strong>：</p>
<ul>
<li><p><strong>原理</strong>：在每页数据的头部或单独区域存储预计算的聚合信息（如 Min, Max, Sum, Count）。</p>
</li>
<li><p><strong>作用</strong>：在读取页面前，先检查 Zone Map。如果查询条件是 <code>WHERE val &gt; 600</code>，而 Zone Map 显示该页 <code>MAX = 400</code>，则直接<strong>跳过整页</strong>，完全不进行 I&#x2F;O 。这在云数据库（减少网络传输）中尤为重要 。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-索引扫描-Index-Scan"><a href="#2-索引扫描-Index-Scan" class="headerlink" title="(2) 索引扫描 (Index Scan)"></a>(2) 索引扫描 (Index Scan)</h3><p>DBMS 选择一个索引来查找数据。索引并不总是比顺序扫描快。</p>
<ul>
<li><p><strong>选择困境</strong>：</p>
<ul>
<li><p>如果查询结果占表的一大部分（如99%），顺序扫描往往比随机 I&#x2F;O 的索引扫描快 。</p>
</li>
<li><p>DBMS 需要根据统计信息（选择性 Selectivity）来决定是否使用索引 。</p>
</li>
</ul>
</li>
<li><p><strong>多索引扫描 (Multi-Index Scan)</strong>：</p>
<ul>
<li><p>如果查询有多个条件（如 <code>age &lt; 30 AND dept = &#39;CS&#39;</code>），可以分别在两个索引中查找 。</p>
</li>
<li><p>获取两组 Record ID，利用位图（Bitmap）或哈希表计算<strong>交集 (Intersection)</strong>，然后再回表取数据 。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-表达式求值-Expression-Evaluation"><a href="#4-表达式求值-Expression-Evaluation" class="headerlink" title="4. 表达式求值 (Expression Evaluation)"></a>4. 表达式求值 (Expression Evaluation)</h2><p><code>WHERE</code> 子句中的条件（如 <code>B.value = ? + [cite_start]1</code>）在内部被表示为<strong>表达式树 (Expression Tree)</strong> 。</p>
<ul>
<li><p><strong>解释执行 (Interpretation)</strong>：DBMS 遍历这棵树，递归调用每个节点进行计算。这很慢，因为每次计算都有类型检查和函数跳转的开销 。</p>
</li>
<li><p><strong>优化技术</strong>：</p>
<ol>
<li><p><strong>JIT 编译 (Just-In-Time Compilation)</strong>：将整个表达式树编译成原生的机器码，去除树遍历的开销，直接执行 。</p>
</li>
<li><p><strong>常量折叠 (Constant Folding)</strong>：如果表达式中有 <code>1 + 2</code>，直接在规划阶段算成 <code>3</code> 。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="5-修改查询-Modification-Queries-与万圣节问题"><a href="#5-修改查询-Modification-Queries-与万圣节问题" class="headerlink" title="5. 修改查询 (Modification Queries)与万圣节问题"></a>5. 修改查询 (Modification Queries)与万圣节问题</h2><p>对于 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>，操作符不仅要修改数据，还要负责检查约束（Constraints）和更新索引 。</p>
<h3 id="万圣节问题-Halloween-Problem"><a href="#万圣节问题-Halloween-Problem" class="headerlink" title="万圣节问题 (Halloween Problem)"></a>万圣节问题 (Halloween Problem)</h3><p>这是一个经典的数据库异常现象，由 IBM 研究员在 1976 年万圣节发现 。</p>
<ul>
<li><p><strong>现象</strong>：假设你要给所有薪水低于 1000 的员工加薪 10%。</p>
<ul>
<li><p>你更新了第一个员工，薪水变高了。</p>
</li>
<li><p>如果更新操作改变了元组在物理存储或索引中的位置，扫描操作符可能会<strong>再次扫描到这个已经被更新过的元组</strong> 。</p>
</li>
<li><p>结果：该员工被反复加薪，甚至导致无限循环。</p>
</li>
</ul>
</li>
<li><p><strong>解决方案</strong>：DBMS 必须跟踪哪些元组已经被修改过（例如记录 Record IDs），防止重复处理 。</p>
</li>
</ul>
<hr>
<h3 id="总结与下一步"><a href="#总结与下一步" class="headerlink" title="总结与下一步"></a>总结与下一步</h3><p>这节课的核心在于理解 <strong>Query Plan 是如何被“执行”的</strong>。</p>
<ol>
<li><strong>Iterator 模型</strong> 是这一层的基石，简单但有调用开销。</li>
<li><strong>Vectorization 模型</strong> 通过批处理解决了开销问题，是现代 OLAP 的标配。</li>
<li><strong>Access Methods</strong> 决定了最底层的 I&#x2F;O 效率，Zone Map 和 Index Selection 是其中的关键优化点。</li>
</ol>
<hr>
<h1 id="第十四讲：Query-Processing-II（并行查询执行）"><a href="#第十四讲：Query-Processing-II（并行查询执行）" class="headerlink" title="第十四讲：Query Processing II（并行查询执行）"></a>第十四讲：Query Processing II（并行查询执行）</h1><h2 id="1-核心背景与意义"><a href="#1-核心背景与意义" class="headerlink" title="1. 核心背景与意义"></a>1. 核心背景与意义</h2><p>在早期的讨论中，我们假设查询是由单个线程（Worker）执行的 。然而，现代 DBMS 为了提升性能，通常采用<strong>并行执行（Parallel Execution）</strong> 。</p>
<p><strong>并行执行的主要优势：</strong></p>
<ul>
<li><p><strong>性能提升：</strong> 提高吞吐量（每秒查询数）并降低响应延迟 。</p>
</li>
<li><p><strong>响应性与可用性：</strong> 增强外部客户端的交互体验 。</p>
</li>
<li><p><strong>降低总拥有成本 (TCO)：</strong> 通过更高效地利用硬件资源和降低能耗，优化云端系统的运行成本 。</p>
</li>
</ul>
<h3 id="并行（Parallel）与分布式（Distributed）的区别"><a href="#并行（Parallel）与分布式（Distributed）的区别" class="headerlink" title="并行（Parallel）与分布式（Distributed）的区别"></a>并行（Parallel）与分布式（Distributed）的区别</h3><p>虽然两者都将数据分散在多个资源上 ，但环境完全不同：</p>
<ul>
<li><p><strong>并行数据库：</strong> 节点物理距离近，通过高速互连通信。通信速度快且廉价，故障率低 。</p>
</li>
<li><p><strong>分布式数据库：</strong> 节点跨机架或数据中心。通信使用公共网络，成本高、延迟大，且必须考虑节点故障 。</p>
</li>
</ul>
<hr>
<h2 id="2-DBMS-进程模型-Process-Models"><a href="#2-DBMS-进程模型-Process-Models" class="headerlink" title="2. DBMS 进程模型 (Process Models)"></a>2. DBMS 进程模型 (Process Models)</h2><p>进程模型定义了系统如何支持多用户的并发请求 。</p>
<h3 id="A-进程每工作者-Process-per-Worker"><a href="#A-进程每工作者-Process-per-Worker" class="headerlink" title="A. 进程每工作者 (Process per Worker)"></a>A. 进程每工作者 (Process per Worker)</h3><ul>
<li><p><strong>原理：</strong> 每个工作者是一个独立的操作系统进程 。</p>
</li>
<li><p><strong>调度：</strong> 依赖操作系统的调度器 。</p>
</li>
<li><p><strong>优点：</strong> 隔离性强，单个进程崩溃不会导致整个系统宕机 。</p>
</li>
<li><p><strong>缺点：</strong> 依赖共享内存进行数据交换，跨进程通信（IPC）开销大 。</p>
</li>
<li><p><strong>代表案例：</strong> Postgres, Oracle, IBM DB2 。</p>
</li>
</ul>
<h3 id="B-线程每工作者-Thread-per-Worker-——-现代主流"><a href="#B-线程每工作者-Thread-per-Worker-——-现代主流" class="headerlink" title="B. 线程每工作者 (Thread per Worker) —— 现代主流"></a>B. 线程每工作者 (Thread per Worker) —— 现代主流</h3><ul>
<li><p><strong>原理：</strong> 一个数据库进程内包含多个工作线程 。</p>
</li>
<li><p><strong>调度：</strong> DBMS 可以完全控制任务调度，拥有更高的灵活性 。</p>
</li>
<li><p><strong>优点：</strong> 上下文切换开销小，无需复杂的跨进程共享模型 。</p>
</li>
<li><p><strong>缺点：</strong> 一个线程崩溃可能导致整个进程（整个数据库）崩溃 。</p>
</li>
<li><p><strong>代表案例：</strong> MySQL, Microsoft SQL Server 。</p>
</li>
</ul>
<h3 id="C-嵌入式模型-Embedded-DBMS"><a href="#C-嵌入式模型-Embedded-DBMS" class="headerlink" title="C. 嵌入式模型 (Embedded DBMS)"></a>C. 嵌入式模型 (Embedded DBMS)</h3><ul>
<li><p><strong>原理：</strong> 数据库运行在应用程序的同一地址空间内 。</p>
</li>
<li><p><strong>调度：</strong> 由应用程序负责线程调度 。</p>
</li>
<li><p><strong>代表案例：</strong> SQLite, DuckDB, RocksDB 。</p>
</li>
</ul>
<hr>
<h2 id="3-并行执行的类型"><a href="#3-并行执行的类型" class="headerlink" title="3. 并行执行的类型"></a>3. 并行执行的类型</h2><p>并行可以从查询间（Inter）和查询内（Intra）两个维度展开。</p>
<h3 id="3-1-查询间并行-Inter-Query-Parallelism"><a href="#3-1-查询间并行-Inter-Query-Parallelism" class="headerlink" title="3.1 查询间并行 (Inter-Query Parallelism)"></a>3.1 查询间并行 (Inter-Query Parallelism)</h3><ul>
<li><p><strong>定义：</strong> 多个不同的查询同时执行 。</p>
</li>
<li><p><strong>核心挑战：</strong> 如果多个查询同时更新相同的数据，会产生并发冲突 。</p>
</li>
</ul>
<h3 id="3-2-查询内并行-Intra-Query-Parallelism"><a href="#3-2-查询内并行-Intra-Query-Parallelism" class="headerlink" title="3.2 查询内并行 (Intra-Query Parallelism)"></a>3.2 查询内并行 (Intra-Query Parallelism)</h3><ul>
<li><strong>定义：</strong> 并行执行单个查询中的各个操作 。</li>
</ul>
<h4 id="算子内并行-Intra-Operator-Horizontal"><a href="#算子内并行-Intra-Operator-Horizontal" class="headerlink" title="算子内并行 (Intra-Operator &#x2F; Horizontal)"></a>算子内并行 (Intra-Operator &#x2F; Horizontal)</h4><ul>
<li><p><strong>原理：</strong> 将单个算子分解为多个独立的片段（Fragments），每个片段在不同的数据子集上执行相同功能 。</p>
</li>
<li><p><strong>关键组件：</strong> <strong>交换算子 (Exchange Operator)</strong> 。</p>
<ul>
<li><p><strong>Gather：</strong> 将多个流合并为一个 。</p>
</li>
<li><p><strong>Distribute：</strong> 将一个流拆分为多个 。</p>
</li>
<li><p><strong>Repartition：</strong> 重新组织多个输入流到多个输出流 。</p>
</li>
</ul>
</li>
</ul>
<h4 id="算子间并行-Inter-Operator-Vertical-Pipelining"><a href="#算子间并行-Inter-Operator-Vertical-Pipelining" class="headerlink" title="算子间并行 (Inter-Operator &#x2F; Vertical &#x2F; Pipelining)"></a>算子间并行 (Inter-Operator &#x2F; Vertical &#x2F; Pipelining)</h4><ul>
<li><strong>原理：</strong> 类似于流水线，上游算子在下游算子产生数据时立即开始处理，无需等待所有数据物化 。</li>
</ul>
<h4 id="丛式并行-Bushy-Parallelism"><a href="#丛式并行-Bushy-Parallelism" class="headerlink" title="丛式并行 (Bushy Parallelism)"></a>丛式并行 (Bushy Parallelism)</h4><ul>
<li><strong>原理：</strong> 结合了上述两种方式，不同的工作者同时执行查询计划中不同部分的多个算子 。</li>
</ul>
<hr>
<h2 id="4-I-O-并行-I-O-Parallelism"><a href="#4-I-O-并行-I-O-Parallelism" class="headerlink" title="4. I&#x2F;O 并行 (I&#x2F;O Parallelism)"></a>4. I&#x2F;O 并行 (I&#x2F;O Parallelism)</h2><p>如果磁盘是瓶颈，增加 CPU 线程也无法提升性能 。</p>
<ul>
<li><p><strong>多磁盘并行 (Multi-Disk)：</strong> 通过 RAID 或存储设备将文件分散在物理硬盘上，这对 DBMS 是透明的 。</p>
</li>
<li><p><strong>数据库分区 (Database Partitioning)：</strong> 将数据库物理拆分为不相交的子集，存储在不同磁盘。</p>
</li>
<li><p><strong>逻辑分区：</strong> 将一个逻辑表拆分为物理段管理，对应用透明 。</p>
</li>
</ul>
<hr>
<h3 id="补充理解：为什么-DBMS-要“夺取”调度权？"><a href="#补充理解：为什么-DBMS-要“夺取”调度权？" class="headerlink" title="补充理解：为什么 DBMS 要“夺取”调度权？"></a>补充理解：为什么 DBMS 要“夺取”调度权？</h3><p>在笔记中提到，DBMS 总是比操作系统更了解查询计划，因此倾向于自己调度 。这是因为：</p>
<ol>
<li><strong>数据位置感知：</strong> DBMS 知道数据在哪个 Buffer Pool 页面，可以实现“计算向数据移动”。</li>
<li><strong>依赖关系感知：</strong> DBMS 知道算子间的先后顺序（如 Join 必须在 Scan 后），而 OS 只把它们看作普通的线程。</li>
</ol>
<p>这份笔记基于你提供的 CMU 15-445&#x2F;645 课程资料（Lecture #15: Query Planning &amp; Optimization），系统地总结了数据库查询优化器的核心架构、策略与算法。</p>
<hr>
<h1 id="第十五讲：查询规划与优化-Query-Planning-Optimization"><a href="#第十五讲：查询规划与优化-Query-Planning-Optimization" class="headerlink" title="第十五讲：查询规划与优化 (Query Planning &amp; Optimization)"></a>第十五讲：查询规划与优化 (Query Planning &amp; Optimization)</h1><h2 id="1-优化器概述-Overview"><a href="#1-优化器概述-Overview" class="headerlink" title="1. 优化器概述 (Overview)"></a>1. 优化器概述 (Overview)</h2><p>由于 SQL 是<strong>声明式 (Declarative)</strong> 语言，用户只说明“想要什么”，而不说明“如何计算” 。DBMS 的任务是将 SQL 语句转化为高效的<strong>可执行查询计划</strong> 。</p>
<ul>
<li><p><strong>核心挑战</strong>：同一个查询有多种执行方式（如不同的连接算法），性能差异巨大 。</p>
</li>
<li><p><strong>历史地位</strong>：查询优化是构建 DBMS 最难的部分 。最早的优化器源于 20 世纪 70 年代的 IBM System R 。</p>
</li>
</ul>
<p>查询处理流程 ：</p>
<ol>
<li><strong>Parser (解析器)</strong>：将 SQL 字符串转化为<strong>抽象语法树 (AST)</strong>。</li>
<li><strong>Binder (绑定器)</strong>：结合系统目录 (System Catalog)，将 AST 中的名称映射为内部 ID。</li>
<li><strong>Optimizer (优化器)</strong>：根据逻辑计划选择最高效的物理执行路径。</li>
</ol>
<hr>
<h2 id="2-逻辑计划-vs-物理计划"><a href="#2-逻辑计划-vs-物理计划" class="headerlink" title="2. 逻辑计划 vs. 物理计划"></a>2. 逻辑计划 vs. 物理计划</h2><ul>
<li><strong>逻辑计划 (Logical Plan)</strong>：对应于关系代数表达式，描述操作的逻辑顺序。</li>
<li><strong>物理计划 (Physical Plan)</strong>：定义具体的执行策略和访问路径（如顺序扫描、索引扫描、哈希连接等），受数据物理格式（如排序、压缩）影响。</li>
</ul>
<hr>
<h2 id="3-查询优化两大策略"><a href="#3-查询优化两大策略" class="headerlink" title="3. 查询优化两大策略"></a>3. 查询优化两大策略</h2><h3 id="A-基于规则的逻辑优化-Rule-based-Heuristics"><a href="#A-基于规则的逻辑优化-Rule-based-Heuristics" class="headerlink" title="A. 基于规则的逻辑优化 (Rule-based &#x2F; Heuristics)"></a>A. 基于规则的逻辑优化 (Rule-based &#x2F; Heuristics)</h3><p>利用静态规则和模式匹配来转换逻辑计划，不查看具体数据内容 。</p>
<ul>
<li><p><strong>谓词下推 (Predicate Pushdown)</strong>：尽可能早地进行过滤，减少进入后续算子的数据量 。</p>
</li>
<li><p><strong>投影下推 (Projection Pushdown)</strong>：尽早切掉不需要的列，减小元组大小，降低中间结果开销 。</p>
</li>
<li><p><strong>表达式重写</strong>：合并冗余谓词（如将 <code>val BETWEEN 1 AND 100 OR val BETWEEN 50 AND 150</code> 重写为 <code>BETWEEN 1 AND 150</code>）或删除不可能执行的谓词 。</p>
</li>
</ul>
<h3 id="B-基于代价的物理优化-Cost-based-Search"><a href="#B-基于代价的物理优化-Cost-based-Search" class="headerlink" title="B. 基于代价的物理优化 (Cost-based Search)"></a>B. 基于代价的物理优化 (Cost-based Search)</h3><p>通过估算不同等价计划的代价，选择代价最低的一个 。</p>
<ul>
<li><strong>评价指标</strong>：CPU 开销、磁盘 I&#x2F;O（块传输数）、内存使用量、网络开销 。</li>
</ul>
<hr>
<h2 id="4-代价估算-Cost-Estimations"><a href="#4-代价估算-Cost-Estimations" class="headerlink" title="4. 代价估算 (Cost Estimations)"></a>4. 代价估算 (Cost Estimations)</h2><p>为了在不实际执行查询的情况下估算代价，DBMS 在目录中维护<strong>统计信息</strong> 。</p>
<p>核心统计指标 ：</p>
<ul>
<li>$N_{R}$：关系 $R$ 中的元组总数。</li>
<li>$V(A, R)$：属性 $A$ 的不同取值数 (Distinct Values)。</li>
<li><strong>选择度 (Selectivity)</strong>：谓词 P 过滤后符合条件的元组比例 。</li>
</ul>
<h3 id="解决数据倾斜：直方图-Histograms"><a href="#解决数据倾斜：直方图-Histograms" class="headerlink" title="解决数据倾斜：直方图 (Histograms)"></a>解决数据倾斜：直方图 (Histograms)</h3><p>现实数据通常是不均匀的 。DBMS 使用直方图来减少存储开销并提高估算准确性：</p>
<ul>
<li><p><strong>等宽直方图 (Equi-Width)</strong>：每个桶的取值范围跨度相同 。</p>
</li>
<li><p><strong>等深直方图 (Equi-Depth)</strong>：调整桶范围，使每个桶内落入的记录数大致相等 。</p>
</li>
</ul>
<h3 id="采样-Sampling"><a href="#采样-Sampling" class="headerlink" title="采样 (Sampling)"></a>采样 (Sampling)</h3><p>对于超大规模数据（如 10 亿行），DBMS 会在数据表的子集上应用谓词来估算选择度 。</p>
<hr>
<h2 id="5-搜索空间与优化算法"><a href="#5-搜索空间与优化算法" class="headerlink" title="5. 搜索空间与优化算法"></a>5. 搜索空间与优化算法</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>重点在于选择<strong>访问方法 (Access Method)</strong>。对于 OLTP 查询，通常存在最优索引（Sargable），使用简单启发式规则即可选择 。</p>
<h3 id="多表连接-Multi-Relation"><a href="#多表连接-Multi-Relation" class="headerlink" title="多表连接 (Multi-Relation)"></a>多表连接 (Multi-Relation)</h3><p>连接顺序的选择是指数级难题（n 个表连接有 4^n 种可能的顺序） 。</p>
<ol>
<li><p><strong>自底向上 (Bottom-up)</strong>：从单个表开始构建，通过动态规划寻找最优连接顺序（如 IBM System R, Postgres） 。</p>
</li>
<li><p><strong>自顶向下 (Top-down)</strong>：从目标结果出发，通过规则和分支限界搜索向下寻找最优物理算子（如 MSSQL, Volcano 模型） 。</p>
</li>
</ol>
<hr>
<h2 id="6-嵌套子查询优化"><a href="#6-嵌套子查询优化" class="headerlink" title="6. 嵌套子查询优化"></a>6. 嵌套子查询优化</h2><p>DBMS 会尝试“扁平化”子查询：</p>
<ul>
<li><p><strong>重写</strong>：将子查询改写为连接 (JOIN) 。</p>
</li>
<li><p><strong>分解</strong>：将复杂子查询的结果存入临时表，供外层查询使用 。</p>
</li>
</ul>
<hr>
<h3 id="补充：原理深度解析"><a href="#补充：原理深度解析" class="headerlink" title="补充：原理深度解析"></a>补充：原理深度解析</h3><p><strong>为什么连接顺序如此重要？</strong><br>在多表连接中，中间结果的大小直接决定了查询效率。如果先连接两个产生海量数据的表，内存和 I&#x2F;O 压力会瞬间激增。优化器的核心目标就是通过<strong>选择度估算</strong>，找到能让中间结果尽可能小的连接路径。</p>
<p>这份 CMU 15-445&#x2F;645 Database Systems (Fall 2024) Lecture #16 <strong>Concurrency Control Theory (并发控制理论)</strong> 的课程笔记整理如下。</p>
<p>这份笔记不仅总结了课件内容，还补充了相关原理的深度解析，旨在帮助你理解数据库如何在多用户并发访问时，依然保证数据的准确性和系统的稳定性。</p>
<hr>
<h1 id="第十六讲：Concurrency-Control-Theory-并发控制理论"><a href="#第十六讲：Concurrency-Control-Theory-并发控制理论" class="headerlink" title="第十六讲：Concurrency Control Theory (并发控制理论)"></a>第十六讲：Concurrency Control Theory (并发控制理论)</h1><h2 id="1-为什么需要并发控制？-Motivation"><a href="#1-为什么需要并发控制？-Motivation" class="headerlink" title="1. 为什么需要并发控制？(Motivation)"></a>1. 为什么需要并发控制？(Motivation)</h2><p>在数据库系统中，如果我们只是简单地让所有操作顺序执行（一次处理一个），虽然能保证不出错，但效率极低。我们需要让多个事务“并发”执行以提高系统吞吐量，但这带来了两个核心问题：</p>
<ol>
<li><p><strong>丢失更新 (Lost Update Problem)</strong>：由于竞争条件（Race Condition），两个事务同时更新同一条记录，导致其中一个更新被覆盖 。</p>
</li>
<li><p><strong>持久性问题 (Durability Problem)</strong>：如果系统断电或崩溃，如何确保已提交的数据不丢失，未提交的数据不残留 。</p>
</li>
</ol>
<hr>
<h2 id="2-事务-Transactions"><a href="#2-事务-Transactions" class="headerlink" title="2. 事务 (Transactions)"></a>2. 事务 (Transactions)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>事务是 DBMS 中变化的<strong>基本单位</strong>。它是一系列在共享数据库上执行的操作（如 SQL 查询）的序列，这些操作共同完成一个高级功能 。</p>
<ul>
<li><p><strong>原子性 (Atomic)</strong>：事务不可分割，要么全做，要么全不做（Partial transactions represent unfinished business）。</p>
</li>
<li><p><strong>示例</strong>：Andy 给 Promotor 转账 $100。</p>
<ol>
<li>检查 Andy 余额。</li>
<li>Andy 扣除 $100。</li>
<li>Promotor 增加 $100。</li>
</ol>
</li>
</ul>
<p><em>这三步必须作为一个整体，不能只做了前两步而没做第三步</em> 。</p>
<h3 id="“稻草人”系统-The-Strawman-System"><a href="#“稻草人”系统-The-Strawman-System" class="headerlink" title="“稻草人”系统 (The Strawman System)"></a>“稻草人”系统 (The Strawman System)</h3><p>这是一个用于对比的简单设计：系统只允许<strong>同一时间运行一个事务</strong>（单线程）。</p>
<ul>
<li><p><strong>执行方式</strong>：每次事务开始前，复制整个数据库文件，在副本上修改。如果成功，用副本覆盖原文件；如果失败，丢弃副本 。</p>
</li>
<li><p><strong>缺点</strong>：极慢（不支持并发）、空间浪费（每次都要复制整个库）。</p>
</li>
<li><p><strong>结论</strong>：我们需要允许<strong>并发执行 (Concurrent Execution)</strong>，但必须保证<strong>正确性 (Correctness)</strong> 和<strong>公平性 (Fairness)</strong> 。</p>
</li>
</ul>
<hr>
<h2 id="3-ACID-特性"><a href="#3-ACID-特性" class="headerlink" title="3. ACID 特性"></a>3. ACID 特性</h2><p>ACID 是确保数据库事务正确性的四个标准 。</p>
<h3 id="A-Atomicity-原子性"><a href="#A-Atomicity-原子性" class="headerlink" title="A - Atomicity (原子性)"></a>A - Atomicity (原子性)</h3><p>事务中的所有操作要么全部成功，要么全部失败（回滚）。即使系统在事务执行中途崩溃，重启后也不能残留只执行了一半的状态 。</p>
<p><strong>实现机制：</strong></p>
<ol>
<li><p><strong>日志 (Logging - 推荐)</strong>：DBMS 记录所有操作的日志（Undo Records）。如果事务中止，利用日志撤销已做的修改。这是现代数据库的标准做法，效率高 。</p>
</li>
<li><p><strong>影子分页 (Shadow Paging)</strong>：修改数据时，不直接改原页面，而是复制一份副本进行修改。提交时才将指针指向新页面。</p>
<ul>
<li><em>优点</em>：恢复简单（直接丢弃副本），不需要复杂的 Undo 日志。</li>
<li><em>缺点</em>：运行时性能差（数据碎片化、复制开销大），因此很少在高性能 DBMS 中使用 。</li>
</ul>
</li>
</ol>
<h3 id="C-Consistency-一致性"><a href="#C-Consistency-一致性" class="headerlink" title="C - Consistency (一致性)"></a>C - Consistency (一致性)</h3><p>一致性指数据库从一个“逻辑上正确”的状态转移到另一个“逻辑上正确”的状态 。</p>
<ul>
<li><p><strong>数据库一致性 (Database Consistency)</strong>：数据必须满足所有完整性约束（例如：年龄不能为负数，外键约束等）。</p>
</li>
<li><p><strong>事务一致性 (Transaction Consistency)</strong>：如果数据库在事务开始前是一致的，那么事务结束后也必须是一致的。<strong>注意：这是应用层（Application）的责任，DBMS 只能负责检查约束，无法判断业务逻辑是否正确</strong> 。</p>
</li>
</ul>
<h3 id="I-Isolation-隔离性"><a href="#I-Isolation-隔离性" class="headerlink" title="I - Isolation (隔离性)"></a>I - Isolation (隔离性)</h3><p>每个事务在执行时，应该感觉不到其他事务的存在。并发执行的结果必须与某种<strong>串行执行 (Serial Execution)</strong> 的结果相同 。</p>
<ul>
<li>这是并发控制（Concurrency Control）的核心目标。</li>
</ul>
<h3 id="D-Durability-持久性"><a href="#D-Durability-持久性" class="headerlink" title="D - Durability (持久性)"></a>D - Durability (持久性)</h3><p>一旦事务提交（Commit），其对数据库的修改就是永久的，即使随后发生系统崩溃或断电也不能丢失 。</p>
<ul>
<li>实现通常依赖于将日志或影子页面写入非易失性存储（磁盘） 。</li>
</ul>
<hr>
<h2 id="4-并发控制理论-Concurrency-Control-Theory"><a href="#4-并发控制理论-Concurrency-Control-Theory" class="headerlink" title="4. 并发控制理论 (Concurrency Control Theory)"></a>4. 并发控制理论 (Concurrency Control Theory)</h2><p>并发控制协议决定了 DBMS 如何在运行时交替执行多个事务的操作 。</p>
<h3 id="两种主要流派"><a href="#两种主要流派" class="headerlink" title="两种主要流派"></a>两种主要流派</h3><ol>
<li><p><strong>悲观并发控制 (Pessimistic)</strong>：假设冲突频繁发生，在操作前先加锁，阻止问题的发生（Don’t let problems arise）。</p>
</li>
<li><p><strong>乐观并发控制 (Optimistic)</strong>：假设冲突很少，先执行，在提交时检查是否冲突。如果冲突则回滚（Deal with conflicts after commit）。</p>
</li>
</ol>
<h3 id="调度-Schedule"><a href="#调度-Schedule" class="headerlink" title="调度 (Schedule)"></a>调度 (Schedule)</h3><p>调度是操作执行的顺序 。我们的目标是找到一种<strong>可串行化 (Serializable)</strong> 的调度。</p>
<ul>
<li><strong>串行调度 (Serial Schedule)</strong>：事务一个接一个执行，没有交错。</li>
<li><strong>可串行化调度 (Serializable Schedule)</strong>：一个并发调度的执行结果，等价于（Equivalent to）某种串行调度的结果。这种调度被认为是正确的 。</li>
</ul>
<h3 id="冲突-Conflicts"><a href="#冲突-Conflicts" class="headerlink" title="冲突 (Conflicts)"></a>冲突 (Conflicts)</h3><p>当两个操作满足以下三个条件时，称为冲突 ：</p>
<ol>
<li>属于不同的事务。</li>
<li>操作同一个对象。</li>
<li>至少有一个是<strong>写 (Write)</strong> 操作。</li>
</ol>
<p><strong>三种冲突类型：</strong></p>
<ol>
<li><p><strong>Read-Write (不可重复读)</strong>：Txn A 读取了数据，Txn B 修改了它。Txn A 再次读取时发现值变了 。</p>
</li>
<li><p><strong>Write-Read (脏读)</strong>：Txn A 修改了数据但未提交，Txn B 读取了这个未提交的数据。如果 Txn A 随后回滚，Txn B 读到的就是脏数据 。</p>
</li>
<li><p><strong>Write-Write (丢失更新)</strong>：Txn A 和 Txn B 同时修改同一数据，Txn B 的写覆盖了 Txn A 的写 。</p>
</li>
</ol>
<hr>
<h2 id="5-可串行化-Serializability-的类型"><a href="#5-可串行化-Serializability-的类型" class="headerlink" title="5. 可串行化 (Serializability) 的类型"></a>5. 可串行化 (Serializability) 的类型</h2><p>我们需要一种形式化的方法来判断一个调度是否是“正确”的（即可串行化的）。</p>
<h3 id="1-冲突可串行化-Conflict-Serializability"><a href="#1-冲突可串行化-Conflict-Serializability" class="headerlink" title="(1) 冲突可串行化 (Conflict Serializability)"></a>(1) 冲突可串行化 (Conflict Serializability)</h3><p>这是大多数 DBMS 实际采用的标准 。</p>
<ul>
<li><p><strong>定义</strong>：如果一个调度可以通过交换<strong>不冲突</strong>的操作，转换成一个串行调度，那它就是冲突可串行化的 。</p>
</li>
<li><p><strong>检测方法 - 依赖图 (Dependency Graph)</strong>：</p>
<ul>
<li>节点是事务。</li>
<li>如果 $T_i$ 的操作与 $T_j$ 的操作冲突，且 $T_i$ 在 $T_j$ 之前执行，则画一条 $T_i \to T_j$ 的边 。</li>
</ul>
</li>
<li><p><strong>定理</strong>：如果依赖图<strong>没有环 (Acyclic)</strong>，则调度是冲突可串行化的 。</p>
</li>
</ul>
<h3 id="2-视图可串行化-View-Serializability"><a href="#2-视图可串行化-View-Serializability" class="headerlink" title="(2) 视图可串行化 (View Serializability)"></a>(2) 视图可串行化 (View Serializability)</h3><p>这是一个比冲突可串行化更弱（包含范围更广）的概念 。</p>
<ul>
<li><p><strong>关键点</strong>：它允许<strong>盲写 (Blind Writes)</strong>（即不读数据直接写入）。</p>
</li>
<li><p><strong>原理</strong>：只要最终的数据库状态和某种串行执行的结果一致即可。即使中间过程有冲突，如果最后的盲写覆盖了错误，那也是可接受的 。</p>
</li>
<li><p><strong>现状</strong>：很难高效地验证（通常是 NP 完全问题），所以数据库系统<strong>实际上不使用</strong>它，而是坚持使用冲突可串行化 。</p>
</li>
</ul>
<h3 id="调度集合的关系-Universe-of-Schedules"><a href="#调度集合的关系-Universe-of-Schedules" class="headerlink" title="调度集合的关系 (Universe of Schedules)"></a>调度集合的关系 (Universe of Schedules)</h3><h2 id="描述了包含关系：-text-Serial-subset-text-Conflict-Serializable-subset-text-View-Serializable-subset-text-All-Schedules"><a href="#描述了包含关系：-text-Serial-subset-text-Conflict-Serializable-subset-text-View-Serializable-subset-text-All-Schedules" class="headerlink" title=" 描述了包含关系：$$\text{Serial} \subset \text{Conflict Serializable} \subset \text{View Serializable} \subset \text{All Schedules}$$"></a> 描述了包含关系：<br>$$\text{Serial} \subset \text{Conflict Serializable} \subset \text{View Serializable} \subset \text{All Schedules}$$</h2><h3 id="补充总结：理解的核心逻辑"><a href="#补充总结：理解的核心逻辑" class="headerlink" title="补充总结：理解的核心逻辑"></a>补充总结：理解的核心逻辑</h3><ol>
<li><strong>目标</strong>：我们想要并发（快），但不能乱（正确）。</li>
<li><strong>标准</strong>：什么叫“不乱”？标准是 ACID 中的 <strong>Isolation</strong>。</li>
<li><strong>度量</strong>：怎么判断 Isolation 达标了？看这个调度是否 <strong>Serializable</strong>（等价于串行）。</li>
<li><strong>实现</strong>：怎么判断是否 Serializable？</li>
</ol>
<ul>
<li><strong>View Serializability</strong> 理论完美但太难算。</li>
<li><strong>Conflict Serializability</strong> 容易算（查有无环），虽然漏掉了一些盲写的情况，但足够好用。</li>
</ul>
<ol start="5">
<li><strong>手段</strong>：怎么保证生成的调度是 Conflict Serializable 的？通过锁（2PL）或时间戳排序（Timestamp Ordering）等协议（这是下一节课的内容）。</li>
</ol>
<p>这份 CMU 15-445&#x2F;645 Database Systems (Fall 2024) Lecture #17 <strong>Two-Phase Locking (二阶段锁)</strong> 的课程笔记整理如下。</p>
<p>这份笔记在总结课件核心内容的基础上，补充了相关原理的对比和解析，旨在帮助你理解数据库如何通过锁机制“动态地”保证事务的正确性（可串行化）。</p>
<hr>
<h1 id="第十七讲：Two-Phase-Locking-二阶段锁"><a href="#第十七讲：Two-Phase-Locking-二阶段锁" class="headerlink" title="第十七讲：Two-Phase Locking (二阶段锁)"></a>第十七讲：Two-Phase Locking (二阶段锁)</h1><h2 id="1-事务锁-Transaction-Locks"><a href="#1-事务锁-Transaction-Locks" class="headerlink" title="1. 事务锁 (Transaction Locks)"></a>1. 事务锁 (Transaction Locks)</h2><p>在之前的理论课中，我们假设在安排调度时已经知道所有事务的读写操作。但在现实中，DBMS 无法预知未来。因此，我们需要一种机制在<strong>运行时 (On-the-fly)</strong> 动态生成正确的调度。</p>
<h3 id="锁的本质"><a href="#锁的本质" class="headerlink" title="锁的本质"></a>锁的本质</h3><p>DBMS 使用<strong>锁 (Locks)</strong> 来保护数据库对象，防止多个事务同时读写造成冲突。</p>
<ul>
<li><p><strong>锁管理器 (Lock Manager)</strong>：一个中心化的组件，负责维护内部的锁表 (Lock Table)，决定是否批准事务的锁请求 。</p>
</li>
<li><p><strong>锁 vs. Latch</strong>：这是一个常考的面试点 。</p>
<ul>
<li><strong>Locks</strong>：保护数据库的逻辑内容（如元组、表），属于事务层，持续时间长（整个事务期间），支持回滚。</li>
<li><strong>Latches</strong>：保护 DBMS 内部的数据结构（如 B+ 树节点、哈希表 bucket），属于线程&#x2F;物理层，持续时间极短（临界区），不需要回滚。</li>
</ul>
</li>
</ul>
<h3 id="基本锁类型"><a href="#基本锁类型" class="headerlink" title="基本锁类型"></a>基本锁类型</h3><ol>
<li><p><strong>Shared Lock (S-LOCK &#x2F; 共享锁)</strong>：</p>
<ul>
<li><strong>用途</strong>：用于<strong>读取</strong>对象。</li>
<li><strong>兼容性</strong>：多个事务可以同时持有同一个对象的 S 锁（即多读不互斥）。</li>
</ul>
</li>
<li><p><strong>Exclusive Lock (X-LOCK &#x2F; 排他锁)</strong>：</p>
<ul>
<li><strong>用途</strong>：用于<strong>修改</strong>对象。</li>
<li><strong>兼容性</strong>：如果一个对象被加了 X 锁，其他任何事务都不能对它加任何锁（S 或 X）。X 锁必须独占 。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-二阶段锁协议-Two-Phase-Locking-2PL"><a href="#2-二阶段锁协议-Two-Phase-Locking-2PL" class="headerlink" title="2. 二阶段锁协议 (Two-Phase Locking - 2PL)"></a>2. 二阶段锁协议 (Two-Phase Locking - 2PL)</h2><p>仅仅有锁是不够的，如果事务随意加锁解锁，依然可能导致不可串行化的结果。<strong>2PL</strong> 是一种悲观的并发控制协议，它规定了事务<strong>何时</strong>可以加锁和解锁，以此来保证冲突可串行化（Conflict Serializability）。</p>
<h3 id="协议规则"><a href="#协议规则" class="headerlink" title="协议规则"></a>协议规则</h3><p>2PL 将事务的执行分为两个阶段 ：</p>
<ol>
<li><p><strong>增长阶段 (Growing Phase)</strong>：</p>
<ul>
<li>事务可以<strong>申请</strong>新锁（S 或 X）。</li>
<li><strong>绝对不允许</strong>释放任何锁。</li>
</ul>
</li>
<li><p><strong>缩减阶段 (Shrinking Phase)</strong>：</p>
<ul>
<li>一旦事务释放了第一个锁，就立即进入缩减阶段。</li>
<li>在此阶段，事务只能<strong>释放</strong>锁。</li>
<li><strong>绝对不允许</strong>申请新锁。</li>
</ul>
</li>
</ol>
<h3 id="2PL-的性质"><a href="#2PL-的性质" class="headerlink" title="2PL 的性质"></a>2PL 的性质</h3><ul>
<li><p><strong>正确性</strong>：2PL 足以保证生成的调度是<strong>冲突可串行化</strong>的（Dependency Graph 无环）。</p>
</li>
<li><p><strong>问题 1：级联中止 (Cascading Aborts)</strong>：</p>
<ul>
<li>如果 T1 写了数据 A（未提交），T2 读了 A。此时 T1 中止（回滚），T2 读到的就是脏数据，必须也被强制中止。这会导致连锁反应，浪费大量计算资源 。</li>
</ul>
</li>
<li><p><strong>问题 2：死锁 (Deadlocks)</strong>：2PL 可能导致死锁（互相等待）。</p>
</li>
</ul>
<h3 id="强严格二阶段锁-Strong-Strict-2PL-SS2PL"><a href="#强严格二阶段锁-Strong-Strict-2PL-SS2PL" class="headerlink" title="强严格二阶段锁 (Strong Strict 2PL &#x2F; SS2PL)"></a>强严格二阶段锁 (Strong Strict 2PL &#x2F; SS2PL)</h3><p>为了解决级联中止问题，现代 DBMS 通常使用 SS2PL（也称为 Rigorous 2PL）。</p>
<ul>
<li><p><strong>规则</strong>：事务只能在<strong>提交 (Commit)</strong> 或 <strong>中止 (Abort)</strong> 的那一刻，一次性释放<strong>所有</strong>的锁 。</p>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>无级联中止</strong>：只有已提交的数据才能被别人读到。</li>
<li><strong>恢复简单</strong>：回滚时只需恢复旧值，不会影响其他正在运行的事务 。</li>
</ul>
</li>
<li><p><strong>代价</strong>：持锁时间变长，并发度降低 。</p>
</li>
</ul>
<p><strong>调度集合的关系</strong>：</p>
<h2 id="text-Strong-Strict-2PL-subset-text-Conflict-Serializable-subset-text-View-Serializable-subset-text-All-Schedules"><a href="#text-Strong-Strict-2PL-subset-text-Conflict-Serializable-subset-text-View-Serializable-subset-text-All-Schedules" class="headerlink" title="$$\text{Strong Strict 2PL} \subset \text{Conflict Serializable} \subset \text{View Serializable} \subset \text{All Schedules}$$"></a>$$\text{Strong Strict 2PL} \subset \text{Conflict Serializable} \subset \text{View Serializable} \subset \text{All Schedules}$$</h2><h2 id="3-死锁处理-Deadlock-Handling"><a href="#3-死锁处理-Deadlock-Handling" class="headerlink" title="3. 死锁处理 (Deadlock Handling)"></a>3. 死锁处理 (Deadlock Handling)</h2><p>死锁是指两个或多个事务互相持有对方需要的锁，导致无限等待 。处理死锁有两种策略：</p>
<h3 id="策略-1-死锁检测-Deadlock-Detection"><a href="#策略-1-死锁检测-Deadlock-Detection" class="headerlink" title="策略 #1: 死锁检测 (Deadlock Detection)"></a>策略 #1: 死锁检测 (Deadlock Detection)</h3><p>DBMS 允许死锁发生，但会定期检查并打破它。</p>
<ul>
<li><p><strong>等待图 (Waits-for Graph)</strong>：节点是事务，边$T_i \to T_j$ 表示 $T_i$ 正在等待 $T_j$ 释放锁。如果图中出现<strong>环</strong>，说明有死锁 。</p>
</li>
<li><p><strong>处理流程</strong>：后台线程定期构建等待图。如果发现环，选择一个<strong>受害者 (Victim)</strong> 事务进行回滚 。</p>
</li>
<li><p><strong>受害者选择标准</strong>：</p>
<ul>
<li><p><strong>年龄</strong>（通常杀年轻的，保护老的）。</p>
</li>
<li><p><strong>进度</strong>（杀进度少的）。</p>
</li>
<li><p><strong>锁数量</strong>（杀持有锁少的，回滚开销小）。</p>
</li>
<li><p><strong>防饥饿</strong>：如果一个事务每次都被杀，它会“饥饿”。系统应记录它被杀的次数，下次提高它的优先级 。</p>
</li>
</ul>
</li>
</ul>
<h3 id="策略-2-死锁预防-Deadlock-Prevention"><a href="#策略-2-死锁预防-Deadlock-Prevention" class="headerlink" title="策略 #2: 死锁预防 (Deadlock Prevention)"></a>策略 #2: 死锁预防 (Deadlock Prevention)</h3><p>DBMS 在事务申请锁时就扼杀死锁的可能性，不允许出现循环等待。这通常基于<strong>时间戳 (Timestamp)</strong> 分配优先级（越老优先级越高）。</p>
<ul>
<li><p><strong>Wait-Die (老等，少死)</strong>：</p>
<ul>
<li>如果请求者优先级 <strong>高</strong> (老)：允许等待 (Wait)。</li>
<li>如果请求者优先级 <strong>低</strong> (新)：自己中止 (Die)。</li>
</ul>
</li>
<li><p><strong>Wound-Wait (老杀，少等)</strong>：</p>
<ul>
<li>如果请求者优先级 <strong>高</strong> (老)：强制抢占，把持有者中止 (Wound)。</li>
<li>如果请求者优先级 <strong>低</strong> (新)：老实等待 (Wait)。</li>
</ul>
</li>
</ul>
<p><strong>记忆口诀</strong>：如果协议名是 X-Y，请求者优先级<strong>高</strong>时做 X，<strong>低</strong>时做 Y 。</p>
<hr>
<h2 id="4-锁的粒度-Lock-Granularities"><a href="#4-锁的粒度-Lock-Granularities" class="headerlink" title="4. 锁的粒度 (Lock Granularities)"></a>4. 锁的粒度 (Lock Granularities)</h2><p>如果一个事务要更新 10 亿条记录：</p>
<ul>
<li><p>申请 10 亿个 Tuple Lock？太慢，锁管理器内存爆炸 。</p>
</li>
<li><p>申请 1 个 Table Lock？太粗，阻塞了所有其他只读该表一行的事务 。</p>
</li>
</ul>
<p><strong>解决方案</strong>：多粒度锁 (Lock Hierarchy)。</p>
<ul>
<li><p><strong>层级</strong>：Database \to Table \to Page \to Tuple 。</p>
</li>
<li><p><strong>意向锁 (Intention Locks)</strong>：</p>
<ul>
<li>当事务想给底层节点（如 Tuple）加锁时，必须先给上层节点（如 Table, Page）加<strong>意向锁</strong>。</li>
<li>这就像在大楼门口挂个牌子：“里面有人正在干活，别锁大门”。这样其他事务想锁整个表时，看一眼表上的意向锁就知道不行，不用逐行检查 。</li>
</ul>
</li>
</ul>
<p><strong>意向锁类型</strong> ：</p>
<ol>
<li><strong>IS (Intention-Shared)</strong>：打算在底层加 S 锁。</li>
<li><strong>IX (Intention-Exclusive)</strong>：打算在底层加 X 锁。</li>
<li><strong>SIX (Shared + Intention-Exclusive)</strong>：我读整个子树（S），同时我要修改底层的某些节点（IX）。（例如：全表扫描并更新部分行）。</li>
</ol>
<p><strong>锁升级 (Lock Escalation)</strong>：当 DBMS 发现一个事务在某个对象上持有的锁太多（例如在一个表里锁了 1000 行），它会自动将这些细粒度锁合并成一个粗粒度锁（把 1000 个行锁升级为 1 个表锁），以节省资源 。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>2PL</strong> 解决了并发执行的<strong>正确性</strong>问题（通过强制两阶段）。</li>
<li><strong>Strong Strict 2PL</strong> 进一步解决了<strong>级联回滚</strong>问题。</li>
<li><strong>死锁检测&#x2F;预防</strong> 解决了 2PL 带来的<strong>死锁</strong>副作用。</li>
<li><strong>意向锁</strong> 解决了锁管理的<strong>性能与并发度平衡</strong>问题。</li>
</ul>
<p>这份笔记基于 CMU 15-445&#x2F;645 课程的第 17 讲（Lecture #17: Timestamp Ordering Concurrency Control），系统地总结了基于时间戳的并发控制协议、乐观并发控制（OCC）、幻读问题及其解决方案。</p>
<hr>
<h1 id="第十八讲：时间戳排序并发控制-Timestamp-Ordering"><a href="#第十八讲：时间戳排序并发控制-Timestamp-Ordering" class="headerlink" title="第十八讲：时间戳排序并发控制 (Timestamp Ordering)"></a>第十八讲：时间戳排序并发控制 (Timestamp Ordering)</h1><h2 id="1-时间戳排序协议-Timestamp-Ordering-T-O"><a href="#1-时间戳排序协议-Timestamp-Ordering-T-O" class="headerlink" title="1. 时间戳排序协议 (Timestamp Ordering, T&#x2F;O)"></a>1. 时间戳排序协议 (Timestamp Ordering, T&#x2F;O)</h2><p>时间戳排序是一种<strong>乐观 (Optimistic)</strong> 的并发控制协议 。与悲观协议（如 2PL）不同，它不要求事务在读写前获取锁，而是利用时间戳来决定事务的串行化顺序 。</p>
<ul>
<li><p><strong>核心原理</strong>：为每个事务 T_{i} 分配一个唯一且单调递增的时间戳 TS(T_{i}) 。</p>
</li>
<li><p><strong>串行顺序</strong>：如果 TS(T_{i}) &lt; TS(T_{j})，DBMS 必须确保执行结果等价于 T_{i} 在 T_{j} 之前执行的串行计划 。</p>
</li>
<li><p><strong>分配策略</strong>：</p>
</li>
<li><p><strong>系统时钟</strong>：可能存在夏令时等边缘问题 。</p>
</li>
<li><p><strong>逻辑计数器</strong>：存在溢出问题，且在分布式系统中难以维护 。</p>
</li>
<li><p><strong>混合方式</strong>：结合上述两种方法 。</p>
</li>
</ul>
<hr>
<h2 id="2-乐观并发控制-Optimistic-Concurrency-Control-OCC"><a href="#2-乐观并发控制-Optimistic-Concurrency-Control-OCC" class="headerlink" title="2. 乐观并发控制 (Optimistic Concurrency Control, OCC)"></a>2. 乐观并发控制 (Optimistic Concurrency Control, OCC)</h2><p>OCC 假设事务冲突极少发生，适用于读多写少或访问数据不重叠的场景 。</p>
<p>OCC 的三个阶段 </p>
<ol>
<li><p><strong>Read Phase (读取阶段)</strong>：DBMS 为每个事务创建一个私有工作空间 。事务读取的对象被复制到工作空间，所有的修改也仅应用于该空间 。</p>
</li>
<li><p><strong>Validation Phase (验证阶段)</strong>：当事务提交时，DBMS 检查其写集是否与其他事务冲突 。</p>
</li>
<li><p><strong>Write Phase (写入阶段)</strong>：如果验证通过，将私有空间中的修改应用到全局数据库；否则，中止并重启事务 。</p>
</li>
</ol>
<h3 id="验证逻辑-Validation-Phase"><a href="#验证逻辑-Validation-Phase" class="headerlink" title="验证逻辑 (Validation Phase)"></a>验证逻辑 (Validation Phase)</h3><p>DBMS 在验证阶段为事务分配时间戳 。为了确保串行化，必须检查 T_{i} 与其他事务之间的读写（RW）和写写（WW）冲突 。</p>
<ul>
<li><p><strong>前向验证 (Forward Validation)</strong>：检查提交事务与所有正在运行的事务之间的冲突 。</p>
</li>
<li><p><strong>后向验证 (Backward Validation)</strong>：检查提交事务与已提交事务之间的冲突 。</p>
</li>
</ul>
<p><strong>验证成功必须满足的条件（以 TS(T_{i}) &lt; TS(T_{j}) 为例）</strong>：</p>
<ul>
<li><p>条件 1：$T_{i}$ 在 $T_{j}$ 开始前完成所有阶段 。</p>
</li>
<li><p>条件 2：$T_{i}$ 在 $T_{j}$ 开始写入前完成写入，且 $T_{i}$ 的写集与 $T_{j}$ 的读集不相交（$WriteSet(T_{i}) \cap ReadSet(T_{j}) &#x3D; \emptyset$） 。</p>
</li>
<li><p>条件 3：$T_{i}$ 在 $T_{j}$ 完成读取前完成其读取，且 $T_{i}$ 的写集与 $T_{j}$ 的读集和写集都不相交 。</p>
</li>
</ul>
<hr>
<h2 id="3-动态数据库与幻读问题-Phantom-Problem"><a href="#3-动态数据库与幻读问题-Phantom-Problem" class="headerlink" title="3. 动态数据库与幻读问题 (Phantom Problem)"></a>3. 动态数据库与幻读问题 (Phantom Problem)</h2><p>当事务涉及插入、更新和删除时，仅锁定现有记录是不够的 。<strong>幻读</strong>是指一个事务在同一范围内执行两次相同的查询，却得到了不同的结果集 。</p>
<h3 id="解决幻读的方案"><a href="#解决幻读的方案" class="headerlink" title="解决幻读的方案"></a>解决幻读的方案</h3><ol>
<li><p><strong>重执行扫描 (Re-Execute Scans)</strong>：在提交时重新运行所有带有 <code>WHERE</code> 子句的查询，检查结果是否一致 。</p>
</li>
<li><p><strong>谓词锁 (Predicate Locking)</strong>：对查询的谓词属性加锁，但由于开销大，很少被实际应用 。</p>
</li>
<li><p><strong>索引锁 (Index Locking)</strong>：利用索引键保护数据范围 。</p>
<ul>
<li><p><strong>Key-Value Locks</strong>：锁定索引中的单个键值 。</p>
</li>
<li><p><strong>Gap Locks (间隙锁)</strong>：锁定键值之间的间隙，防止新数据插入该间隙 。</p>
</li>
<li><p><strong>Key-Range Locks</strong>：锁定一个键到下一个现有键之间的范围 。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="4-隔离级别-Isolation-Levels"><a href="#4-隔离级别-Isolation-Levels" class="headerlink" title="4. 隔离级别 (Isolation Levels)"></a>4. 隔离级别 (Isolation Levels)</h2><p>为了提高性能，DBMS 允许在串行化之外使用较弱的隔离级别 。</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读 (Dirty Read)</th>
<th align="left">不可重复读(Unrepeatable Read)</th>
<th align="left">幻读 (Phantom Read)</th>
<th align="left">常见实现方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERIALIZABLE</strong></td>
<td align="left">不允许</td>
<td align="left">不允许</td>
<td align="left">不允许</td>
<td align="left">严格 2PL + 幻读保护</td>
</tr>
<tr>
<td align="left"><strong>REPEATABLE READS</strong></td>
<td align="left">不允许</td>
<td align="left">不允许</td>
<td align="left"><strong>可能发生</strong></td>
<td align="left">严格 2PL</td>
</tr>
<tr>
<td align="left"><strong>READ COMMITTED</strong></td>
<td align="left">不允许</td>
<td align="left"><strong>可能发生</strong></td>
<td align="left"><strong>可能发生</strong></td>
<td align="left">写加锁，读后立即释放共享锁</td>
</tr>
<tr>
<td align="left"><strong>READ UNCOMMITTED</strong></td>
<td align="left"><strong>可能发生</strong></td>
<td align="left"><strong>可能发生</strong></td>
<td align="left"><strong>可能发生</strong></td>
<td align="left">写加锁，读不加共享锁</td>
</tr>
</tbody></table>
<hr>
<h3 id="补充理解：OCC-的代价"><a href="#补充理解：OCC-的代价" class="headerlink" title="补充理解：OCC 的代价"></a>补充理解：OCC 的代价</h3><p>虽然 OCC 避免了锁管理器的开销，但它并非完美。正如笔记中提到的，OCC 存在显著的<strong>数据复制开销</strong> 以及<strong>中止浪费</strong>（事务在执行完所有工作后才发现冲突被中止） 。因此，在冲突频繁的高压力环境下，OCC 的性能往往不如传统的 2PL。</p>
<p>这份 CMU 15-445&#x2F;645 Database Systems (Fall 2024) Lecture #19 <strong>Multi-Version Concurrency Control (多版本并发控制)</strong> 的课程笔记整理如下。</p>
<p>这份笔记在总结课件核心内容的基础上，补充了相关原理的深度解析，帮助你理解为什么现代数据库（如 Postgres, MySQL&#x2F;InnoDB, Oracle）几乎都使用 MVCC。</p>
<hr>
<h1 id="第十九讲：Multi-Version-Concurrency-Control-MVCC"><a href="#第十九讲：Multi-Version-Concurrency-Control-MVCC" class="headerlink" title="第十九讲：Multi-Version Concurrency Control (MVCC)"></a>第十九讲：Multi-Version Concurrency Control (MVCC)</h1><h2 id="1-核心概念：什么是-MVCC？"><a href="#1-核心概念：什么是-MVCC？" class="headerlink" title="1. 核心概念：什么是 MVCC？"></a>1. 核心概念：什么是 MVCC？</h2><p><strong>多版本并发控制 (MVCC)</strong> 不仅仅是一个具体的协议，而是一种通过维护数据的多个物理版本来实现并发控制的设计理念 。</p>
<ul>
<li><p><strong>基本原理</strong>：</p>
<ul>
<li><p>DBMS 为数据库中的每个逻辑对象（Logical Object）维护多个物理版本（Physical Versions）。</p>
</li>
<li><p><strong>写操作</strong>：当事务更新数据时，不是覆盖原数据，而是创建一个带有新时间戳的<strong>新版本</strong> 。</p>
</li>
<li><p><strong>读操作</strong>：当事务读取数据时，它读取的是该事务开始那一刻“可见”的最新版本（也就是快照）。</p>
</li>
</ul>
</li>
<li><p><strong>核心优势 ( The “Golden Rule” )</strong>：</p>
<blockquote>
<p><strong>Writers do not block readers, and readers do not block writers.</strong><br>(写操作不阻塞读操作，读操作也不阻塞写操作。)</p>
</blockquote>
</li>
</ul>
<p>这意味着一个事务在修改数据 A 的同时，另一个事务可以毫无阻碍地读取数据 A 的旧版本 。这比传统的二阶段锁（2PL）并发度高得多，因为在 2PL 中读写是互斥的。</p>
<p>注意：写操作之间仍然可能互相阻塞（Write-Write Conflict），通常通过对特定版本加锁解决 。</p>
<hr>
<h2 id="2-快照隔离-Snapshot-Isolation"><a href="#2-快照隔离-Snapshot-Isolation" class="headerlink" title="2. 快照隔离 (Snapshot Isolation)"></a>2. 快照隔离 (Snapshot Isolation)</h2><p>MVCC 天然支持<strong>快照隔离 (SI)</strong> 级别。</p>
<ul>
<li><p><strong>工作机制</strong>：</p>
<ul>
<li><p>事务开始时，DBMS 会为它拍一张“快照”（通常由 Transaction Status Table 和时间戳决定）。</p>
</li>
<li><p>事务在整个生命周期内，看到的数据都是基于这张快照的。它完全与其他并发事务隔离开来 。</p>
</li>
<li><p>这对<strong>只读事务</strong>是完美的，因为它们不需要任何锁，就能读到一致的数据 。</p>
</li>
</ul>
</li>
<li><p><strong>写冲突 (Write Conflicts)</strong>：</p>
<ul>
<li>如果两个事务试图更新同一个对象，<strong>先写者胜 (First Writer Wins)</strong> 。后来的写者要么等待，要么中止。</li>
</ul>
</li>
<li><p><strong>异常：写偏斜 (Write Skew)</strong>：</p>
<ul>
<li>这是 SI 隔离级别下特有的异常（在可串行化级别下不应发生）。</li>
</ul>
</li>
<li><p><strong>场景</strong>：两个并发事务读取了<strong>不同</strong>的对象，但修改导致了整体逻辑约束被破坏。</p>
</li>
<li><p><strong>例子</strong>：由于此时读写不互斥，如果事务 A 把所有白球涂黑，事务 B 把所有黑球涂白，最终结果可能既有黑又有白，这在串行执行中是不可能出现的 。</p>
</li>
</ul>
<hr>
<h2 id="3-MVCC-的四大设计决策"><a href="#3-MVCC-的四大设计决策" class="headerlink" title="3. MVCC 的四大设计决策"></a>3. MVCC 的四大设计决策</h2><p>实现 MVCC 需要解决四个主要的设计问题：</p>
<ol>
<li><strong>版本存储 (Version Storage)</strong>：怎么存？</li>
<li><strong>垃圾回收 (Garbage Collection)</strong>：怎么删？</li>
<li><strong>索引管理 (Index Management)</strong>：怎么找？</li>
<li><strong>删除处理 (Deletes)</strong>：怎么标？</li>
</ol>
<h3 id="1-版本存储-Version-Storage"><a href="#1-版本存储-Version-Storage" class="headerlink" title="(1) 版本存储 (Version Storage)"></a>(1) 版本存储 (Version Storage)</h3><p>每个逻辑元组（Tuple）都有一个<strong>版本链 (Version Chain)</strong>，这是一个按时间戳排序的链表 。索引通常指向链表的“头”。</p>
<p>主要有三种存储物理版本的方法：</p>
<ol>
<li><strong>Append-Only Storage (追加存储)</strong></li>
</ol>
<ul>
<li><p>所有版本（新旧）都混在同一个表中。更新时，直接在表中追加新行，并更新链表指针。</p>
</li>
<li><p><strong>链表顺序</strong>：</p>
<ul>
<li><em>Oldest-to-Newest (O2N)</em>：链表头是最老版本。缺点是读最新数据需要遍历整个链表（慢）。</li>
<li><em>Newest-to-Oldest (N2O)</em>：链表头是最新版本。优点是读取最快（因为大多数查询都查最新数据），缺点是每次更新都要修改索引指向新的头 。</li>
</ul>
</li>
<li><p><em>PostgreSQL 使用此方案。</em></p>
</li>
</ul>
<ol start="2">
<li><strong>Time-Travel Storage (时间旅行存储)</strong></li>
</ol>
<ul>
<li>主表只存<strong>最新</strong>版本。</li>
<li>旧版本被复制到一个单独的“历史表 (Time-Travel Table)”中。</li>
<li>优点是主表很紧凑，全表扫描快。</li>
</ul>
<ol start="3">
<li><strong>Delta Storage (增量存储)</strong></li>
</ol>
<ul>
<li>主表存最新版本。</li>
<li>“回滚段 (Delta Storage)”中只存储<strong>修改的值 (Delta&#x2F;Changes)</strong>，而不是完整的旧行。</li>
<li><strong>原理</strong>：想看旧版本？拿最新版本，逆向应用 Delta 算出来。<ul>
<li><em>优点</em>：写入极快，节省空间。<em>缺点</em>：读取旧版本慢（需要计算）。</li>
<li><em>MySQL (InnoDB) 和 Oracle 使用此方案。</em></li>
</ul>
</li>
</ul>
<h3 id="2-垃圾回收-Garbage-Collection-GC"><a href="#2-垃圾回收-Garbage-Collection-GC" class="headerlink" title="(2) 垃圾回收 (Garbage Collection - GC)"></a>(2) 垃圾回收 (Garbage Collection - GC)</h3><p>随着更新增多，旧版本会堆积。当没有活跃事务需要通过快照看到某个旧版本时，该版本就是“可回收”的 。</p>
<ol>
<li><strong>元组级 GC (Tuple-level GC)</strong></li>
</ol>
<ul>
<li><p><strong>后台清理 (Background Vacuuming)</strong>：后台线程定期扫描表，通过比对活跃事务的位图，清除不可见的版本 。</p>
</li>
<li><p><strong>协作清理 (Cooperative Cleaning)</strong>：工作线程（Worker）在执行查询扫描版本链时，顺手把不再需要的旧版本删掉（仅适用于 O2N 顺序）。</p>
</li>
</ul>
<ol start="2">
<li><strong>事务级 GC (Transaction-level GC)</strong></li>
</ol>
<ul>
<li>每个事务负责记录自己产生了哪些旧版本。当事务结束且确认这些版本不再被需要时，由系统回收。</li>
</ul>
<h3 id="3-索引管理-Index-Management"><a href="#3-索引管理-Index-Management" class="headerlink" title="(3) 索引管理 (Index Management)"></a>(3) 索引管理 (Index Management)</h3><p>在 MVCC 中，主键索引 (Primary Key Index) 总是指向版本链的头部 。难点在于<strong>辅助索引 (Secondary Indexes)</strong>。</p>
<p>如果更新了数据（导致产生了新版本的物理位置变化），辅助索引该怎么办？</p>
<ol>
<li><strong>逻辑指针 (Logical Pointers)</strong></li>
</ol>
<ul>
<li>辅助索引存储主键（或逻辑 ID），而不是物理地址。</li>
<li><em>查找路径</em>：辅助索引 -&gt; 主键 -&gt; 主键索引 -&gt; 物理地址。</li>
<li><em>优点</em>：更新数据时，不需要修改辅助索引（因为主键没变）。</li>
<li><em>缺点</em>：读数据多了一次查找（回表），慢。</li>
</ul>
<ol start="2">
<li><strong>物理指针 (Physical Pointers)</strong></li>
</ol>
<ul>
<li>辅助索引直接存储物理地址（指向版本链头）。</li>
<li><em>优点</em>：读数据快，一步到位。</li>
<li></li>
</ul>
<p><em>缺点</em>：<strong>写放大</strong>。一旦更新数据产生新版本，所有指向该数据的辅助索引都必须更新指向新地址 。</p>
<p><strong>重复键问题 (Duplicate Key Problem)</strong> ：<br>在 MVCC 中，索引可能包含同一个 Key 的多个条目（指向不同版本的元组）。索引结构必须支持非唯一 Key，即使是唯一索引在底层物理存储上也可能因为版本共存而出现重复。</p>
<h3 id="4-删除-Deletes"><a href="#4-删除-Deletes" class="headerlink" title="(4) 删除 (Deletes)"></a>(4) 删除 (Deletes)</h3><p>在 MVCC 中，物理删除也是一种“更新”。</p>
<ol>
<li><p><strong>Deleted Flag</strong>：在元组头加个标记，说“我被删了” 。</p>
</li>
<li><p><strong>Tombstone Tuple (墓碑元组)</strong>：插入一个特殊的空版本，标志着生命周期的结束 。<br>真正的物理删除由垃圾回收器（GC）稍后完成 。</p>
</li>
</ol>
<hr>
<h2 id="4-总结与补充"><a href="#4-总结与补充" class="headerlink" title="4. 总结与补充"></a>4. 总结与补充</h2><p>MVCC 是现代数据库并发控制的事实标准。</p>
<ul>
<li><strong>相比 2PL</strong>：MVCC 最大的贡献是解除了“读-写”阻塞。读操作永远不会因为写锁而被挂起，这对于以读为主的互联网应用至关重要。</li>
<li><strong>代价</strong>：<ol>
<li><strong>空间放大</strong>：需要存储多版本。</li>
<li><strong>管理开销</strong>：需要复杂的垃圾回收机制，否则数据库会无限膨胀（PostgreSQL 的 Vacuum 问题就是典型）。</li>
<li><strong>索引维护</strong>：更新操作可能导致严重的索引写放大。</li>
</ol>
</li>
</ul>
<h3 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h3><p>如果你的系统是<strong>写密集型 (Write-Heavy)</strong> 的，且几乎不读历史数据，Append-Only Storage 的 N2O 策略和 Delta Storage 哪个更好？</p>
<ul>
<li><em>分析</em>：Delta Storage 通常更好。因为 Append-Only 每次 Update 都要复制整个 Tuple，写放大严重；而 Delta 只存变更量，写入 I&#x2F;O 更小。这也是为什么写性能强悍的 InnoDB 选择 Delta Storage 的原因。</li>
</ul>
<p>这份笔记基于 CMU 15-445&#x2F;645 课程第 20 讲（Lecture #20: Database Logging），系统总结了数据库恢复算法、缓冲池管理策略、影子分页、预写日志（WAL）以及检查点机制。</p>
<hr>
<h1 id="第二十讲：数据库日志与故障恢复-Database-Logging"><a href="#第二十讲：数据库日志与故障恢复-Database-Logging" class="headerlink" title="第二十讲：数据库日志与故障恢复 (Database Logging)"></a>第二十讲：数据库日志与故障恢复 (Database Logging)</h1><h2 id="1-故障恢复概述-Crash-Recovery"><a href="#1-故障恢复概述-Crash-Recovery" class="headerlink" title="1. 故障恢复概述 (Crash Recovery)"></a>1. 故障恢复概述 (Crash Recovery)</h2><p>恢复算法是确保数据库在发生故障（如断电、系统崩溃）后，依然能保持<strong>一致性 (Consistency)</strong>、<strong>原子性 (Atomicity)</strong> 和<strong>持久性 (Durability)</strong> 的技术 。</p>
<h3 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h3><ul>
<li><p><strong>UNDO</strong>：撤销未完成或已回滚事务对数据库的影响 。</p>
</li>
<li><p><strong>REDO</strong>：重新应用已提交事务的影响，以确保持久性 。</p>
</li>
</ul>
<hr>
<h2 id="2-缓冲池管理策略-Buffer-Pool-Management-Policies"><a href="#2-缓冲池管理策略-Buffer-Pool-Management-Policies" class="headerlink" title="2. 缓冲池管理策略 (Buffer Pool Management Policies)"></a>2. 缓冲池管理策略 (Buffer Pool Management Policies)</h2><p>DBMS 必须平衡系统性能与数据安全性。这主要由两个策略决定：</p>
<h3 id="A-Steal-策略-窃取"><a href="#A-Steal-策略-窃取" class="headerlink" title="A. Steal 策略 (窃取)"></a>A. Steal 策略 (窃取)</h3><p>定义是否允许未提交的事务覆盖非易失性存储（磁盘）中最近提交的值 。</p>
<ul>
<li><p><strong>STEAL</strong>：允许 。优点是内存利用率高，但崩溃后需要 <strong>UNDO</strong> 。</p>
</li>
<li><p><strong>NO-STEAL</strong>：不允许 。不需要 UNDO，但事务修改量受限于可用内存 。</p>
</li>
</ul>
<h3 id="B-Force-策略-强制"><a href="#B-Force-策略-强制" class="headerlink" title="B. Force 策略 (强制)"></a>B. Force 策略 (强制)</h3><p>定义是否要求事务在提交前，将其所有更新都反映到磁盘上 。</p>
<ul>
<li><p><strong>FORCE</strong>：强制要求 。恢复简单，但由于涉及大量随机写，运行时性能极差 。</p>
</li>
<li><p><strong>NO-FORCE</strong>：不强制 。运行时性能最优，但崩溃后需要 <strong>REDO</strong> 。</p>
</li>
</ul>
<blockquote>
<p><strong>总结</strong>：现代主流 DBMS 通常采用 <strong>STEAL + NO-FORCE</strong> 策略，因为它能提供最佳的运行时性能 。</p>
</blockquote>
<hr>
<h2 id="3-影子分页-Shadow-Paging"><a href="#3-影子分页-Shadow-Paging" class="headerlink" title="3. 影子分页 (Shadow Paging)"></a>3. 影子分页 (Shadow Paging)</h2><p>这是一种早期的 <strong>NO-STEAL + FORCE</strong> 系统实现 。</p>
<ul>
<li><p><strong>原理</strong>：DBMS 维护两份页表：<strong>Master (主页表)</strong> 和 <strong>Shadow (影子页表)</strong> 。</p>
</li>
<li><p><strong>执行</strong>：写操作只发生在影子页表中 。</p>
</li>
<li><p><strong>提交</strong>：通过原子性地修改根节点指针，让主页表指向影子页表的内容 。</p>
</li>
<li><p><strong>缺点</strong>：复制页表开销大、导致随机写、造成数据碎片、且需要垃圾回收机制 。</p>
</li>
</ul>
<hr>
<h2 id="4-预写日志-Write-Ahead-Logging-WAL"><a href="#4-预写日志-Write-Ahead-Logging-WAL" class="headerlink" title="4. 预写日志 (Write-Ahead Logging, WAL)"></a>4. 预写日志 (Write-Ahead Logging, WAL)</h2><p>这是目前几乎所有数据库（如 PostgreSQL, MySQL, SQL Server）的标准做法 。</p>
<h3 id="核心准则-The-Golden-Rule"><a href="#核心准则-The-Golden-Rule" class="headerlink" title="核心准则 (The Golden Rule)"></a>核心准则 (The Golden Rule)</h3><p>在将数据页刷新到磁盘之前，必须先将对应修改的日志记录写入稳定存储（磁盘） 。</p>
<h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><ol>
<li><p>事务的所有日志记录先缓存在内存的 <strong>WAL Buffer</strong> 中 。</p>
</li>
<li><p>只有在事务的所有日志都刷入磁盘后，该事务才被认为已提交 。</p>
</li>
<li><p><strong>日志记录内容</strong>：事务 ID、对象 ID、<strong>Before Value (用于 UNDO)</strong>、<strong>After Value (用于 REDO)</strong> 。</p>
</li>
</ol>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>将随机写操作转变为顺序写日志，极大提升了系统吞吐量 。</p>
<hr>
<h2 id="5-日志记录方案-Logging-Schemes"><a href="#5-日志记录方案-Logging-Schemes" class="headerlink" title="5. 日志记录方案 (Logging Schemes)"></a>5. 日志记录方案 (Logging Schemes)</h2><p>日志中存储内容的粒度各不相同：</p>
<ul>
<li><p><strong>物理日志 (Physical Logging)</strong>：记录数据库特定位置的字节级更改（类似于 git diff） 。</p>
</li>
<li><p><strong>逻辑日志 (Logical Logging)</strong>：记录高层操作（如 <code>INSERT</code> 或 <code>UPDATE</code> 语句） 。存储量小，但并发环境下恢复极难且缓慢 。</p>
</li>
<li><p><strong>生理日志 (Physiological Logging)</strong>：<strong>最常用的方案</strong> 。日志针对单个数据页，但通过插槽号（Slot Number）标识元组，而不指定页内具体字节位置 。这允许 DBMS 在日志写盘后重新组织页面布局 。</p>
</li>
</ul>
<hr>
<h2 id="6-检查点-Checkpoints"><a href="#6-检查点-Checkpoints" class="headerlink" title="6. 检查点 (Checkpoints)"></a>6. 检查点 (Checkpoints)</h2><p>如果不受限制，WAL 日志会无限增长，导致系统崩溃后的恢复时间过长 。</p>
<ul>
<li><p><strong>机制</strong>：DBMS 定期执行检查点操作，将缓冲池中的所有脏页（Dirty Pages）刷新到磁盘，并写入一个 <code>&lt;CHECKPOINT&gt;</code> 记录 。</p>
</li>
<li><p><strong>阻塞式实现</strong>：停止接受新事务，等待当前事务完成，然后刷新数据 。这种方式虽然保证了一致性，但会造成性能瞬时下降 。</p>
</li>
</ul>
<hr>
<h3 id="补充：原理深度解析-1"><a href="#补充：原理深度解析-1" class="headerlink" title="补充：原理深度解析"></a>补充：原理深度解析</h3><p><strong>为什么随机写会严重拖慢性能？</strong><br>传统的机械硬盘（HDD）在进行随机读写时，需要频繁移动磁头（寻道），延迟极高。即便在 SSD 时代，随机写入也会触发复杂的垃圾回收（GC）和写放大效应 。WAL 将数据修改通过日志转化为<strong>顺序追加 (Sequential Append)</strong>，完美避开了磁盘性能的最弱项，这也是数据库能支撑高并发写操作的关键所在。</p>
<p>这份 CMU 15-445&#x2F;645 Database Systems (Fall 2024) Lecture #21 <strong>Database Crash Recovery (数据库崩溃恢复)</strong> 的课程笔记整理如下。</p>
<p>这份笔记在总结课件核心内容的基础上，补充了 <strong>ARIES</strong> 算法背后的设计哲学（如 STEAL&#x2F;NO-FORCE 策略），帮助你从原理层面理解数据库是如何在崩溃后“起死回生”的。</p>
<hr>
<h1 id="第二十一讲：Database-Crash-Recovery-数据库崩溃恢复"><a href="#第二十一讲：Database-Crash-Recovery-数据库崩溃恢复" class="headerlink" title="第二十一讲：Database Crash Recovery (数据库崩溃恢复)"></a>第二十一讲：Database Crash Recovery (数据库崩溃恢复)</h1><h2 id="1-核心背景：故障与恢复-Motivation"><a href="#1-核心背景：故障与恢复-Motivation" class="headerlink" title="1. 核心背景：故障与恢复 (Motivation)"></a>1. 核心背景：故障与恢复 (Motivation)</h2><p>DBMS 的恢复系统是为了确保在发生故障（如断电、崩溃）时，依然能维持 ACID 特性，特别是 <strong>Atomicity (原子性)</strong> 和 <strong>Durability (持久性)</strong> 。</p>
<h3 id="关键前提：STEAL-NO-FORCE-策略"><a href="#关键前提：STEAL-NO-FORCE-策略" class="headerlink" title="关键前提：STEAL + NO-FORCE 策略"></a>关键前提：STEAL + NO-FORCE 策略</h3><p>虽然课件中只简略提到了这几个词 ，但理解它们是理解 ARIES 的基础：</p>
<ol>
<li><strong>STEAL (允许偷跑)</strong>：DBMS 允许未提交事务（Uncommitted）修改的脏页被写入磁盘。</li>
</ol>
<ul>
<li><em>后果</em>：如果崩溃，磁盘上可能存有脏数据，恢复时必须 <strong>Undo (撤销)</strong> 这些更改。</li>
</ul>
<ol start="2">
<li><strong>NO-FORCE (非强制刷盘)</strong>：事务提交时，<strong>不强制</strong>将所有脏页立即刷入磁盘（只刷日志）。</li>
</ol>
<ul>
<li><em>后果</em>：如果崩溃，已提交的数据可能还没写入磁盘，恢复时必须 <strong>Redo (重做)</strong> 这些更改。</li>
</ul>
<p><strong>结论</strong>：因为现代数据库为了性能几乎都采用 <strong>STEAL + NO-FORCE</strong>，所以我们需要一个既能 Undo 又能 Redo 的恢复算法——即 <strong>ARIES</strong>。</p>
<hr>
<h2 id="2-ARIES-恢复算法概述"><a href="#2-ARIES-恢复算法概述" class="headerlink" title="2. ARIES 恢复算法概述"></a>2. ARIES 恢复算法概述</h2><p><strong>ARIES</strong> (Algorithms for Recovery and Isolation Exploiting Semantics) 是 IBM 在 90 年代研发的恢复算法，现在几乎是所有关系型数据库的标准 。它的三大核心原则是：</p>
<ol>
<li><p><strong>Write-Ahead Logging (WAL)</strong>：先写日志，后写数据页。任何修改必须先进入 Stable Storage（磁盘）上的日志文件，才能修改磁盘上的数据文件 。</p>
</li>
<li><p><strong>Repeating History (重演历史)</strong>：重启时，重新执行一遍崩溃发生前所有的操作（包括那些后来 abort 的操作），将数据库恢复到崩溃那一瞬间的“准确状态” 。</p>
</li>
<li><p><strong>Logging Changes During Undo (Undo 时也要写日志)</strong>：在撤销操作时，也会记录日志（称为 CLR）。这保证了如果恢复过程中再次崩溃，我们不会重复撤销已经撤销过的步骤 。</p>
</li>
</ol>
<hr>
<h2 id="3-日志与-LSN-Log-Sequence-Numbers"><a href="#3-日志与-LSN-Log-Sequence-Numbers" class="headerlink" title="3. 日志与 LSN (Log Sequence Numbers)"></a>3. 日志与 LSN (Log Sequence Numbers)</h2><p>为了追踪执行顺序，DBMS 使用 <strong>LSN (日志序列号)</strong>，它是全局唯一且单调递增的 。</p>
<h3 id="关键的-LSN-类型"><a href="#关键的-LSN-类型" class="headerlink" title="关键的 LSN 类型"></a>关键的 LSN 类型</h3><p>理解恢复过程需要分清以下几种 LSN 的位置和作用 ：</p>
<table>
<thead>
<tr>
<th>LSN 名称</th>
<th>位置</th>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>flushedLSN</strong></td>
<td>内存</td>
<td>已经写入磁盘的最新日志的 LSN</td>
<td>只有当  时，页面才能刷盘 。</td>
</tr>
<tr>
<td><strong>pageLSN</strong></td>
<td>数据页 (Page)</td>
<td>该页面最后一次被更新的 LSN</td>
<td>即使页面在磁盘上，我们也能知道它最后被谁改过。</td>
</tr>
<tr>
<td><strong>recLSN</strong></td>
<td>脏页表 (DPT)</td>
<td>该页面最早变脏的那条日志 LSN</td>
<td>用于恢复时确定 Redo 从哪里开始。</td>
</tr>
<tr>
<td><strong>lastLSN</strong></td>
<td>活跃事务表 (ATT)</td>
<td>事务  产生的最新一条日志 LSN</td>
<td>用于将同一事务的日志串联起来（链表）。</td>
</tr>
<tr>
<td><strong>MasterRecord</strong></td>
<td>磁盘</td>
<td>最近一次 Checkpoint 的 LSN</td>
<td>恢复的起点 。</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-正常执行时的关键机制-Normal-Execution"><a href="#4-正常执行时的关键机制-Normal-Execution" class="headerlink" title="4. 正常执行时的关键机制 (Normal Execution)"></a>4. 正常执行时的关键机制 (Normal Execution)</h2><h3 id="事务提交-Commit"><a href="#事务提交-Commit" class="headerlink" title="事务提交 (Commit)"></a>事务提交 (Commit)</h3><ol>
<li><p>写入 <code>COMMIT</code> 日志记录。</p>
</li>
<li><p><strong>强制刷新 (Flush)</strong> 日志到磁盘（直到包含该 <code>COMMIT</code> 记录）。注意：数据页不需要立即刷盘（NO-FORCE）。</p>
</li>
<li><p>向用户返回“成功”。</p>
</li>
<li><p>稍后写入 <code>TXN-END</code>（用于内部清理）。</p>
</li>
</ol>
<h3 id="事务中止-Abort-与-CLR"><a href="#事务中止-Abort-与-CLR" class="headerlink" title="事务中止 (Abort)与 CLR"></a>事务中止 (Abort)与 CLR</h3><p>当事务回滚时，其实也是一种“修改”（把数据改回旧值）。ARIES 会引入 <strong>CLR (Compensation Log Record，补偿日志记录)</strong> 。</p>
<ul>
<li><strong>CLR 的作用</strong>：记录“我做了一个撤销操作”。</li>
<li><strong>UndoNextLSN</strong>：CLR 中包含一个指针，指向<strong>下一个需要被 Undo 的 LSN</strong>。</li>
<li><strong>避免死循环</strong>：CLR 本身永远不需要被 Undo。如果在 Undo 过程中崩溃，重启后 DBMS 看到 CLR，会直接跳到 <code>UndoNextLSN</code> 继续撤销更早的操作，而不会重复撤销已经撤销过的步骤 。</li>
</ul>
<hr>
<h2 id="5-检查点-Checkpointing"><a href="#5-检查点-Checkpointing" class="headerlink" title="5. 检查点 (Checkpointing)"></a>5. 检查点 (Checkpointing)</h2><p>为了避免恢复时从头重放所有日志，DBMS 需要定期做 Checkpoint。</p>
<ul>
<li><p><strong>Blocking Checkpoint (阻塞式)</strong>：停止所有事务，刷脏页。简单但性能差 。</p>
</li>
<li><p><strong>Fuzzy Checkpoint (模糊&#x2F;非阻塞式)</strong>：ARIES 采用的方式 。</p>
<ul>
<li><p>允许事务在 Checkpoint 期间继续运行。</p>
</li>
<li><p>记录 <code>&lt;CHECKPOINT-BEGIN&gt;</code> 和 <code>&lt;CHECKPOINT-END&gt;</code>。</p>
</li>
<li><p>保存当前的 <strong>ATT (活跃事务表)</strong> 和 <strong>DPT (脏页表)</strong> 快照 。</p>
</li>
<li><p>这并不保证此时磁盘上的数据页是一致的，但通过日志重放可以修复。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="6-ARIES-恢复流程-The-3-Phases"><a href="#6-ARIES-恢复流程-The-3-Phases" class="headerlink" title="6. ARIES 恢复流程 (The 3 Phases)"></a>6. ARIES 恢复流程 (The 3 Phases)</h2><p>当数据库崩溃重启后，ARIES 分三个阶段执行恢复 。</p>
<h3 id="第一阶段：分析-Analysis"><a href="#第一阶段：分析-Analysis" class="headerlink" title="第一阶段：分析 (Analysis)"></a>第一阶段：分析 (Analysis)</h3><p><strong>目标</strong>：搞清楚崩溃那一刻，谁还在运行（需要 Undo），哪些页可能是脏的（需要 Redo）。</p>
<ol>
<li><p>从 <code>MasterRecord</code> 指向的 Checkpoint 开始扫描日志。</p>
</li>
<li><p><strong>重建 ATT (活跃事务表)</strong>：遇到 <code>BEGIN</code> 加入 ATT，遇到 <code>END</code> 移除。最终留下的就是崩溃时的“失败者 (Losers)” 。</p>
</li>
<li><p><strong>重建 DPT (脏页表)</strong>：遇到 <code>UPDATE</code> 且页面不在 DPT 中，则加入并记录 <code>recLSN</code> 。</p>
</li>
</ol>
<h3 id="第二阶段：重做-Redo-——-“Repeating-History”"><a href="#第二阶段：重做-Redo-——-“Repeating-History”" class="headerlink" title="第二阶段：重做 (Redo) —— “Repeating History”"></a>第二阶段：重做 (Redo) —— “Repeating History”</h3><p><strong>目标</strong>：将数据库状态<strong>完全</strong>恢复到崩溃发生的那一秒（包括已提交和未提交的修改）。</p>
<ol>
<li><p><strong>起点</strong>：从 DPT 中最小的 <code>recLSN</code> 开始读取日志 。</p>
</li>
<li><p><strong>操作</strong>：对每一条更新日志，判断是否需要重做。</p>
</li>
<li><p><strong>不需要重做的情况</strong> ：</p>
<ul>
<li>页面不在 DPT 中（说明早已刷盘）。</li>
<li>页面在 DPT 中，但日志 LSN &lt; <code>recLSN</code>（说明该更新在变脏之前）。</li>
<li><strong>最关键检查</strong>：从磁盘读取页面，如果磁盘上的 <code>pageLSN</code>  日志 LSN（说明磁盘上的页面已经是最新的了）。</li>
</ul>
</li>
<li><p><strong>执行</strong>：如果不满足上述条件，重新执行修改，并将页面的 <code>pageLSN</code> 更新为日志 LSN 。</p>
</li>
</ol>
<h3 id="第三阶段：撤销-Undo"><a href="#第三阶段：撤销-Undo" class="headerlink" title="第三阶段：撤销 (Undo)"></a>第三阶段：撤销 (Undo)</h3><p><strong>目标</strong>：回滚所有在崩溃时未提交的事务（即 ATT 中的 Losers）。</p>
<ol>
<li><p><strong>起点</strong>：处理所有 ATT 中状态为 Undo 的事务。</p>
</li>
<li><p><strong>顺序</strong>：按照 LSN <strong>从大到小 (Reverse Order)</strong> 回滚。</p>
</li>
<li><p><strong>执行</strong>：</p>
<ul>
<li><p>找到事务的最后一条记录 (<code>lastLSN</code>)。</p>
</li>
<li><p>执行逆操作。</p>
</li>
<li><p>为每个逆操作写入 <strong>CLR</strong> 日志 。</p>
</li>
<li><p>如果遇到 CLR，直接跳到 <code>undoNextLSN</code>（跳过已经撤销过的部分）。</p>
</li>
</ul>
</li>
<li><p><strong>结束</strong>：当所有 Loser 事务完全回滚，写入 <code>TXN-END</code> 。</p>
</li>
</ol>
<hr>
<h3 id="总结：为什么-ARIES-如此强大？"><a href="#总结：为什么-ARIES-如此强大？" class="headerlink" title="总结：为什么 ARIES 如此强大？"></a>总结：为什么 ARIES 如此强大？</h3><ol>
<li><strong>Redo 一切</strong>：它不猜测谁提交了谁没提交，先无脑重做所有历史，把状态恢复到崩溃点。这大大简化了逻辑。</li>
<li><strong>Undo Losers</strong>：在状态一致后，再精准地撤销未提交的事务。</li>
<li><strong>CLR 机制</strong>：确保了<strong>恢复过程本身也是可恢复的</strong>。如果恢复到一半又崩了，重启后不会把数据改乱。</li>
</ol>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>如果系统在 <strong>Redo 阶段</strong> 崩溃了怎么办？</p>
<ul>
<li><strong>答案</strong>：没关系。重启后再次运行 Redo。因为 Redo 操作是<strong>幂等 (Idempotent)</strong> 的（通过检查 <code>pageLSN</code>，如果 <code>pageLSN</code> 已经变大，就不会重复应用同一个 LSN 的修改）。</li>
</ul>
<p>这份笔记基于 CMU 15-445&#x2F;645 课程的第 22 讲（Lecture #22: Introduction to Distributed Databases），系统地总结了分布式数据库的核心架构、设计挑战及数据分区策略。</p>
<hr>
<h1 id="第二十二讲：分布式数据库导论"><a href="#第二十二讲：分布式数据库导论" class="headerlink" title="第二十二讲：分布式数据库导论"></a>第二十二讲：分布式数据库导论</h1><h2 id="1-分布式数据库概述-Overview"><a href="#1-分布式数据库概述-Overview" class="headerlink" title="1. 分布式数据库概述 (Overview)"></a>1. 分布式数据库概述 (Overview)</h2><p>分布式 DBMS 将单个逻辑数据库拆分并存储在多个物理资源（节点）上 。对于应用程序而言，这种拆分通常是透明的，即应用无需关心数据具体存放在哪里 。</p>
<p><strong>设计核心目标：</strong> <strong>容错性 (Fault Tolerance)</strong>。确保单个节点的故障不会导致整个系统的瘫痪 。</p>
<h3 id="分布式-Distributed-vs-并行-Parallel"><a href="#分布式-Distributed-vs-并行-Parallel" class="headerlink" title="分布式 (Distributed) vs. 并行 (Parallel)"></a>分布式 (Distributed) vs. 并行 (Parallel)</h3><p>虽然两者都利用多资源，但环境假设不同：</p>
<ul>
<li><p><strong>并行数据库 (Parallel DB)：</strong> 节点间物理距离近，通过高速 LAN 连接，通信成本低且极其可靠 。设计时通常不考虑丢包或节点崩溃 。</p>
</li>
<li><p><strong>分布式数据库 (Distributed DB)：</strong> 节点可能跨地域分布，通过公共网络连接，通信慢且不可靠 。通信开销和节点故障是设计中必须处理的一等公民 。</p>
</li>
</ul>
<hr>
<h2 id="2-系统架构-System-Architectures"><a href="#2-系统架构-System-Architectures" class="headerlink" title="2. 系统架构 (System Architectures)"></a>2. 系统架构 (System Architectures)</h2><p>架构决定了 CPU 可以直接访问哪些共享资源，直接影响协调效率和数据存储方式 。</p>
<table>
<thead>
<tr>
<th>架构类型</th>
<th>共享资源</th>
<th>特点与原理</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Shared Everything</strong></td>
<td>CPU, 内存, 磁盘</td>
<td>单机架构，所有资源由本地控制 。</td>
</tr>
<tr>
<td><strong>Shared Memory</strong></td>
<td>内存, 磁盘</td>
<td>多个 CPU 通过高速互连共享内存空间和磁盘 。在操作系统层面实现，实践中较少由 DBMS 直接采用 。</td>
</tr>
<tr>
<td><strong>Shared Disk</strong></td>
<td>磁盘</td>
<td>所有 CPU 共享一个逻辑磁盘，但拥有私有内存 。<strong>云原生数据库的主流</strong>，允许计算层与存储层独立扩展 。</td>
</tr>
<tr>
<td><strong>Shared Nothing</strong></td>
<td>无共享硬件</td>
<td>每个节点拥有独立的 CPU、内存和磁盘 。节点间仅通过网络通信 。</td>
</tr>
</tbody></table>
<h3 id="原理补充："><a href="#原理补充：" class="headerlink" title="原理补充："></a>原理补充：</h3><ul>
<li><p><strong>Shared Nothing 的难点：</strong> 增加容量时必须物理迁移数据，且跨节点一致性协调非常困难 。</p>
</li>
<li><p><strong>Shared Disk 的优势：</strong> 节点崩溃不影响数据库状态（状态存储在共享磁盘中），且节点可以缓存数据作为本地状态 。</p>
</li>
</ul>
<hr>
<h2 id="3-数据库分区方案-Partitioning-Schemes"><a href="#3-数据库分区方案-Partitioning-Schemes" class="headerlink" title="3. 数据库分区方案 (Partitioning Schemes)"></a>3. 数据库分区方案 (Partitioning Schemes)</h2><p>分区（在 NoSQL 中常称为 Sharding）旨在将数据分布到不同节点，以提高并行度 。</p>
<h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><ol>
<li><p><strong>幼稚分区 (Naive Partitioning)：</strong> 每个节点存储一张完整的表 。虽然简单，但难以扩展，且 JOIN 操作或访问不均时性能极差 。</p>
</li>
<li><p><strong>垂直分区 (Vertical Partitioning)：</strong> 将表的属性（列）拆分到不同分区 。</p>
</li>
<li><p><strong>水平分区 (Horizontal Partitioning)：</strong> 最常用的方式，将元组（行）拆分为不相交的子集 。通常选择一个列作为 <strong>分区键 (Partitioning Key)</strong> 。</p>
</li>
</ol>
<h3 id="一致性哈希-Consistent-Hashing"><a href="#一致性哈希-Consistent-Hashing" class="headerlink" title="一致性哈希 (Consistent Hashing)"></a>一致性哈希 (Consistent Hashing)</h3><p>传统的哈希分区（如 hash(key) \pmod n）在增加或删除节点时，会导致绝大部分数据需要重新分布 。一致性哈希解决了这个问题：</p>
<ul>
<li><p><strong>原理：</strong> 将所有节点和分区键映射到一个逻辑环上 。键由顺时针方向最近的节点负责 。</p>
</li>
<li><p><strong>优势：</strong> 当节点变动时，仅影响环上相邻的节点，只有 1&#x2F;n 的键需要迁移 。</p>
</li>
</ul>
<hr>
<h2 id="4-分布式并发控制-Distributed-Concurrency-Control"><a href="#4-分布式并发控制-Distributed-Concurrency-Control" class="headerlink" title="4. 分布式并发控制 (Distributed Concurrency Control)"></a>4. 分布式并发控制 (Distributed Concurrency Control)</h2><p>分布式事务涉及多个分区，需要昂贵的协调成本 。</p>
<ul>
<li><p><strong>集中式协调器 (Centralized Coordinator)：</strong> 一个全局的“交通警察”负责分配锁和管理事务 。</p>
</li>
<li><p><strong>优点：</strong> 易于实现分布式 2PL，拥有全局视图，能快速处理死锁 。</p>
</li>
<li><p><strong>缺点：</strong> 在高并发下容易成为性能瓶颈 。</p>
</li>
<li><p><strong>分散式协调器 (Decentralized Coordinator)：</strong> 节点间自组织，客户端直接与某个“主分区”通信，由该分区负责与其他节点协调 。</p>
</li>
</ul>
<hr>
<h2 id="5-联邦数据库-Federated-Databases"><a href="#5-联邦数据库-Federated-Databases" class="headerlink" title="5. 联邦数据库 (Federated Databases)"></a>5. 联邦数据库 (Federated Databases)</h2><p>这是一种将多个互不相同的 DBMS 逻辑连接成一个单一系统的架构 。</p>
<ul>
<li><p><strong>实现：</strong> 通过中间件（Middleware）和连接器（Connector）将查询转换为各个后端数据库可读的格式 。</p>
</li>
<li><p><strong>挑战：</strong> 由于不同系统的查询语言、数据模型和限制各不相同，很难进行统一的查询优化 。</p>
</li>
</ul>
<hr>
<h3 id="原理深度总结：透明性-Transparency"><a href="#原理深度总结：透明性-Transparency" class="headerlink" title="原理深度总结：透明性 (Transparency)"></a>原理深度总结：透明性 (Transparency)</h3><p>分布式系统的终极目标是<strong>数据透明性</strong> 。即用户发送一条 SQL 查询，他不应该知道这条查询是在单节点执行，还是被切成了 100 个碎片在不同机器上跑，更不应该知道数据是按哈希分布还是按范围分布的 。</p>
<p>这份 CMU 15-445&#x2F;645 Database Systems (Fall 2024) Lecture #23 <strong>Distributed OLTP Databases (分布式 OLTP 数据库)</strong> 的课程笔记整理如下。</p>
<p>这份笔记不仅总结了课件的核心内容，还补充了分布式系统中关键的设计权衡（Trade-offs）和原理深度解析，帮助你理解如何构建一个既可靠又高效的分布式数据库。</p>
<hr>
<h1 id="第二十三讲：Distributed-OLTP-Databases-分布式-OLTP-数据库"><a href="#第二十三讲：Distributed-OLTP-Databases-分布式-OLTP-数据库" class="headerlink" title="第二十三讲：Distributed OLTP Databases (分布式 OLTP 数据库)"></a>第二十三讲：Distributed OLTP Databases (分布式 OLTP 数据库)</h1><h2 id="1-背景：OLTP-与-OLAP-的区别"><a href="#1-背景：OLTP-与-OLAP-的区别" class="headerlink" title="1. 背景：OLTP 与 OLAP 的区别"></a>1. 背景：OLTP 与 OLAP 的区别</h2><p>在讨论分布式架构之前，首先要明确我们针对的工作负载类型，本节课关注的是 <strong>OLTP</strong>。</p>
<ul>
<li><p><strong>OLTP (On-line Transaction Processing)</strong>：</p>
<ul>
<li><p><strong>特点</strong>：短生命周期的读写事务，操作重复性高，占用资源少（Small footprint）。</p>
</li>
<li><p><strong>目标</strong>：高吞吐量、低延迟。</p>
</li>
</ul>
</li>
<li><p><strong>OLAP (On-line Analytical Processing)</strong>：</p>
<ul>
<li><p><strong>特点</strong>：长运行时间的只读查询，涉及复杂的连接（Joins），通常是探索性的分析查询 。</p>
</li>
<li><p><strong>目标</strong>：扫描大量数据并聚合结果。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-分布式架构基础-System-Architecture"><a href="#2-分布式架构基础-System-Architecture" class="headerlink" title="2. 分布式架构基础 (System Architecture)"></a>2. 分布式架构基础 (System Architecture)</h2><p>在分布式 OLTP 系统中，数据被分片（Partition）存储在多个节点上。</p>
<h3 id="去中心化协调-Decentralized-Coordinator"><a href="#去中心化协调-Decentralized-Coordinator" class="headerlink" title="去中心化协调 (Decentralized Coordinator)"></a>去中心化协调 (Decentralized Coordinator)</h3><ul>
<li><p><strong>架构</strong>：应用服务器直接与某个节点通信。通常会选出一个分区作为<strong>主节点 (Primary Node)</strong> 。</p>
</li>
<li><p><strong>流程</strong>：</p>
<ol>
<li>事务的 <code>BEGIN</code> 请求发送给主节点。</li>
<li>查询被直接路由到相关节点。</li>
<li><code>COMMIT</code> 请求发送给主节点，由主节点负责判断是否所有参与节点都同意提交 。</li>
</ol>
</li>
<li><p><strong>挑战</strong>：需要确保即使节点故障或消息延迟，所有节点对事务的结果（提交或中止）也能达成一致 。</p>
</li>
</ul>
<hr>
<h2 id="3-复制-Replication"><a href="#3-复制-Replication" class="headerlink" title="3. 复制 (Replication)"></a>3. 复制 (Replication)</h2><p>为了提高可用性（Availability），DBMS 将数据复制到冗余节点上。这里涉及四个关键的设计决策。</p>
<h3 id="1-副本配置-Replica-Configuration"><a href="#1-副本配置-Replica-Configuration" class="headerlink" title="(1) 副本配置 (Replica Configuration)"></a>(1) 副本配置 (Replica Configuration)</h3><p>决定了写操作可以发生在哪些节点上。</p>
<ul>
<li><p><strong>主从复制 (Primary-Replica)</strong>：</p>
<ul>
<li><p><strong>原理</strong>：所有的<strong>更新 (Updates)</strong> 必须发往指定的 Primary 节点。Primary 负责将更新传播给 Replicas 。</p>
</li>
<li><p><strong>读操作</strong>：可以读 Replica（如果允许读旧数据），也可以读 Primary。</p>
</li>
<li><p><strong>故障</strong>：Primary 挂了需要重新选举 。</p>
</li>
<li><p><strong>优点</strong>：没有写冲突，并发控制简单。</p>
</li>
</ul>
</li>
<li><p><strong>多主复制 (Multi-Primary)</strong>：</p>
<ul>
<li><p><strong>原理</strong>：事务可以更新<strong>任意</strong>副本。副本之间必须通过原子提交协议同步 。</p>
</li>
<li><p><strong>缺点</strong>：写冲突频繁，需要复杂的同步机制，性能通常较差。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-传播方案-Propagation-Scheme"><a href="#2-传播方案-Propagation-Scheme" class="headerlink" title="(2) 传播方案 (Propagation Scheme)"></a>(2) 传播方案 (Propagation Scheme)</h3><p>决定了客户端何时收到“写入成功”的确认。</p>
<ul>
<li><p><strong>同步 (Synchronous &#x2F; Strong Consistency)</strong>：</p>
<ul>
<li><p>Primary 发送更新给 Replicas，<strong>等待</strong>它们确认已记录日志后，才向客户端返回成功 。</p>
</li>
<li><p><strong>优点</strong>：强一致性，不丢数据 。</p>
</li>
<li><p><strong>缺点</strong>：慢，受最慢节点的拖累。</p>
</li>
</ul>
</li>
<li><p><strong>异步 (Asynchronous &#x2F; Eventual Consistency)</strong>：</p>
<ul>
<li><p>Primary 处理完就立即向客户端返回成功，<strong>不等待</strong> Replicas 确认 。</p>
</li>
<li><p><strong>优点</strong>：快。</p>
</li>
<li><p><strong>缺点</strong>：可能丢数据（如果 Primary 在同步前挂掉），可能读到旧数据（Stale reads）。常见于 NoSQL 系统。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-传播时机-Propagation-Timing"><a href="#3-传播时机-Propagation-Timing" class="headerlink" title="(3) 传播时机 (Propagation Timing)"></a>(3) 传播时机 (Propagation Timing)</h3><ul>
<li><p><strong>Continuous (连续)</strong>：生成日志时立即发送。大多数系统采用此法 。</p>
</li>
<li><p><strong>On Commit (提交时)</strong>：事务提交时一次性发送所有日志。避免了为中止的事务发送日志，但假设事务日志能塞进内存 。</p>
</li>
</ul>
<h3 id="4-更新方式-Update-Method"><a href="#4-更新方式-Update-Method" class="headerlink" title="(4) 更新方式 (Update Method)"></a>(4) 更新方式 (Update Method)</h3><ul>
<li><p><strong>Active-Active</strong>：SQL 语句在每个副本上都执行一遍。<strong>难点</strong>：必须保证所有节点执行顺序完全一致（非确定性函数如 <code>RAND()</code> 会出问题）。</p>
</li>
<li><p><strong>Active-Passive</strong>：在主节点执行，传输<strong>物理字节 (Bytes)</strong> 或逻辑结果给副本。这是主流做法 。</p>
</li>
</ul>
<h3 id="K-Safety"><a href="#K-Safety" class="headerlink" title="K-Safety"></a>K-Safety</h3><ul>
<li>衡量容错能力的指标。 代表必须随时可用的副本数量。如果可用副本数 ，系统必须停止服务 。</li>
</ul>
<hr>
<h2 id="4-原子提交协议-Atomic-Commit-Protocols"><a href="#4-原子提交协议-Atomic-Commit-Protocols" class="headerlink" title="4. 原子提交协议 (Atomic Commit Protocols)"></a>4. 原子提交协议 (Atomic Commit Protocols)</h2><p>当一个事务跨越多个节点时，必须保证<strong>原子性</strong>：要么所有节点都提交，要么所有节点都中止。</p>
<p>我们需要满足三个属性：</p>
<ol>
<li><p><strong>稳定性 (Stability)</strong>：一旦决定了结果（提交&#x2F;中止），不可更改 。</p>
</li>
<li><p><strong>一致性 (Consistency)</strong>：所有节点最终状态一致 。</p>
</li>
<li><p><strong>活性 (Liveness)</strong>：协议最终能完成，不会无限阻塞 。</p>
</li>
</ol>
<h3 id="1-两阶段提交-Two-Phase-Commit-2PC"><a href="#1-两阶段提交-Two-Phase-Commit-2PC" class="headerlink" title="(1) 两阶段提交 (Two-Phase Commit, 2PC)"></a>(1) 两阶段提交 (Two-Phase Commit, 2PC)</h3><p>这是最经典的协议（1970s），由协调者 (Coordinator) 和参与者 (Participants) 组成。</p>
<ul>
<li><p><strong>Phase 1: Prepare (准备阶段)</strong></p>
<ul>
<li>协调者向所有参与者发送 <code>Prepare</code> 消息（包含事务内容）。</li>
<li>参与者执行验证，如果可以提交，写入日志并回复 <code>OK</code>；否则回复 <code>Abort</code> 。</li>
</ul>
</li>
<li><p><strong>Phase 2: Commit (提交阶段)</strong></p>
<ul>
<li>如果<strong>所有</strong>参与者都回复 <code>OK</code>，协调者发送 <code>Commit</code> 消息。</li>
<li>如果有<strong>任意</strong>一个回复 <code>Abort</code>，协调者发送 <code>Abort</code> 消息 。</li>
</ul>
</li>
<li><p><strong>核心问题</strong>：<strong>阻塞 (Blocking)</strong>。如果协调者在发送 Prepare 后崩溃，参与者不知道该怎么办，必须一直持有锁并阻塞等待，直到协调者恢复 。</p>
</li>
<li><p><strong>优化</strong>：</p>
<ul>
<li><p><em>Early Prepare Voting</em>：最后一个查询顺便带上投票 。</p>
</li>
<li><p><em>Early Acknowledgement</em>：协调者确认全票通过后，在 Phase 2 完成前就告知客户端成功 。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-Paxos-与-Raft"><a href="#2-Paxos-与-Raft" class="headerlink" title="(2) Paxos (与 Raft)"></a>(2) Paxos (与 Raft)</h3><p>现代系统更倾向于使用 Paxos 或 Raft，因为它们容错性更强。</p>
<ul>
<li><p><strong>原理</strong>：基于<strong>共识 (Consensus)</strong>。2PC 要求 100% 同意，而 Paxos 只需要 <strong>多数派 (Majority)</strong> 同意。</p>
</li>
<li><p><strong>容错</strong>：只要  个节点中有  个活着，系统就能继续运行（非阻塞）。</p>
</li>
<li><p><strong>流程</strong>：Proposer 提议一个值（Commit&#x2F;Abort），Acceptors 投票。一旦多数派接受，结果就确定了 。</p>
</li>
<li><p><strong>Multi-Paxos</strong>：选出一个 Leader 长期负责提议，跳过第一阶段，提高性能 。</p>
</li>
</ul>
<p><strong>对比总结</strong>：</p>
<ul>
<li><p>如果节点在同一数据中心且很少故障，<strong>2PC</strong> 通常更快（消息往返少）。</p>
</li>
<li><p>如果需要跨数据中心或高容错，<strong>Paxos&#x2F;Raft</strong> 是必须的。</p>
</li>
</ul>
<hr>
<h2 id="5-CAP-定理与-PACELC"><a href="#5-CAP-定理与-PACELC" class="headerlink" title="5. CAP 定理与 PACELC"></a>5. CAP 定理与 PACELC</h2><h3 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h3><p>在一个分布式系统中，无法同时满足以下三点，只能三选二 ：</p>
<ol>
<li><p><strong>C (Consistency)</strong>：一致性（线性一致性）。写操作完成后，随后的读操作必须能读到该值 。</p>
</li>
<li><p><strong>A (Availability)</strong>：可用性。所有存活节点都能处理请求 。</p>
</li>
<li><p><strong>P (Partition Tolerance)</strong>：分区容错性。网络断开时系统仍能工作 。</p>
</li>
</ol>
<ul>
<li><p><strong>现实选择</strong>：由于网络分区（P）在分布式系统中是不可避免的（网线总会被挖断），所以实际上只能在 <strong>CP</strong>（强一致，分区时不可用）和 <strong>AP</strong>（高可用，分区时数据不一致）之间做选择 。</p>
</li>
<li><p><em>传统 DBMS &#x2F; NewSQL</em>：倾向于 CP。</p>
</li>
<li><p><em>NoSQL</em>：倾向于 AP。</p>
</li>
</ul>
<h3 id="PACELC-定理"><a href="#PACELC-定理" class="headerlink" title="PACELC 定理"></a>PACELC 定理</h3><p>CAP 的扩展版本，考虑了系统正常运行（没有分区）时的权衡 。</p>
<ul>
<li><strong>P (Partition)</strong>：如果有分区，选择 <strong>A</strong> 或 <strong>C</strong>。</li>
<li><strong>E (Else)</strong>：如果没有分区（正常情况），选择 <strong>L (Latency)</strong> 或 <strong>C (Consistency)</strong>。</li>
<li>比如：如果你想要极低的延迟（L），就必须放弃强一致性（C），改用异步复制。</li>
</ul>
<p>这份笔记基于 CMU 15-445&#x2F;645 课程第 23 讲（Lecture #23: Distributed OLAP Databases），系统总结了分布式分析型数据库（OLAP）的设计架构、执行模型及现代云原生趋势。</p>
<hr>
<h1 id="第二十四讲：分布式分析型数据库-Distributed-OLAP"><a href="#第二十四讲：分布式分析型数据库-Distributed-OLAP" class="headerlink" title="第二十四讲：分布式分析型数据库 (Distributed OLAP)"></a>第二十四讲：分布式分析型数据库 (Distributed OLAP)</h1><h2 id="1-决策支持系统-Decision-Support-Systems-DSS"><a href="#1-决策支持系统-Decision-Support-Systems-DSS" class="headerlink" title="1. 决策支持系统 (Decision Support Systems, DSS)"></a>1. 决策支持系统 (Decision Support Systems, DSS)</h2><p>OLAP 数据库主要用于执行只读的复杂查询，以支持组织的决策分析 。</p>
<h3 id="数据摄取：ETL-vs-ELT"><a href="#数据摄取：ETL-vs-ELT" class="headerlink" title="数据摄取：ETL vs. ELT"></a>数据摄取：ETL vs. ELT</h3><ul>
<li><p><strong>ETL (Extract, Transform, Load)</strong>：在将数据存入数据仓库前，先在外部完成清洗转换 。</p>
</li>
<li><p><strong>ELT (Extract, Load, Transform)</strong>：现代趋势，先将原始数据加载入库，利用 OLAP 数据库自身的并行计算能力完成转换 。</p>
</li>
</ul>
<h3 id="模式建模-Schema-Modeling"><a href="#模式建模-Schema-Modeling" class="headerlink" title="模式建模 (Schema Modeling)"></a>模式建模 (Schema Modeling)</h3><ul>
<li><p><strong>星型模式 (Star Schema)</strong> ：</p>
<ul>
<li><p>由<strong>事实表 (Fact Table)</strong> 和一层<strong>维度表 (Dimension Tables)</strong> 组成 。</p>
</li>
<li><p><strong>特点</strong>：冗余度高（非规范化），但 <strong>JOIN 次数少，查询速度最快</strong> 。</p>
</li>
</ul>
</li>
<li><p><strong>雪花模式 (Snowflake Schema)</strong> ：</p>
<ul>
<li><p>维度表可以进一步分解，支持多层维度 。</p>
</li>
<li><p><strong>特点</strong>：存储更节省（规范化），但由于需要 <strong>更多的 JOIN 操作，查询性能相对较低</strong> 。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-分布式执行模型"><a href="#2-分布式执行模型" class="headerlink" title="2. 分布式执行模型"></a>2. 分布式执行模型</h2><h3 id="Pushing-vs-Pulling"><a href="#Pushing-vs-Pulling" class="headerlink" title="Pushing vs. Pulling"></a>Pushing vs. Pulling</h3><ul>
<li><p><strong>Pushing (Query to Data)</strong>：将查询逻辑（片段）发送到存储数据的节点上执行，尽可能在本地完成过滤和处理 。</p>
<ul>
<li><strong>适用场景</strong>：Shared-nothing 系统，旨在减少昂贵的网络传输 。</li>
</ul>
</li>
<li><p><strong>Pulling (Data to Query)</strong>：将数据从存储节点拉取到执行查询的节点上处理 。</p>
<ul>
<li><strong>适用场景</strong>：Shared-disk 系统 。</li>
</ul>
</li>
</ul>
<h3 id="容错性-Fault-Tolerance"><a href="#容错性-Fault-Tolerance" class="headerlink" title="容错性 (Fault Tolerance)"></a>容错性 (Fault Tolerance)</h3><ul>
<li><p><strong>现状</strong>：大多数分布式 OLAP 假设节点在查询期间不会失效 。</p>
</li>
<li><p><strong>代价</strong>：若某个节点在执行长达数天的查询时崩溃，通常会导致整个查询失败并必须<strong>从头开始重新执行</strong> 。</p>
</li>
</ul>
<hr>
<h2 id="3-分布式连接算法-Distributed-Joins"><a href="#3-分布式连接算法-Distributed-Joins" class="headerlink" title="3. 分布式连接算法 (Distributed Joins)"></a>3. 分布式连接算法 (Distributed Joins)</h2><p>分布式环境下的 JOIN 是最耗时的操作，其效率取决于数据的分区方式 。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>描述</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td><strong>场景 1</strong></td>
<td>一个表全量副本在每节点，另一表分区</td>
<td>本地并行连接</td>
</tr>
<tr>
<td><strong>场景 2</strong></td>
<td>两个表都按 JOIN 属性进行分区且 ID 匹配</td>
<td>本地并行连接</td>
</tr>
<tr>
<td><strong>场景 3</strong></td>
<td>分区键不同，但其中一表很小</td>
<td><br><strong>广播连接 (Broadcast Join)</strong>：将小表发送给所有节点</td>
</tr>
<tr>
<td><strong>场景 4</strong></td>
<td>最坏情况：两表分区键均非 JOIN 键</td>
<td><br><strong>洗牌连接 (Shuffle Join)</strong>：全量重新分配数据</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-云系统与无服务器架构-Cloud-Serverless"><a href="#4-云系统与无服务器架构-Cloud-Serverless" class="headerlink" title="4. 云系统与无服务器架构 (Cloud &amp; Serverless)"></a>4. 云系统与无服务器架构 (Cloud &amp; Serverless)</h2><h3 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h3><ul>
<li><p><strong>托管型 (Managed)</strong>：传统 DBMS 搬上云，不感知云环境 。</p>
</li>
<li><p><strong>云原生 (Cloud-Native)</strong>：基于 Shared-disk 架构，计算与存储解耦（如 Snowflake, BigQuery） 。</p>
</li>
<li><p><strong>无服务器 (Serverless)</strong> ：</p>
<ul>
<li><p>当数据库空闲时，驱逐租户并对 Buffer Pool 进行检查点（Checkpoint）存盘，停止计费 。</p>
</li>
<li><p>用户仅需为活动查询时间和非活动存储付费 。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-OLAP-商品化-Commoditization"><a href="#5-OLAP-商品化-Commoditization" class="headerlink" title="5. OLAP 商品化 (Commoditization)"></a>5. OLAP 商品化 (Commoditization)</h2><p>现代 OLAP 倾向于将功能解耦为独立的开源组件，极大地提高了系统间的互操作性 ：</p>
<ul>
<li><p><strong>查询优化器</strong>：如 Apache Calcite 。</p>
</li>
<li><p><strong>数据文件格式</strong>：开源二进制格式（如 <strong>Apache Parquet</strong>, Apache Arrow）取代私有格式 。</p>
</li>
<li><p><strong>执行引擎</strong>：如 Velox, DataFusion 。</p>
</li>
</ul>
<hr>
<h3 id="原理深度总结：为什么-OLAP-偏爱列存？"><a href="#原理深度总结：为什么-OLAP-偏爱列存？" class="headerlink" title="原理深度总结：为什么 OLAP 偏爱列存？"></a>原理深度总结：为什么 OLAP 偏爱列存？</h3><p>虽然笔记中未详细展开列存细节，但列存（Columnar Storage）是 OLAP 性能的核心。</p>
<ol>
<li><strong>极高的压缩比</strong>：同一列数据类型相同，压缩效率极高。</li>
<li><strong>I&#x2F;O 裁剪</strong>：只需读取查询涉及的列，无需扫描整行，极大减少磁盘读取量。</li>
<li><strong>向量化执行</strong>：适配现代 CPU 的 SIMD 指令，批量处理数据。</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CMU15-445/" class="category-chain-item">CMU15-445</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/17/CMU15-445-bustub-project4%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/" title="CMU15-445(bustub):project4实现笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU15-445(bustub):project4实现笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/04/CMU15-445-Bustub-project3%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/" title="CMU15-445(Bustub):project3实现笔记">
                        <span class="hidden-mobile">CMU15-445(Bustub):project3实现笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <i class="iconfont icon-love"></i> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
