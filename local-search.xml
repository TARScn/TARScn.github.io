<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CMU15-445(bustub):project4实现笔记</title>
    <link href="/2025/12/17/CMU15-445-bustub-project4%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/12/17/CMU15-445-bustub-project4%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CMU15-445(bustub):课程学习笔记2</title>
    <link href="/2025/12/16/CMU15-445-bustub-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2025/12/16/CMU15-445-bustub-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h1 id="第十三讲：Query-Processing-I"><a href="#第十三讲：Query-Processing-I" class="headerlink" title="第十三讲：Query Processing I"></a>第十三讲：Query Processing I</h1><h2 id="1-概述：从-SQL-到执行"><a href="#1-概述：从-SQL-到执行" class="headerlink" title="1. 概述：从 SQL 到执行"></a>1. 概述：从 SQL 到执行</h2><p>SQL 是一种声明式语言（Declarative），你告诉数据库“我想要什么”，而不是“怎么做”。DBMS 的工作就是将这种声明转换为可执行的<strong>查询计划 (Query Plan)</strong> 。</p><ul><li><p><strong>查询计划的本质</strong>：它是一个操作符（Operators）构成的有向无环图（DAG），通常组织成树状结构 。</p></li><li><p><strong>数据流向</strong>：数据从树的叶子节点（Leaves）流向根节点（Root），根节点的输出即为查询结果 。</p></li><li><p><strong>操作符 (Operators)</strong>：通常是二元的（1-2个子节点），负责具体的数据处理逻辑（如过滤、连接、排序）。</p></li></ul><h3 id="关键概念：流水线与阻断-Pipeline-Breakers"><a href="#关键概念：流水线与阻断-Pipeline-Breakers" class="headerlink" title="关键概念：流水线与阻断 (Pipeline &amp; Breakers)"></a>关键概念：流水线与阻断 (Pipeline &amp; Breakers)</h3><p>理解查询执行的核心在于理解数据是如何流动的：</p><ul><li><p><strong>流水线 (Pipeline)</strong>：理想情况下，操作符之间应该像流水线一样。上游算子产生一个元组（Tuple），下游算子立即处理，中间不需要落盘存储 。</p></li><li><p><strong>流水线阻断器 (Pipeline Breaker)</strong>：某些操作符必须等待所有子节点的数据全部到达后才能开始工作。这就像生产线上的“路障” 。</p></li><li><p><strong>例子</strong>：<code>JOIN</code> 的构建阶段（必须先构建完哈希表才能探测）、<code>ORDER BY</code>（必须拿到所有数据才能排序）、子查询 。</p></li></ul><hr><h2 id="2-处理模型-Processing-Models"><a href="#2-处理模型-Processing-Models" class="headerlink" title="2. 处理模型 (Processing Models)"></a>2. 处理模型 (Processing Models)</h2><p>DBMS 处理模型定义了系统如何执行查询计划，特别是操作符之间如何传递数据（是一个个传、一批批传，还是全部传）。主要有三种模型：</p><h3 id="1-迭代器模型-Iterator-Model-Volcano-Model-Pipeline-Model"><a href="#1-迭代器模型-Iterator-Model-Volcano-Model-Pipeline-Model" class="headerlink" title="(1) 迭代器模型 (Iterator Model) &#x2F; Volcano Model &#x2F; Pipeline Model"></a>(1) 迭代器模型 (Iterator Model) &#x2F; Volcano Model &#x2F; Pipeline Model</h3><p>这是最常见的模型，几乎所有的行存储（Row-based）数据库都使用它 。</p><ul><li><strong>原理</strong>：每个操作符实现一个 <code>Next()</code> 函数。<ul><li><p>父节点调用子节点的 <code>Next()</code>。</p></li><li><p>子节点返回<strong>一个元组 (Tuple)</strong> 或空标记（null&#x2F;EOF）。</p></li><li><p>是一个“拉取”（Pull）数据的过程，从 Root 到底部循环调用 。</p></li></ul></li></ul><img src="/img/CMU15-445-Bustub-课程学习笔记2/Iterator.png" alt="迭代器" style="display: block; margin: 0 auto; width: 70%; height:70%;"><ul><li><p><strong>优点</strong>：</p><ul><li><p><strong>流控制友好</strong>：非常适合基于磁盘的系统，内存用量可控 。</p></li><li><p><strong>易于实现</strong>：操作符之间解耦，容易组合 。</p></li><li><p><strong>支持 Limit</strong>：只要父节点拿够了数据，就可以停止调用 <code>Next()</code> 。</p></li></ul></li><li><p><strong>缺点</strong>：函数调用开销大（每个 Tuple 调用一次），不利于 CPU 流水线和缓存优化。</p></li></ul><h3 id="2-物化模型-Materialization-Model"><a href="#2-物化模型-Materialization-Model" class="headerlink" title="(2) 物化模型 (Materialization Model)"></a>(2) 物化模型 (Materialization Model)</h3><p>这种模型是迭代器模型的一种特化，区别在于它不流式传输，而是“一次性交货”。</p><ul><li><p><strong>原理</strong>：每个操作符实现一个 <code>Output()</code> 函数。该函数一次性处理所有输入，并将<strong>所有结果</strong>物化（存储）后一次性返回给父节点 。</p></li><li><p><strong>适用场景</strong>：</p><ul><li><p><strong>OLTP (联机事务处理)</strong>：适合，因为 OLTP 查询通常只涉及少量数据，减少了函数调用次数 。</p></li><li><p><strong>不适合 OLAP</strong>：如果中间结果集很大，必须溢写到磁盘，效率极低 。</p></li></ul></li></ul><img src="/img/CMU15-445-Bustub-课程学习笔记2/Materialization.png" alt="物化模型" style="display: block; margin: 0 auto; width: 70%; height:70%;"><h3 id="3-向量化-批处理模型-Vectorized-Batch-Model"><a href="#3-向量化-批处理模型-Vectorized-Batch-Model" class="headerlink" title="(3) 向量化&#x2F;批处理模型 (Vectorized &#x2F; Batch Model)"></a>(3) 向量化&#x2F;批处理模型 (Vectorized &#x2F; Batch Model)</h3><p>这是现代分析型数据库（如 Snowflake, Redshift, DuckDB）的标准。</p><ul><li><p><strong>原理</strong>：结合了迭代器的流式思想和物化的批量思想。每个操作符也有 <code>Next()</code> 函数，但它每次返回<strong>一批元组 (Batch&#x2F;Vector)</strong>，而不是一个 。</p></li><li><p><strong>优点</strong>：</p><ul><li><p><strong>减少开销</strong>：将函数调用的开销分摊到一批数据上 。</p></li><li><p><strong>硬件加速</strong>：非常适合利用 CPU 的 <strong>SIMD</strong> (单指令多数据) 指令集来并行处理数据 。</p></li><li><p><strong>OLAP 理想选择</strong>：特别是对于列式存储，扫描大量数据极其高效 。</p></li></ul></li></ul><img src="/img/CMU15-445-Bustub-课程学习笔记2/Vectorized.png" alt="批处理模型" style="display: block; margin: 0 auto; width: 70%; height:70%;"><hr><h2 id="3-访问方法-Access-Methods"><a href="#3-访问方法-Access-Methods" class="headerlink" title="3. 访问方法 (Access Methods)"></a>3. 访问方法 (Access Methods)</h2><p>访问方法是 DBMS 从表中读取数据的方式。主要有两种路径：全表扫描或通过索引。</p><h3 id="1-顺序扫描-Sequential-Scan"><a href="#1-顺序扫描-Sequential-Scan" class="headerlink" title="(1) 顺序扫描 (Sequential Scan)"></a>(1) 顺序扫描 (Sequential Scan)</h3><p>DBMS 遍历表中的每一页，从缓冲池（Buffer Pool）获取数据并检查是否符合条件 。这通常是效率最低的方法，但有很多优化手段：</p><ul><li><p><strong>预取 (Prefetching)</strong>：提前加载后续页面，掩盖 I&#x2F;O 延迟 。</p></li><li><p><strong>绕过缓冲池 (Buffer Pool Bypass)</strong>：扫描大量数据时不污染热数据缓存，直接在局部内存处理 。</p></li><li><p><strong>并行化 (Parallelization)</strong>：多线程同时扫 。</p></li><li><p><strong>Zone Map (区域映射 &#x2F; Lossless Data Skipping)</strong>：</p><ul><li><p><strong>原理</strong>：在每页数据的头部或单独区域存储预计算的聚合信息（如 Min, Max, Sum, Count）。</p></li><li><p><strong>作用</strong>：在读取页面前，先检查 Zone Map。如果查询条件是 <code>WHERE val &gt; 600</code>，而 Zone Map 显示该页 <code>MAX = 400</code>，则直接<strong>跳过整页</strong>，完全不进行 I&#x2F;O 。这在云数据库（减少网络传输）中尤为重要 。</p></li></ul></li></ul><h3 id="2-索引扫描-Index-Scan"><a href="#2-索引扫描-Index-Scan" class="headerlink" title="(2) 索引扫描 (Index Scan)"></a>(2) 索引扫描 (Index Scan)</h3><p>DBMS 选择一个索引来查找数据。索引并不总是比顺序扫描快。</p><ul><li><p><strong>选择困境</strong>：</p><ul><li><p>如果查询结果占表的一大部分（如99%），顺序扫描往往比随机 I&#x2F;O 的索引扫描快 。</p></li><li><p>DBMS 需要根据统计信息（选择性 Selectivity）来决定是否使用索引 。</p></li></ul></li><li><p><strong>多索引扫描 (Multi-Index Scan)</strong>：</p><ul><li><p>如果查询有多个条件（如 <code>age &lt; 30 AND dept = &#39;CS&#39;</code>），可以分别在两个索引中查找 。</p></li><li><p>获取两组 Record ID，利用位图（Bitmap）或哈希表计算<strong>交集 (Intersection)</strong>，然后再回表取数据 。</p></li></ul></li></ul><hr><h2 id="4-表达式求值-Expression-Evaluation"><a href="#4-表达式求值-Expression-Evaluation" class="headerlink" title="4. 表达式求值 (Expression Evaluation)"></a>4. 表达式求值 (Expression Evaluation)</h2><p><code>WHERE</code> 子句中的条件（如 <code>B.value = ? + [cite_start]1</code>）在内部被表示为<strong>表达式树 (Expression Tree)</strong> 。</p><ul><li><p><strong>解释执行 (Interpretation)</strong>：DBMS 遍历这棵树，递归调用每个节点进行计算。这很慢，因为每次计算都有类型检查和函数跳转的开销 。</p></li><li><p><strong>优化技术</strong>：</p><ol><li><p><strong>JIT 编译 (Just-In-Time Compilation)</strong>：将整个表达式树编译成原生的机器码，去除树遍历的开销，直接执行 。</p></li><li><p><strong>常量折叠 (Constant Folding)</strong>：如果表达式中有 <code>1 + 2</code>，直接在规划阶段算成 <code>3</code> 。</p></li></ol></li></ul><hr><h2 id="5-修改查询-Modification-Queries-与万圣节问题"><a href="#5-修改查询-Modification-Queries-与万圣节问题" class="headerlink" title="5. 修改查询 (Modification Queries)与万圣节问题"></a>5. 修改查询 (Modification Queries)与万圣节问题</h2><p>对于 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>，操作符不仅要修改数据，还要负责检查约束（Constraints）和更新索引 。</p><h3 id="万圣节问题-Halloween-Problem"><a href="#万圣节问题-Halloween-Problem" class="headerlink" title="万圣节问题 (Halloween Problem)"></a>万圣节问题 (Halloween Problem)</h3><p>这是一个经典的数据库异常现象，由 IBM 研究员在 1976 年万圣节发现 。</p><ul><li><p><strong>现象</strong>：假设你要给所有薪水低于 1000 的员工加薪 10%。</p><ul><li><p>你更新了第一个员工，薪水变高了。</p></li><li><p>如果更新操作改变了元组在物理存储或索引中的位置，扫描操作符可能会<strong>再次扫描到这个已经被更新过的元组</strong> 。</p></li><li><p>结果：该员工被反复加薪，甚至导致无限循环。</p></li></ul></li><li><p><strong>解决方案</strong>：DBMS 必须跟踪哪些元组已经被修改过（例如记录 Record IDs），防止重复处理 。</p></li></ul><hr><h3 id="总结与下一步"><a href="#总结与下一步" class="headerlink" title="总结与下一步"></a>总结与下一步</h3><p>这节课的核心在于理解 <strong>Query Plan 是如何被“执行”的</strong>。</p><ol><li><strong>Iterator 模型</strong> 是这一层的基石，简单但有调用开销。</li><li><strong>Vectorization 模型</strong> 通过批处理解决了开销问题，是现代 OLAP 的标配。</li><li><strong>Access Methods</strong> 决定了最底层的 I&#x2F;O 效率，Zone Map 和 Index Selection 是其中的关键优化点。</li></ol><hr><h1 id="第十四讲：Query-Processing-II（并行查询执行）"><a href="#第十四讲：Query-Processing-II（并行查询执行）" class="headerlink" title="第十四讲：Query Processing II（并行查询执行）"></a>第十四讲：Query Processing II（并行查询执行）</h1><h2 id="1-核心背景与意义"><a href="#1-核心背景与意义" class="headerlink" title="1. 核心背景与意义"></a>1. 核心背景与意义</h2><p>在早期的讨论中，我们假设查询是由单个线程（Worker）执行的 。然而，现代 DBMS 为了提升性能，通常采用<strong>并行执行（Parallel Execution）</strong> 。</p><p><strong>并行执行的主要优势：</strong></p><ul><li><p><strong>性能提升：</strong> 提高吞吐量（每秒查询数）并降低响应延迟 。</p></li><li><p><strong>响应性与可用性：</strong> 增强外部客户端的交互体验 。</p></li><li><p><strong>降低总拥有成本 (TCO)：</strong> 通过更高效地利用硬件资源和降低能耗，优化云端系统的运行成本 。</p></li></ul><h3 id="并行（Parallel）与分布式（Distributed）的区别"><a href="#并行（Parallel）与分布式（Distributed）的区别" class="headerlink" title="并行（Parallel）与分布式（Distributed）的区别"></a>并行（Parallel）与分布式（Distributed）的区别</h3><p>虽然两者都将数据分散在多个资源上 ，但环境完全不同：</p><ul><li><p><strong>并行数据库：</strong> 节点物理距离近，通过高速互连通信。通信速度快且廉价，故障率低 。</p></li><li><p><strong>分布式数据库：</strong> 节点跨机架或数据中心。通信使用公共网络，成本高、延迟大，且必须考虑节点故障 。</p></li></ul><hr><h2 id="2-DBMS-进程模型-Process-Models"><a href="#2-DBMS-进程模型-Process-Models" class="headerlink" title="2. DBMS 进程模型 (Process Models)"></a>2. DBMS 进程模型 (Process Models)</h2><p>进程模型定义了系统如何支持多用户的并发请求 。</p><h3 id="A-进程每工作者-Process-per-Worker"><a href="#A-进程每工作者-Process-per-Worker" class="headerlink" title="A. 进程每工作者 (Process per Worker)"></a>A. 进程每工作者 (Process per Worker)</h3><ul><li><p><strong>原理：</strong> 每个工作者是一个独立的操作系统进程 。</p></li><li><p><strong>调度：</strong> 依赖操作系统的调度器 。</p></li><li><p><strong>优点：</strong> 隔离性强，单个进程崩溃不会导致整个系统宕机 。</p></li><li><p><strong>缺点：</strong> 依赖共享内存进行数据交换，跨进程通信（IPC）开销大 。</p></li><li><p><strong>代表案例：</strong> Postgres, Oracle, IBM DB2 。</p></li></ul><h3 id="B-线程每工作者-Thread-per-Worker-——-现代主流"><a href="#B-线程每工作者-Thread-per-Worker-——-现代主流" class="headerlink" title="B. 线程每工作者 (Thread per Worker) —— 现代主流"></a>B. 线程每工作者 (Thread per Worker) —— 现代主流</h3><ul><li><p><strong>原理：</strong> 一个数据库进程内包含多个工作线程 。</p></li><li><p><strong>调度：</strong> DBMS 可以完全控制任务调度，拥有更高的灵活性 。</p></li><li><p><strong>优点：</strong> 上下文切换开销小，无需复杂的跨进程共享模型 。</p></li><li><p><strong>缺点：</strong> 一个线程崩溃可能导致整个进程（整个数据库）崩溃 。</p></li><li><p><strong>代表案例：</strong> MySQL, Microsoft SQL Server 。</p></li></ul><h3 id="C-嵌入式模型-Embedded-DBMS"><a href="#C-嵌入式模型-Embedded-DBMS" class="headerlink" title="C. 嵌入式模型 (Embedded DBMS)"></a>C. 嵌入式模型 (Embedded DBMS)</h3><ul><li><p><strong>原理：</strong> 数据库运行在应用程序的同一地址空间内 。</p></li><li><p><strong>调度：</strong> 由应用程序负责线程调度 。</p></li><li><p><strong>代表案例：</strong> SQLite, DuckDB, RocksDB 。</p></li></ul><hr><h2 id="3-并行执行的类型"><a href="#3-并行执行的类型" class="headerlink" title="3. 并行执行的类型"></a>3. 并行执行的类型</h2><p>并行可以从查询间（Inter）和查询内（Intra）两个维度展开。</p><h3 id="3-1-查询间并行-Inter-Query-Parallelism"><a href="#3-1-查询间并行-Inter-Query-Parallelism" class="headerlink" title="3.1 查询间并行 (Inter-Query Parallelism)"></a>3.1 查询间并行 (Inter-Query Parallelism)</h3><ul><li><p><strong>定义：</strong> 多个不同的查询同时执行 。</p></li><li><p><strong>核心挑战：</strong> 如果多个查询同时更新相同的数据，会产生并发冲突 。</p></li></ul><h3 id="3-2-查询内并行-Intra-Query-Parallelism"><a href="#3-2-查询内并行-Intra-Query-Parallelism" class="headerlink" title="3.2 查询内并行 (Intra-Query Parallelism)"></a>3.2 查询内并行 (Intra-Query Parallelism)</h3><ul><li><strong>定义：</strong> 并行执行单个查询中的各个操作 。</li></ul><h4 id="算子内并行-Intra-Operator-Horizontal"><a href="#算子内并行-Intra-Operator-Horizontal" class="headerlink" title="算子内并行 (Intra-Operator &#x2F; Horizontal)"></a>算子内并行 (Intra-Operator &#x2F; Horizontal)</h4><ul><li><p><strong>原理：</strong> 将单个算子分解为多个独立的片段（Fragments），每个片段在不同的数据子集上执行相同功能 。</p></li><li><p><strong>关键组件：</strong> <strong>交换算子 (Exchange Operator)</strong> 。</p><ul><li><p><strong>Gather：</strong> 将多个流合并为一个 。</p></li><li><p><strong>Distribute：</strong> 将一个流拆分为多个 。</p></li><li><p><strong>Repartition：</strong> 重新组织多个输入流到多个输出流 。</p></li></ul></li></ul><h4 id="算子间并行-Inter-Operator-Vertical-Pipelining"><a href="#算子间并行-Inter-Operator-Vertical-Pipelining" class="headerlink" title="算子间并行 (Inter-Operator &#x2F; Vertical &#x2F; Pipelining)"></a>算子间并行 (Inter-Operator &#x2F; Vertical &#x2F; Pipelining)</h4><ul><li><strong>原理：</strong> 类似于流水线，上游算子在下游算子产生数据时立即开始处理，无需等待所有数据物化 。</li></ul><h4 id="丛式并行-Bushy-Parallelism"><a href="#丛式并行-Bushy-Parallelism" class="headerlink" title="丛式并行 (Bushy Parallelism)"></a>丛式并行 (Bushy Parallelism)</h4><ul><li><strong>原理：</strong> 结合了上述两种方式，不同的工作者同时执行查询计划中不同部分的多个算子 。</li></ul><hr><h2 id="4-I-O-并行-I-O-Parallelism"><a href="#4-I-O-并行-I-O-Parallelism" class="headerlink" title="4. I&#x2F;O 并行 (I&#x2F;O Parallelism)"></a>4. I&#x2F;O 并行 (I&#x2F;O Parallelism)</h2><p>如果磁盘是瓶颈，增加 CPU 线程也无法提升性能 。</p><ul><li><p><strong>多磁盘并行 (Multi-Disk)：</strong> 通过 RAID 或存储设备将文件分散在物理硬盘上，这对 DBMS 是透明的 。</p></li><li><p><strong>数据库分区 (Database Partitioning)：</strong> 将数据库物理拆分为不相交的子集，存储在不同磁盘。</p></li><li><p><strong>逻辑分区：</strong> 将一个逻辑表拆分为物理段管理，对应用透明 。</p></li></ul><hr><h3 id="补充理解：为什么-DBMS-要“夺取”调度权？"><a href="#补充理解：为什么-DBMS-要“夺取”调度权？" class="headerlink" title="补充理解：为什么 DBMS 要“夺取”调度权？"></a>补充理解：为什么 DBMS 要“夺取”调度权？</h3><p>在笔记中提到，DBMS 总是比操作系统更了解查询计划，因此倾向于自己调度 。这是因为：</p><ol><li><strong>数据位置感知：</strong> DBMS 知道数据在哪个 Buffer Pool 页面，可以实现“计算向数据移动”。</li><li><strong>依赖关系感知：</strong> DBMS 知道算子间的先后顺序（如 Join 必须在 Scan 后），而 OS 只把它们看作普通的线程。</li></ol><p>这份笔记基于你提供的 CMU 15-445&#x2F;645 课程资料（Lecture #15: Query Planning &amp; Optimization），系统地总结了数据库查询优化器的核心架构、策略与算法。</p><hr><h1 id="第十五讲：查询规划与优化-Query-Planning-Optimization"><a href="#第十五讲：查询规划与优化-Query-Planning-Optimization" class="headerlink" title="第十五讲：查询规划与优化 (Query Planning &amp; Optimization)"></a>第十五讲：查询规划与优化 (Query Planning &amp; Optimization)</h1><h2 id="1-优化器概述-Overview"><a href="#1-优化器概述-Overview" class="headerlink" title="1. 优化器概述 (Overview)"></a>1. 优化器概述 (Overview)</h2><p>由于 SQL 是<strong>声明式 (Declarative)</strong> 语言，用户只说明“想要什么”，而不说明“如何计算” 。DBMS 的任务是将 SQL 语句转化为高效的<strong>可执行查询计划</strong> 。</p><ul><li><p><strong>核心挑战</strong>：同一个查询有多种执行方式（如不同的连接算法），性能差异巨大 。</p></li><li><p><strong>历史地位</strong>：查询优化是构建 DBMS 最难的部分 。最早的优化器源于 20 世纪 70 年代的 IBM System R 。</p></li></ul><p>查询处理流程 ：</p><ol><li><strong>Parser (解析器)</strong>：将 SQL 字符串转化为<strong>抽象语法树 (AST)</strong>。</li><li><strong>Binder (绑定器)</strong>：结合系统目录 (System Catalog)，将 AST 中的名称映射为内部 ID。</li><li><strong>Optimizer (优化器)</strong>：根据逻辑计划选择最高效的物理执行路径。</li></ol><hr><h2 id="2-逻辑计划-vs-物理计划"><a href="#2-逻辑计划-vs-物理计划" class="headerlink" title="2. 逻辑计划 vs. 物理计划"></a>2. 逻辑计划 vs. 物理计划</h2><ul><li><strong>逻辑计划 (Logical Plan)</strong>：对应于关系代数表达式，描述操作的逻辑顺序。</li><li><strong>物理计划 (Physical Plan)</strong>：定义具体的执行策略和访问路径（如顺序扫描、索引扫描、哈希连接等），受数据物理格式（如排序、压缩）影响。</li></ul><hr><h2 id="3-查询优化两大策略"><a href="#3-查询优化两大策略" class="headerlink" title="3. 查询优化两大策略"></a>3. 查询优化两大策略</h2><h3 id="A-基于规则的逻辑优化-Rule-based-Heuristics"><a href="#A-基于规则的逻辑优化-Rule-based-Heuristics" class="headerlink" title="A. 基于规则的逻辑优化 (Rule-based &#x2F; Heuristics)"></a>A. 基于规则的逻辑优化 (Rule-based &#x2F; Heuristics)</h3><p>利用静态规则和模式匹配来转换逻辑计划，不查看具体数据内容 。</p><ul><li><p><strong>谓词下推 (Predicate Pushdown)</strong>：尽可能早地进行过滤，减少进入后续算子的数据量 。</p></li><li><p><strong>投影下推 (Projection Pushdown)</strong>：尽早切掉不需要的列，减小元组大小，降低中间结果开销 。</p></li><li><p><strong>表达式重写</strong>：合并冗余谓词（如将 <code>val BETWEEN 1 AND 100 OR val BETWEEN 50 AND 150</code> 重写为 <code>BETWEEN 1 AND 150</code>）或删除不可能执行的谓词 。</p></li></ul><h3 id="B-基于代价的物理优化-Cost-based-Search"><a href="#B-基于代价的物理优化-Cost-based-Search" class="headerlink" title="B. 基于代价的物理优化 (Cost-based Search)"></a>B. 基于代价的物理优化 (Cost-based Search)</h3><p>通过估算不同等价计划的代价，选择代价最低的一个 。</p><ul><li><strong>评价指标</strong>：CPU 开销、磁盘 I&#x2F;O（块传输数）、内存使用量、网络开销 。</li></ul><hr><h2 id="4-代价估算-Cost-Estimations"><a href="#4-代价估算-Cost-Estimations" class="headerlink" title="4. 代价估算 (Cost Estimations)"></a>4. 代价估算 (Cost Estimations)</h2><p>为了在不实际执行查询的情况下估算代价，DBMS 在目录中维护<strong>统计信息</strong> 。</p><p>核心统计指标 ：</p><ul><li>$N_{R}$：关系 $R$ 中的元组总数。</li><li>$V(A, R)$：属性 $A$ 的不同取值数 (Distinct Values)。</li><li><strong>选择度 (Selectivity)</strong>：谓词 P 过滤后符合条件的元组比例 。</li></ul><h3 id="解决数据倾斜：直方图-Histograms"><a href="#解决数据倾斜：直方图-Histograms" class="headerlink" title="解决数据倾斜：直方图 (Histograms)"></a>解决数据倾斜：直方图 (Histograms)</h3><p>现实数据通常是不均匀的 。DBMS 使用直方图来减少存储开销并提高估算准确性：</p><ul><li><p><strong>等宽直方图 (Equi-Width)</strong>：每个桶的取值范围跨度相同 。</p></li><li><p><strong>等深直方图 (Equi-Depth)</strong>：调整桶范围，使每个桶内落入的记录数大致相等 。</p></li></ul><h3 id="采样-Sampling"><a href="#采样-Sampling" class="headerlink" title="采样 (Sampling)"></a>采样 (Sampling)</h3><p>对于超大规模数据（如 10 亿行），DBMS 会在数据表的子集上应用谓词来估算选择度 。</p><hr><h2 id="5-搜索空间与优化算法"><a href="#5-搜索空间与优化算法" class="headerlink" title="5. 搜索空间与优化算法"></a>5. 搜索空间与优化算法</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>重点在于选择<strong>访问方法 (Access Method)</strong>。对于 OLTP 查询，通常存在最优索引（Sargable），使用简单启发式规则即可选择 。</p><h3 id="多表连接-Multi-Relation"><a href="#多表连接-Multi-Relation" class="headerlink" title="多表连接 (Multi-Relation)"></a>多表连接 (Multi-Relation)</h3><p>连接顺序的选择是指数级难题（n 个表连接有 4^n 种可能的顺序） 。</p><ol><li><p><strong>自底向上 (Bottom-up)</strong>：从单个表开始构建，通过动态规划寻找最优连接顺序（如 IBM System R, Postgres） 。</p></li><li><p><strong>自顶向下 (Top-down)</strong>：从目标结果出发，通过规则和分支限界搜索向下寻找最优物理算子（如 MSSQL, Volcano 模型） 。</p></li></ol><hr><h2 id="6-嵌套子查询优化"><a href="#6-嵌套子查询优化" class="headerlink" title="6. 嵌套子查询优化"></a>6. 嵌套子查询优化</h2><p>DBMS 会尝试“扁平化”子查询：</p><ul><li><p><strong>重写</strong>：将子查询改写为连接 (JOIN) 。</p></li><li><p><strong>分解</strong>：将复杂子查询的结果存入临时表，供外层查询使用 。</p></li></ul><hr><h3 id="补充：原理深度解析"><a href="#补充：原理深度解析" class="headerlink" title="补充：原理深度解析"></a>补充：原理深度解析</h3><p><strong>为什么连接顺序如此重要？</strong><br>在多表连接中，中间结果的大小直接决定了查询效率。如果先连接两个产生海量数据的表，内存和 I&#x2F;O 压力会瞬间激增。优化器的核心目标就是通过<strong>选择度估算</strong>，找到能让中间结果尽可能小的连接路径。</p><p>这份 CMU 15-445&#x2F;645 Database Systems (Fall 2024) Lecture #16 <strong>Concurrency Control Theory (并发控制理论)</strong> 的课程笔记整理如下。</p><p>这份笔记不仅总结了课件内容，还补充了相关原理的深度解析，旨在帮助你理解数据库如何在多用户并发访问时，依然保证数据的准确性和系统的稳定性。</p><hr><h1 id="第十六讲：Concurrency-Control-Theory-并发控制理论"><a href="#第十六讲：Concurrency-Control-Theory-并发控制理论" class="headerlink" title="第十六讲：Concurrency Control Theory (并发控制理论)"></a>第十六讲：Concurrency Control Theory (并发控制理论)</h1><h2 id="1-为什么需要并发控制？-Motivation"><a href="#1-为什么需要并发控制？-Motivation" class="headerlink" title="1. 为什么需要并发控制？(Motivation)"></a>1. 为什么需要并发控制？(Motivation)</h2><p>在数据库系统中，如果我们只是简单地让所有操作顺序执行（一次处理一个），虽然能保证不出错，但效率极低。我们需要让多个事务“并发”执行以提高系统吞吐量，但这带来了两个核心问题：</p><ol><li><p><strong>丢失更新 (Lost Update Problem)</strong>：由于竞争条件（Race Condition），两个事务同时更新同一条记录，导致其中一个更新被覆盖 。</p></li><li><p><strong>持久性问题 (Durability Problem)</strong>：如果系统断电或崩溃，如何确保已提交的数据不丢失，未提交的数据不残留 。</p></li></ol><hr><h2 id="2-事务-Transactions"><a href="#2-事务-Transactions" class="headerlink" title="2. 事务 (Transactions)"></a>2. 事务 (Transactions)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>事务是 DBMS 中变化的<strong>基本单位</strong>。它是一系列在共享数据库上执行的操作（如 SQL 查询）的序列，这些操作共同完成一个高级功能 。</p><ul><li><p><strong>原子性 (Atomic)</strong>：事务不可分割，要么全做，要么全不做（Partial transactions represent unfinished business）。</p></li><li><p><strong>示例</strong>：Andy 给 Promotor 转账 $100。</p><ol><li>检查 Andy 余额。</li><li>Andy 扣除 $100。</li><li>Promotor 增加 $100。</li></ol></li></ul><p><em>这三步必须作为一个整体，不能只做了前两步而没做第三步</em> 。</p><h3 id="“稻草人”系统-The-Strawman-System"><a href="#“稻草人”系统-The-Strawman-System" class="headerlink" title="“稻草人”系统 (The Strawman System)"></a>“稻草人”系统 (The Strawman System)</h3><p>这是一个用于对比的简单设计：系统只允许<strong>同一时间运行一个事务</strong>（单线程）。</p><ul><li><p><strong>执行方式</strong>：每次事务开始前，复制整个数据库文件，在副本上修改。如果成功，用副本覆盖原文件；如果失败，丢弃副本 。</p></li><li><p><strong>缺点</strong>：极慢（不支持并发）、空间浪费（每次都要复制整个库）。</p></li><li><p><strong>结论</strong>：我们需要允许<strong>并发执行 (Concurrent Execution)</strong>，但必须保证<strong>正确性 (Correctness)</strong> 和<strong>公平性 (Fairness)</strong> 。</p></li></ul><hr><h2 id="3-ACID-特性"><a href="#3-ACID-特性" class="headerlink" title="3. ACID 特性"></a>3. ACID 特性</h2><p>ACID 是确保数据库事务正确性的四个标准 。</p><h3 id="A-Atomicity-原子性"><a href="#A-Atomicity-原子性" class="headerlink" title="A - Atomicity (原子性)"></a>A - Atomicity (原子性)</h3><p>事务中的所有操作要么全部成功，要么全部失败（回滚）。即使系统在事务执行中途崩溃，重启后也不能残留只执行了一半的状态 。</p><p><strong>实现机制：</strong></p><ol><li><p><strong>日志 (Logging - 推荐)</strong>：DBMS 记录所有操作的日志（Undo Records）。如果事务中止，利用日志撤销已做的修改。这是现代数据库的标准做法，效率高 。</p></li><li><p><strong>影子分页 (Shadow Paging)</strong>：修改数据时，不直接改原页面，而是复制一份副本进行修改。提交时才将指针指向新页面。</p><ul><li><em>优点</em>：恢复简单（直接丢弃副本），不需要复杂的 Undo 日志。</li><li><em>缺点</em>：运行时性能差（数据碎片化、复制开销大），因此很少在高性能 DBMS 中使用 。</li></ul></li></ol><h3 id="C-Consistency-一致性"><a href="#C-Consistency-一致性" class="headerlink" title="C - Consistency (一致性)"></a>C - Consistency (一致性)</h3><p>一致性指数据库从一个“逻辑上正确”的状态转移到另一个“逻辑上正确”的状态 。</p><ul><li><p><strong>数据库一致性 (Database Consistency)</strong>：数据必须满足所有完整性约束（例如：年龄不能为负数，外键约束等）。</p></li><li><p><strong>事务一致性 (Transaction Consistency)</strong>：如果数据库在事务开始前是一致的，那么事务结束后也必须是一致的。<strong>注意：这是应用层（Application）的责任，DBMS 只能负责检查约束，无法判断业务逻辑是否正确</strong> 。</p></li></ul><h3 id="I-Isolation-隔离性"><a href="#I-Isolation-隔离性" class="headerlink" title="I - Isolation (隔离性)"></a>I - Isolation (隔离性)</h3><p>每个事务在执行时，应该感觉不到其他事务的存在。并发执行的结果必须与某种<strong>串行执行 (Serial Execution)</strong> 的结果相同 。</p><ul><li>这是并发控制（Concurrency Control）的核心目标。</li></ul><h3 id="D-Durability-持久性"><a href="#D-Durability-持久性" class="headerlink" title="D - Durability (持久性)"></a>D - Durability (持久性)</h3><p>一旦事务提交（Commit），其对数据库的修改就是永久的，即使随后发生系统崩溃或断电也不能丢失 。</p><ul><li>实现通常依赖于将日志或影子页面写入非易失性存储（磁盘） 。</li></ul><hr><h2 id="4-并发控制理论-Concurrency-Control-Theory"><a href="#4-并发控制理论-Concurrency-Control-Theory" class="headerlink" title="4. 并发控制理论 (Concurrency Control Theory)"></a>4. 并发控制理论 (Concurrency Control Theory)</h2><p>并发控制协议决定了 DBMS 如何在运行时交替执行多个事务的操作 。</p><h3 id="两种主要流派"><a href="#两种主要流派" class="headerlink" title="两种主要流派"></a>两种主要流派</h3><ol><li><p><strong>悲观并发控制 (Pessimistic)</strong>：假设冲突频繁发生，在操作前先加锁，阻止问题的发生（Don’t let problems arise）。</p></li><li><p><strong>乐观并发控制 (Optimistic)</strong>：假设冲突很少，先执行，在提交时检查是否冲突。如果冲突则回滚（Deal with conflicts after commit）。</p></li></ol><h3 id="调度-Schedule"><a href="#调度-Schedule" class="headerlink" title="调度 (Schedule)"></a>调度 (Schedule)</h3><p>调度是操作执行的顺序 。我们的目标是找到一种<strong>可串行化 (Serializable)</strong> 的调度。</p><ul><li><strong>串行调度 (Serial Schedule)</strong>：事务一个接一个执行，没有交错。</li><li><strong>可串行化调度 (Serializable Schedule)</strong>：一个并发调度的执行结果，等价于（Equivalent to）某种串行调度的结果。这种调度被认为是正确的 。</li></ul><h3 id="冲突-Conflicts"><a href="#冲突-Conflicts" class="headerlink" title="冲突 (Conflicts)"></a>冲突 (Conflicts)</h3><p>当两个操作满足以下三个条件时，称为冲突 ：</p><ol><li>属于不同的事务。</li><li>操作同一个对象。</li><li>至少有一个是<strong>写 (Write)</strong> 操作。</li></ol><p><strong>三种冲突类型：</strong></p><ol><li><p><strong>Read-Write (不可重复读)</strong>：Txn A 读取了数据，Txn B 修改了它。Txn A 再次读取时发现值变了 。</p></li><li><p><strong>Write-Read (脏读)</strong>：Txn A 修改了数据但未提交，Txn B 读取了这个未提交的数据。如果 Txn A 随后回滚，Txn B 读到的就是脏数据 。</p></li><li><p><strong>Write-Write (丢失更新)</strong>：Txn A 和 Txn B 同时修改同一数据，Txn B 的写覆盖了 Txn A 的写 。</p></li></ol><hr><h2 id="5-可串行化-Serializability-的类型"><a href="#5-可串行化-Serializability-的类型" class="headerlink" title="5. 可串行化 (Serializability) 的类型"></a>5. 可串行化 (Serializability) 的类型</h2><p>我们需要一种形式化的方法来判断一个调度是否是“正确”的（即可串行化的）。</p><h3 id="1-冲突可串行化-Conflict-Serializability"><a href="#1-冲突可串行化-Conflict-Serializability" class="headerlink" title="(1) 冲突可串行化 (Conflict Serializability)"></a>(1) 冲突可串行化 (Conflict Serializability)</h3><p>这是大多数 DBMS 实际采用的标准 。</p><ul><li><p><strong>定义</strong>：如果一个调度可以通过交换<strong>不冲突</strong>的操作，转换成一个串行调度，那它就是冲突可串行化的 。</p></li><li><p><strong>检测方法 - 依赖图 (Dependency Graph)</strong>：</p><ul><li>节点是事务。</li><li>如果 $T_i$ 的操作与 $T_j$ 的操作冲突，且 $T_i$ 在 $T_j$ 之前执行，则画一条 $T_i \to T_j$ 的边 。</li></ul></li><li><p><strong>定理</strong>：如果依赖图<strong>没有环 (Acyclic)</strong>，则调度是冲突可串行化的 。</p></li></ul><h3 id="2-视图可串行化-View-Serializability"><a href="#2-视图可串行化-View-Serializability" class="headerlink" title="(2) 视图可串行化 (View Serializability)"></a>(2) 视图可串行化 (View Serializability)</h3><p>这是一个比冲突可串行化更弱（包含范围更广）的概念 。</p><ul><li><p><strong>关键点</strong>：它允许<strong>盲写 (Blind Writes)</strong>（即不读数据直接写入）。</p></li><li><p><strong>原理</strong>：只要最终的数据库状态和某种串行执行的结果一致即可。即使中间过程有冲突，如果最后的盲写覆盖了错误，那也是可接受的 。</p></li><li><p><strong>现状</strong>：很难高效地验证（通常是 NP 完全问题），所以数据库系统<strong>实际上不使用</strong>它，而是坚持使用冲突可串行化 。</p></li></ul><h3 id="调度集合的关系-Universe-of-Schedules"><a href="#调度集合的关系-Universe-of-Schedules" class="headerlink" title="调度集合的关系 (Universe of Schedules)"></a>调度集合的关系 (Universe of Schedules)</h3><h2 id="描述了包含关系：-text-Serial-subset-text-Conflict-Serializable-subset-text-View-Serializable-subset-text-All-Schedules"><a href="#描述了包含关系：-text-Serial-subset-text-Conflict-Serializable-subset-text-View-Serializable-subset-text-All-Schedules" class="headerlink" title=" 描述了包含关系：$$\text{Serial} \subset \text{Conflict Serializable} \subset \text{View Serializable} \subset \text{All Schedules}$$"></a> 描述了包含关系：<br>$$\text{Serial} \subset \text{Conflict Serializable} \subset \text{View Serializable} \subset \text{All Schedules}$$</h2><h3 id="补充总结：理解的核心逻辑"><a href="#补充总结：理解的核心逻辑" class="headerlink" title="补充总结：理解的核心逻辑"></a>补充总结：理解的核心逻辑</h3><ol><li><strong>目标</strong>：我们想要并发（快），但不能乱（正确）。</li><li><strong>标准</strong>：什么叫“不乱”？标准是 ACID 中的 <strong>Isolation</strong>。</li><li><strong>度量</strong>：怎么判断 Isolation 达标了？看这个调度是否 <strong>Serializable</strong>（等价于串行）。</li><li><strong>实现</strong>：怎么判断是否 Serializable？</li></ol><ul><li><strong>View Serializability</strong> 理论完美但太难算。</li><li><strong>Conflict Serializability</strong> 容易算（查有无环），虽然漏掉了一些盲写的情况，但足够好用。</li></ul><ol start="5"><li><strong>手段</strong>：怎么保证生成的调度是 Conflict Serializable 的？通过锁（2PL）或时间戳排序（Timestamp Ordering）等协议（这是下一节课的内容）。</li></ol><p>这份 CMU 15-445&#x2F;645 Database Systems (Fall 2024) Lecture #17 <strong>Two-Phase Locking (二阶段锁)</strong> 的课程笔记整理如下。</p><p>这份笔记在总结课件核心内容的基础上，补充了相关原理的对比和解析，旨在帮助你理解数据库如何通过锁机制“动态地”保证事务的正确性（可串行化）。</p><hr><h1 id="第十七讲：Two-Phase-Locking-二阶段锁"><a href="#第十七讲：Two-Phase-Locking-二阶段锁" class="headerlink" title="第十七讲：Two-Phase Locking (二阶段锁)"></a>第十七讲：Two-Phase Locking (二阶段锁)</h1><h2 id="1-事务锁-Transaction-Locks"><a href="#1-事务锁-Transaction-Locks" class="headerlink" title="1. 事务锁 (Transaction Locks)"></a>1. 事务锁 (Transaction Locks)</h2><p>在之前的理论课中，我们假设在安排调度时已经知道所有事务的读写操作。但在现实中，DBMS 无法预知未来。因此，我们需要一种机制在<strong>运行时 (On-the-fly)</strong> 动态生成正确的调度。</p><h3 id="锁的本质"><a href="#锁的本质" class="headerlink" title="锁的本质"></a>锁的本质</h3><p>DBMS 使用<strong>锁 (Locks)</strong> 来保护数据库对象，防止多个事务同时读写造成冲突。</p><ul><li><p><strong>锁管理器 (Lock Manager)</strong>：一个中心化的组件，负责维护内部的锁表 (Lock Table)，决定是否批准事务的锁请求 。</p></li><li><p><strong>锁 vs. Latch</strong>：这是一个常考的面试点 。</p><ul><li><strong>Locks</strong>：保护数据库的逻辑内容（如元组、表），属于事务层，持续时间长（整个事务期间），支持回滚。</li><li><strong>Latches</strong>：保护 DBMS 内部的数据结构（如 B+ 树节点、哈希表 bucket），属于线程&#x2F;物理层，持续时间极短（临界区），不需要回滚。</li></ul></li></ul><h3 id="基本锁类型"><a href="#基本锁类型" class="headerlink" title="基本锁类型"></a>基本锁类型</h3><ol><li><p><strong>Shared Lock (S-LOCK &#x2F; 共享锁)</strong>：</p><ul><li><strong>用途</strong>：用于<strong>读取</strong>对象。</li><li><strong>兼容性</strong>：多个事务可以同时持有同一个对象的 S 锁（即多读不互斥）。</li></ul></li><li><p><strong>Exclusive Lock (X-LOCK &#x2F; 排他锁)</strong>：</p><ul><li><strong>用途</strong>：用于<strong>修改</strong>对象。</li><li><strong>兼容性</strong>：如果一个对象被加了 X 锁，其他任何事务都不能对它加任何锁（S 或 X）。X 锁必须独占 。</li></ul></li></ol><hr><h2 id="2-二阶段锁协议-Two-Phase-Locking-2PL"><a href="#2-二阶段锁协议-Two-Phase-Locking-2PL" class="headerlink" title="2. 二阶段锁协议 (Two-Phase Locking - 2PL)"></a>2. 二阶段锁协议 (Two-Phase Locking - 2PL)</h2><p>仅仅有锁是不够的，如果事务随意加锁解锁，依然可能导致不可串行化的结果。<strong>2PL</strong> 是一种悲观的并发控制协议，它规定了事务<strong>何时</strong>可以加锁和解锁，以此来保证冲突可串行化（Conflict Serializability）。</p><h3 id="协议规则"><a href="#协议规则" class="headerlink" title="协议规则"></a>协议规则</h3><p>2PL 将事务的执行分为两个阶段 ：</p><ol><li><p><strong>增长阶段 (Growing Phase)</strong>：</p><ul><li>事务可以<strong>申请</strong>新锁（S 或 X）。</li><li><strong>绝对不允许</strong>释放任何锁。</li></ul></li><li><p><strong>缩减阶段 (Shrinking Phase)</strong>：</p><ul><li>一旦事务释放了第一个锁，就立即进入缩减阶段。</li><li>在此阶段，事务只能<strong>释放</strong>锁。</li><li><strong>绝对不允许</strong>申请新锁。</li></ul></li></ol><h3 id="2PL-的性质"><a href="#2PL-的性质" class="headerlink" title="2PL 的性质"></a>2PL 的性质</h3><ul><li><p><strong>正确性</strong>：2PL 足以保证生成的调度是<strong>冲突可串行化</strong>的（Dependency Graph 无环）。</p></li><li><p><strong>问题 1：级联中止 (Cascading Aborts)</strong>：</p><ul><li>如果 T1 写了数据 A（未提交），T2 读了 A。此时 T1 中止（回滚），T2 读到的就是脏数据，必须也被强制中止。这会导致连锁反应，浪费大量计算资源 。</li></ul></li><li><p><strong>问题 2：死锁 (Deadlocks)</strong>：2PL 可能导致死锁（互相等待）。</p></li></ul><h3 id="强严格二阶段锁-Strong-Strict-2PL-SS2PL"><a href="#强严格二阶段锁-Strong-Strict-2PL-SS2PL" class="headerlink" title="强严格二阶段锁 (Strong Strict 2PL &#x2F; SS2PL)"></a>强严格二阶段锁 (Strong Strict 2PL &#x2F; SS2PL)</h3><p>为了解决级联中止问题，现代 DBMS 通常使用 SS2PL（也称为 Rigorous 2PL）。</p><ul><li><p><strong>规则</strong>：事务只能在<strong>提交 (Commit)</strong> 或 <strong>中止 (Abort)</strong> 的那一刻，一次性释放<strong>所有</strong>的锁 。</p></li><li><p><strong>优点</strong>：</p><ul><li><strong>无级联中止</strong>：只有已提交的数据才能被别人读到。</li><li><strong>恢复简单</strong>：回滚时只需恢复旧值，不会影响其他正在运行的事务 。</li></ul></li><li><p><strong>代价</strong>：持锁时间变长，并发度降低 。</p></li></ul><p><strong>调度集合的关系</strong>：</p><h2 id="text-Strong-Strict-2PL-subset-text-Conflict-Serializable-subset-text-View-Serializable-subset-text-All-Schedules"><a href="#text-Strong-Strict-2PL-subset-text-Conflict-Serializable-subset-text-View-Serializable-subset-text-All-Schedules" class="headerlink" title="$$\text{Strong Strict 2PL} \subset \text{Conflict Serializable} \subset \text{View Serializable} \subset \text{All Schedules}$$"></a>$$\text{Strong Strict 2PL} \subset \text{Conflict Serializable} \subset \text{View Serializable} \subset \text{All Schedules}$$</h2><h2 id="3-死锁处理-Deadlock-Handling"><a href="#3-死锁处理-Deadlock-Handling" class="headerlink" title="3. 死锁处理 (Deadlock Handling)"></a>3. 死锁处理 (Deadlock Handling)</h2><p>死锁是指两个或多个事务互相持有对方需要的锁，导致无限等待 。处理死锁有两种策略：</p><h3 id="策略-1-死锁检测-Deadlock-Detection"><a href="#策略-1-死锁检测-Deadlock-Detection" class="headerlink" title="策略 #1: 死锁检测 (Deadlock Detection)"></a>策略 #1: 死锁检测 (Deadlock Detection)</h3><p>DBMS 允许死锁发生，但会定期检查并打破它。</p><ul><li><p><strong>等待图 (Waits-for Graph)</strong>：节点是事务，边$T_i \to T_j$ 表示 $T_i$ 正在等待 $T_j$ 释放锁。如果图中出现<strong>环</strong>，说明有死锁 。</p></li><li><p><strong>处理流程</strong>：后台线程定期构建等待图。如果发现环，选择一个<strong>受害者 (Victim)</strong> 事务进行回滚 。</p></li><li><p><strong>受害者选择标准</strong>：</p><ul><li><p><strong>年龄</strong>（通常杀年轻的，保护老的）。</p></li><li><p><strong>进度</strong>（杀进度少的）。</p></li><li><p><strong>锁数量</strong>（杀持有锁少的，回滚开销小）。</p></li><li><p><strong>防饥饿</strong>：如果一个事务每次都被杀，它会“饥饿”。系统应记录它被杀的次数，下次提高它的优先级 。</p></li></ul></li></ul><h3 id="策略-2-死锁预防-Deadlock-Prevention"><a href="#策略-2-死锁预防-Deadlock-Prevention" class="headerlink" title="策略 #2: 死锁预防 (Deadlock Prevention)"></a>策略 #2: 死锁预防 (Deadlock Prevention)</h3><p>DBMS 在事务申请锁时就扼杀死锁的可能性，不允许出现循环等待。这通常基于<strong>时间戳 (Timestamp)</strong> 分配优先级（越老优先级越高）。</p><ul><li><p><strong>Wait-Die (老等，少死)</strong>：</p><ul><li>如果请求者优先级 <strong>高</strong> (老)：允许等待 (Wait)。</li><li>如果请求者优先级 <strong>低</strong> (新)：自己中止 (Die)。</li></ul></li><li><p><strong>Wound-Wait (老杀，少等)</strong>：</p><ul><li>如果请求者优先级 <strong>高</strong> (老)：强制抢占，把持有者中止 (Wound)。</li><li>如果请求者优先级 <strong>低</strong> (新)：老实等待 (Wait)。</li></ul></li></ul><p><strong>记忆口诀</strong>：如果协议名是 X-Y，请求者优先级<strong>高</strong>时做 X，<strong>低</strong>时做 Y 。</p><hr><h2 id="4-锁的粒度-Lock-Granularities"><a href="#4-锁的粒度-Lock-Granularities" class="headerlink" title="4. 锁的粒度 (Lock Granularities)"></a>4. 锁的粒度 (Lock Granularities)</h2><p>如果一个事务要更新 10 亿条记录：</p><ul><li><p>申请 10 亿个 Tuple Lock？太慢，锁管理器内存爆炸 。</p></li><li><p>申请 1 个 Table Lock？太粗，阻塞了所有其他只读该表一行的事务 。</p></li></ul><p><strong>解决方案</strong>：多粒度锁 (Lock Hierarchy)。</p><ul><li><p><strong>层级</strong>：Database \to Table \to Page \to Tuple 。</p></li><li><p><strong>意向锁 (Intention Locks)</strong>：</p><ul><li>当事务想给底层节点（如 Tuple）加锁时，必须先给上层节点（如 Table, Page）加<strong>意向锁</strong>。</li><li>这就像在大楼门口挂个牌子：“里面有人正在干活，别锁大门”。这样其他事务想锁整个表时，看一眼表上的意向锁就知道不行，不用逐行检查 。</li></ul></li></ul><p><strong>意向锁类型</strong> ：</p><ol><li><strong>IS (Intention-Shared)</strong>：打算在底层加 S 锁。</li><li><strong>IX (Intention-Exclusive)</strong>：打算在底层加 X 锁。</li><li><strong>SIX (Shared + Intention-Exclusive)</strong>：我读整个子树（S），同时我要修改底层的某些节点（IX）。（例如：全表扫描并更新部分行）。</li></ol><p><strong>锁升级 (Lock Escalation)</strong>：当 DBMS 发现一个事务在某个对象上持有的锁太多（例如在一个表里锁了 1000 行），它会自动将这些细粒度锁合并成一个粗粒度锁（把 1000 个行锁升级为 1 个表锁），以节省资源 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>2PL</strong> 解决了并发执行的<strong>正确性</strong>问题（通过强制两阶段）。</li><li><strong>Strong Strict 2PL</strong> 进一步解决了<strong>级联回滚</strong>问题。</li><li><strong>死锁检测&#x2F;预防</strong> 解决了 2PL 带来的<strong>死锁</strong>副作用。</li><li><strong>意向锁</strong> 解决了锁管理的<strong>性能与并发度平衡</strong>问题。</li></ul><p>这份笔记基于 CMU 15-445&#x2F;645 课程的第 17 讲（Lecture #17: Timestamp Ordering Concurrency Control），系统地总结了基于时间戳的并发控制协议、乐观并发控制（OCC）、幻读问题及其解决方案。</p><hr><h1 id="第十八讲：时间戳排序并发控制-Timestamp-Ordering"><a href="#第十八讲：时间戳排序并发控制-Timestamp-Ordering" class="headerlink" title="第十八讲：时间戳排序并发控制 (Timestamp Ordering)"></a>第十八讲：时间戳排序并发控制 (Timestamp Ordering)</h1><h2 id="1-时间戳排序协议-Timestamp-Ordering-T-O"><a href="#1-时间戳排序协议-Timestamp-Ordering-T-O" class="headerlink" title="1. 时间戳排序协议 (Timestamp Ordering, T&#x2F;O)"></a>1. 时间戳排序协议 (Timestamp Ordering, T&#x2F;O)</h2><p>时间戳排序是一种<strong>乐观 (Optimistic)</strong> 的并发控制协议 。与悲观协议（如 2PL）不同，它不要求事务在读写前获取锁，而是利用时间戳来决定事务的串行化顺序 。</p><ul><li><p><strong>核心原理</strong>：为每个事务 T_{i} 分配一个唯一且单调递增的时间戳 TS(T_{i}) 。</p></li><li><p><strong>串行顺序</strong>：如果 TS(T_{i}) &lt; TS(T_{j})，DBMS 必须确保执行结果等价于 T_{i} 在 T_{j} 之前执行的串行计划 。</p></li><li><p><strong>分配策略</strong>：</p></li><li><p><strong>系统时钟</strong>：可能存在夏令时等边缘问题 。</p></li><li><p><strong>逻辑计数器</strong>：存在溢出问题，且在分布式系统中难以维护 。</p></li><li><p><strong>混合方式</strong>：结合上述两种方法 。</p></li></ul><hr><h2 id="2-乐观并发控制-Optimistic-Concurrency-Control-OCC"><a href="#2-乐观并发控制-Optimistic-Concurrency-Control-OCC" class="headerlink" title="2. 乐观并发控制 (Optimistic Concurrency Control, OCC)"></a>2. 乐观并发控制 (Optimistic Concurrency Control, OCC)</h2><p>OCC 假设事务冲突极少发生，适用于读多写少或访问数据不重叠的场景 。</p><p>OCC 的三个阶段 </p><ol><li><p><strong>Read Phase (读取阶段)</strong>：DBMS 为每个事务创建一个私有工作空间 。事务读取的对象被复制到工作空间，所有的修改也仅应用于该空间 。</p></li><li><p><strong>Validation Phase (验证阶段)</strong>：当事务提交时，DBMS 检查其写集是否与其他事务冲突 。</p></li><li><p><strong>Write Phase (写入阶段)</strong>：如果验证通过，将私有空间中的修改应用到全局数据库；否则，中止并重启事务 。</p></li></ol><h3 id="验证逻辑-Validation-Phase"><a href="#验证逻辑-Validation-Phase" class="headerlink" title="验证逻辑 (Validation Phase)"></a>验证逻辑 (Validation Phase)</h3><p>DBMS 在验证阶段为事务分配时间戳 。为了确保串行化，必须检查 T_{i} 与其他事务之间的读写（RW）和写写（WW）冲突 。</p><ul><li><p><strong>前向验证 (Forward Validation)</strong>：检查提交事务与所有正在运行的事务之间的冲突 。</p></li><li><p><strong>后向验证 (Backward Validation)</strong>：检查提交事务与已提交事务之间的冲突 。</p></li></ul><p><strong>验证成功必须满足的条件（以 TS(T_{i}) &lt; TS(T_{j}) 为例）</strong>：</p><ul><li><p>条件 1：$T_{i}$ 在 $T_{j}$ 开始前完成所有阶段 。</p></li><li><p>条件 2：$T_{i}$ 在 $T_{j}$ 开始写入前完成写入，且 $T_{i}$ 的写集与 $T_{j}$ 的读集不相交（$WriteSet(T_{i}) \cap ReadSet(T_{j}) &#x3D; \emptyset$） 。</p></li><li><p>条件 3：$T_{i}$ 在 $T_{j}$ 完成读取前完成其读取，且 $T_{i}$ 的写集与 $T_{j}$ 的读集和写集都不相交 。</p></li></ul><hr><h2 id="3-动态数据库与幻读问题-Phantom-Problem"><a href="#3-动态数据库与幻读问题-Phantom-Problem" class="headerlink" title="3. 动态数据库与幻读问题 (Phantom Problem)"></a>3. 动态数据库与幻读问题 (Phantom Problem)</h2><p>当事务涉及插入、更新和删除时，仅锁定现有记录是不够的 。<strong>幻读</strong>是指一个事务在同一范围内执行两次相同的查询，却得到了不同的结果集 。</p><h3 id="解决幻读的方案"><a href="#解决幻读的方案" class="headerlink" title="解决幻读的方案"></a>解决幻读的方案</h3><ol><li><p><strong>重执行扫描 (Re-Execute Scans)</strong>：在提交时重新运行所有带有 <code>WHERE</code> 子句的查询，检查结果是否一致 。</p></li><li><p><strong>谓词锁 (Predicate Locking)</strong>：对查询的谓词属性加锁，但由于开销大，很少被实际应用 。</p></li><li><p><strong>索引锁 (Index Locking)</strong>：利用索引键保护数据范围 。</p><ul><li><p><strong>Key-Value Locks</strong>：锁定索引中的单个键值 。</p></li><li><p><strong>Gap Locks (间隙锁)</strong>：锁定键值之间的间隙，防止新数据插入该间隙 。</p></li><li><p><strong>Key-Range Locks</strong>：锁定一个键到下一个现有键之间的范围 。</p></li></ul></li></ol><hr><h2 id="4-隔离级别-Isolation-Levels"><a href="#4-隔离级别-Isolation-Levels" class="headerlink" title="4. 隔离级别 (Isolation Levels)"></a>4. 隔离级别 (Isolation Levels)</h2><p>为了提高性能，DBMS 允许在串行化之外使用较弱的隔离级别 。</p><table><thead><tr><th align="left">隔离级别</th><th align="left">脏读 (Dirty Read)</th><th align="left">不可重复读(Unrepeatable Read)</th><th align="left">幻读 (Phantom Read)</th><th align="left">常见实现方式</th></tr></thead><tbody><tr><td align="left"><strong>SERIALIZABLE</strong></td><td align="left">不允许</td><td align="left">不允许</td><td align="left">不允许</td><td align="left">严格 2PL + 幻读保护</td></tr><tr><td align="left"><strong>REPEATABLE READS</strong></td><td align="left">不允许</td><td align="left">不允许</td><td align="left"><strong>可能发生</strong></td><td align="left">严格 2PL</td></tr><tr><td align="left"><strong>READ COMMITTED</strong></td><td align="left">不允许</td><td align="left"><strong>可能发生</strong></td><td align="left"><strong>可能发生</strong></td><td align="left">写加锁，读后立即释放共享锁</td></tr><tr><td align="left"><strong>READ UNCOMMITTED</strong></td><td align="left"><strong>可能发生</strong></td><td align="left"><strong>可能发生</strong></td><td align="left"><strong>可能发生</strong></td><td align="left">写加锁，读不加共享锁</td></tr></tbody></table><hr><h3 id="补充理解：OCC-的代价"><a href="#补充理解：OCC-的代价" class="headerlink" title="补充理解：OCC 的代价"></a>补充理解：OCC 的代价</h3><p>虽然 OCC 避免了锁管理器的开销，但它并非完美。正如笔记中提到的，OCC 存在显著的<strong>数据复制开销</strong> 以及<strong>中止浪费</strong>（事务在执行完所有工作后才发现冲突被中止） 。因此，在冲突频繁的高压力环境下，OCC 的性能往往不如传统的 2PL。</p><p>这份 CMU 15-445&#x2F;645 Database Systems (Fall 2024) Lecture #19 <strong>Multi-Version Concurrency Control (多版本并发控制)</strong> 的课程笔记整理如下。</p><p>这份笔记在总结课件核心内容的基础上，补充了相关原理的深度解析，帮助你理解为什么现代数据库（如 Postgres, MySQL&#x2F;InnoDB, Oracle）几乎都使用 MVCC。</p><hr><h1 id="第十九讲：Multi-Version-Concurrency-Control-MVCC"><a href="#第十九讲：Multi-Version-Concurrency-Control-MVCC" class="headerlink" title="第十九讲：Multi-Version Concurrency Control (MVCC)"></a>第十九讲：Multi-Version Concurrency Control (MVCC)</h1><h2 id="1-核心概念：什么是-MVCC？"><a href="#1-核心概念：什么是-MVCC？" class="headerlink" title="1. 核心概念：什么是 MVCC？"></a>1. 核心概念：什么是 MVCC？</h2><p><strong>多版本并发控制 (MVCC)</strong> 不仅仅是一个具体的协议，而是一种通过维护数据的多个物理版本来实现并发控制的设计理念 。</p><ul><li><p><strong>基本原理</strong>：</p><ul><li><p>DBMS 为数据库中的每个逻辑对象（Logical Object）维护多个物理版本（Physical Versions）。</p></li><li><p><strong>写操作</strong>：当事务更新数据时，不是覆盖原数据，而是创建一个带有新时间戳的<strong>新版本</strong> 。</p></li><li><p><strong>读操作</strong>：当事务读取数据时，它读取的是该事务开始那一刻“可见”的最新版本（也就是快照）。</p></li></ul></li><li><p><strong>核心优势 ( The “Golden Rule” )</strong>：</p><blockquote><p><strong>Writers do not block readers, and readers do not block writers.</strong><br>(写操作不阻塞读操作，读操作也不阻塞写操作。)</p></blockquote></li></ul><p>这意味着一个事务在修改数据 A 的同时，另一个事务可以毫无阻碍地读取数据 A 的旧版本 。这比传统的二阶段锁（2PL）并发度高得多，因为在 2PL 中读写是互斥的。</p><p>注意：写操作之间仍然可能互相阻塞（Write-Write Conflict），通常通过对特定版本加锁解决 。</p><hr><h2 id="2-快照隔离-Snapshot-Isolation"><a href="#2-快照隔离-Snapshot-Isolation" class="headerlink" title="2. 快照隔离 (Snapshot Isolation)"></a>2. 快照隔离 (Snapshot Isolation)</h2><p>MVCC 天然支持<strong>快照隔离 (SI)</strong> 级别。</p><ul><li><p><strong>工作机制</strong>：</p><ul><li><p>事务开始时，DBMS 会为它拍一张“快照”（通常由 Transaction Status Table 和时间戳决定）。</p></li><li><p>事务在整个生命周期内，看到的数据都是基于这张快照的。它完全与其他并发事务隔离开来 。</p></li><li><p>这对<strong>只读事务</strong>是完美的，因为它们不需要任何锁，就能读到一致的数据 。</p></li></ul></li><li><p><strong>写冲突 (Write Conflicts)</strong>：</p><ul><li>如果两个事务试图更新同一个对象，<strong>先写者胜 (First Writer Wins)</strong> 。后来的写者要么等待，要么中止。</li></ul></li><li><p><strong>异常：写偏斜 (Write Skew)</strong>：</p><ul><li>这是 SI 隔离级别下特有的异常（在可串行化级别下不应发生）。</li></ul></li><li><p><strong>场景</strong>：两个并发事务读取了<strong>不同</strong>的对象，但修改导致了整体逻辑约束被破坏。</p></li><li><p><strong>例子</strong>：由于此时读写不互斥，如果事务 A 把所有白球涂黑，事务 B 把所有黑球涂白，最终结果可能既有黑又有白，这在串行执行中是不可能出现的 。</p></li></ul><hr><h2 id="3-MVCC-的四大设计决策"><a href="#3-MVCC-的四大设计决策" class="headerlink" title="3. MVCC 的四大设计决策"></a>3. MVCC 的四大设计决策</h2><p>实现 MVCC 需要解决四个主要的设计问题：</p><ol><li><strong>版本存储 (Version Storage)</strong>：怎么存？</li><li><strong>垃圾回收 (Garbage Collection)</strong>：怎么删？</li><li><strong>索引管理 (Index Management)</strong>：怎么找？</li><li><strong>删除处理 (Deletes)</strong>：怎么标？</li></ol><h3 id="1-版本存储-Version-Storage"><a href="#1-版本存储-Version-Storage" class="headerlink" title="(1) 版本存储 (Version Storage)"></a>(1) 版本存储 (Version Storage)</h3><p>每个逻辑元组（Tuple）都有一个<strong>版本链 (Version Chain)</strong>，这是一个按时间戳排序的链表 。索引通常指向链表的“头”。</p><p>主要有三种存储物理版本的方法：</p><ol><li><strong>Append-Only Storage (追加存储)</strong></li></ol><ul><li><p>所有版本（新旧）都混在同一个表中。更新时，直接在表中追加新行，并更新链表指针。</p></li><li><p><strong>链表顺序</strong>：</p><ul><li><em>Oldest-to-Newest (O2N)</em>：链表头是最老版本。缺点是读最新数据需要遍历整个链表（慢）。</li><li><em>Newest-to-Oldest (N2O)</em>：链表头是最新版本。优点是读取最快（因为大多数查询都查最新数据），缺点是每次更新都要修改索引指向新的头 。</li></ul></li><li><p><em>PostgreSQL 使用此方案。</em></p></li></ul><ol start="2"><li><strong>Time-Travel Storage (时间旅行存储)</strong></li></ol><ul><li>主表只存<strong>最新</strong>版本。</li><li>旧版本被复制到一个单独的“历史表 (Time-Travel Table)”中。</li><li>优点是主表很紧凑，全表扫描快。</li></ul><ol start="3"><li><strong>Delta Storage (增量存储)</strong></li></ol><ul><li>主表存最新版本。</li><li>“回滚段 (Delta Storage)”中只存储<strong>修改的值 (Delta&#x2F;Changes)</strong>，而不是完整的旧行。</li><li><strong>原理</strong>：想看旧版本？拿最新版本，逆向应用 Delta 算出来。<ul><li><em>优点</em>：写入极快，节省空间。<em>缺点</em>：读取旧版本慢（需要计算）。</li><li><em>MySQL (InnoDB) 和 Oracle 使用此方案。</em></li></ul></li></ul><h3 id="2-垃圾回收-Garbage-Collection-GC"><a href="#2-垃圾回收-Garbage-Collection-GC" class="headerlink" title="(2) 垃圾回收 (Garbage Collection - GC)"></a>(2) 垃圾回收 (Garbage Collection - GC)</h3><p>随着更新增多，旧版本会堆积。当没有活跃事务需要通过快照看到某个旧版本时，该版本就是“可回收”的 。</p><ol><li><strong>元组级 GC (Tuple-level GC)</strong></li></ol><ul><li><p><strong>后台清理 (Background Vacuuming)</strong>：后台线程定期扫描表，通过比对活跃事务的位图，清除不可见的版本 。</p></li><li><p><strong>协作清理 (Cooperative Cleaning)</strong>：工作线程（Worker）在执行查询扫描版本链时，顺手把不再需要的旧版本删掉（仅适用于 O2N 顺序）。</p></li></ul><ol start="2"><li><strong>事务级 GC (Transaction-level GC)</strong></li></ol><ul><li>每个事务负责记录自己产生了哪些旧版本。当事务结束且确认这些版本不再被需要时，由系统回收。</li></ul><h3 id="3-索引管理-Index-Management"><a href="#3-索引管理-Index-Management" class="headerlink" title="(3) 索引管理 (Index Management)"></a>(3) 索引管理 (Index Management)</h3><p>在 MVCC 中，主键索引 (Primary Key Index) 总是指向版本链的头部 。难点在于<strong>辅助索引 (Secondary Indexes)</strong>。</p><p>如果更新了数据（导致产生了新版本的物理位置变化），辅助索引该怎么办？</p><ol><li><strong>逻辑指针 (Logical Pointers)</strong></li></ol><ul><li>辅助索引存储主键（或逻辑 ID），而不是物理地址。</li><li><em>查找路径</em>：辅助索引 -&gt; 主键 -&gt; 主键索引 -&gt; 物理地址。</li><li><em>优点</em>：更新数据时，不需要修改辅助索引（因为主键没变）。</li><li><em>缺点</em>：读数据多了一次查找（回表），慢。</li></ul><ol start="2"><li><strong>物理指针 (Physical Pointers)</strong></li></ol><ul><li>辅助索引直接存储物理地址（指向版本链头）。</li><li><em>优点</em>：读数据快，一步到位。</li><li></li></ul><p><em>缺点</em>：<strong>写放大</strong>。一旦更新数据产生新版本，所有指向该数据的辅助索引都必须更新指向新地址 。</p><p><strong>重复键问题 (Duplicate Key Problem)</strong> ：<br>在 MVCC 中，索引可能包含同一个 Key 的多个条目（指向不同版本的元组）。索引结构必须支持非唯一 Key，即使是唯一索引在底层物理存储上也可能因为版本共存而出现重复。</p><h3 id="4-删除-Deletes"><a href="#4-删除-Deletes" class="headerlink" title="(4) 删除 (Deletes)"></a>(4) 删除 (Deletes)</h3><p>在 MVCC 中，物理删除也是一种“更新”。</p><ol><li><p><strong>Deleted Flag</strong>：在元组头加个标记，说“我被删了” 。</p></li><li><p><strong>Tombstone Tuple (墓碑元组)</strong>：插入一个特殊的空版本，标志着生命周期的结束 。<br>真正的物理删除由垃圾回收器（GC）稍后完成 。</p></li></ol><hr><h2 id="4-总结与补充"><a href="#4-总结与补充" class="headerlink" title="4. 总结与补充"></a>4. 总结与补充</h2><p>MVCC 是现代数据库并发控制的事实标准。</p><ul><li><strong>相比 2PL</strong>：MVCC 最大的贡献是解除了“读-写”阻塞。读操作永远不会因为写锁而被挂起，这对于以读为主的互联网应用至关重要。</li><li><strong>代价</strong>：<ol><li><strong>空间放大</strong>：需要存储多版本。</li><li><strong>管理开销</strong>：需要复杂的垃圾回收机制，否则数据库会无限膨胀（PostgreSQL 的 Vacuum 问题就是典型）。</li><li><strong>索引维护</strong>：更新操作可能导致严重的索引写放大。</li></ol></li></ul><h3 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h3><p>如果你的系统是<strong>写密集型 (Write-Heavy)</strong> 的，且几乎不读历史数据，Append-Only Storage 的 N2O 策略和 Delta Storage 哪个更好？</p><ul><li><em>分析</em>：Delta Storage 通常更好。因为 Append-Only 每次 Update 都要复制整个 Tuple，写放大严重；而 Delta 只存变更量，写入 I&#x2F;O 更小。这也是为什么写性能强悍的 InnoDB 选择 Delta Storage 的原因。</li></ul><p>这份笔记基于 CMU 15-445&#x2F;645 课程第 20 讲（Lecture #20: Database Logging），系统总结了数据库恢复算法、缓冲池管理策略、影子分页、预写日志（WAL）以及检查点机制。</p><hr><h1 id="第二十讲：数据库日志与故障恢复-Database-Logging"><a href="#第二十讲：数据库日志与故障恢复-Database-Logging" class="headerlink" title="第二十讲：数据库日志与故障恢复 (Database Logging)"></a>第二十讲：数据库日志与故障恢复 (Database Logging)</h1><h2 id="1-故障恢复概述-Crash-Recovery"><a href="#1-故障恢复概述-Crash-Recovery" class="headerlink" title="1. 故障恢复概述 (Crash Recovery)"></a>1. 故障恢复概述 (Crash Recovery)</h2><p>恢复算法是确保数据库在发生故障（如断电、系统崩溃）后，依然能保持<strong>一致性 (Consistency)</strong>、<strong>原子性 (Atomicity)</strong> 和<strong>持久性 (Durability)</strong> 的技术 。</p><h3 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h3><ul><li><p><strong>UNDO</strong>：撤销未完成或已回滚事务对数据库的影响 。</p></li><li><p><strong>REDO</strong>：重新应用已提交事务的影响，以确保持久性 。</p></li></ul><hr><h2 id="2-缓冲池管理策略-Buffer-Pool-Management-Policies"><a href="#2-缓冲池管理策略-Buffer-Pool-Management-Policies" class="headerlink" title="2. 缓冲池管理策略 (Buffer Pool Management Policies)"></a>2. 缓冲池管理策略 (Buffer Pool Management Policies)</h2><p>DBMS 必须平衡系统性能与数据安全性。这主要由两个策略决定：</p><h3 id="A-Steal-策略-窃取"><a href="#A-Steal-策略-窃取" class="headerlink" title="A. Steal 策略 (窃取)"></a>A. Steal 策略 (窃取)</h3><p>定义是否允许未提交的事务覆盖非易失性存储（磁盘）中最近提交的值 。</p><ul><li><p><strong>STEAL</strong>：允许 。优点是内存利用率高，但崩溃后需要 <strong>UNDO</strong> 。</p></li><li><p><strong>NO-STEAL</strong>：不允许 。不需要 UNDO，但事务修改量受限于可用内存 。</p></li></ul><h3 id="B-Force-策略-强制"><a href="#B-Force-策略-强制" class="headerlink" title="B. Force 策略 (强制)"></a>B. Force 策略 (强制)</h3><p>定义是否要求事务在提交前，将其所有更新都反映到磁盘上 。</p><ul><li><p><strong>FORCE</strong>：强制要求 。恢复简单，但由于涉及大量随机写，运行时性能极差 。</p></li><li><p><strong>NO-FORCE</strong>：不强制 。运行时性能最优，但崩溃后需要 <strong>REDO</strong> 。</p></li></ul><blockquote><p><strong>总结</strong>：现代主流 DBMS 通常采用 <strong>STEAL + NO-FORCE</strong> 策略，因为它能提供最佳的运行时性能 。</p></blockquote><hr><h2 id="3-影子分页-Shadow-Paging"><a href="#3-影子分页-Shadow-Paging" class="headerlink" title="3. 影子分页 (Shadow Paging)"></a>3. 影子分页 (Shadow Paging)</h2><p>这是一种早期的 <strong>NO-STEAL + FORCE</strong> 系统实现 。</p><ul><li><p><strong>原理</strong>：DBMS 维护两份页表：<strong>Master (主页表)</strong> 和 <strong>Shadow (影子页表)</strong> 。</p></li><li><p><strong>执行</strong>：写操作只发生在影子页表中 。</p></li><li><p><strong>提交</strong>：通过原子性地修改根节点指针，让主页表指向影子页表的内容 。</p></li><li><p><strong>缺点</strong>：复制页表开销大、导致随机写、造成数据碎片、且需要垃圾回收机制 。</p></li></ul><hr><h2 id="4-预写日志-Write-Ahead-Logging-WAL"><a href="#4-预写日志-Write-Ahead-Logging-WAL" class="headerlink" title="4. 预写日志 (Write-Ahead Logging, WAL)"></a>4. 预写日志 (Write-Ahead Logging, WAL)</h2><p>这是目前几乎所有数据库（如 PostgreSQL, MySQL, SQL Server）的标准做法 。</p><h3 id="核心准则-The-Golden-Rule"><a href="#核心准则-The-Golden-Rule" class="headerlink" title="核心准则 (The Golden Rule)"></a>核心准则 (The Golden Rule)</h3><p>在将数据页刷新到磁盘之前，必须先将对应修改的日志记录写入稳定存储（磁盘） 。</p><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><ol><li><p>事务的所有日志记录先缓存在内存的 <strong>WAL Buffer</strong> 中 。</p></li><li><p>只有在事务的所有日志都刷入磁盘后，该事务才被认为已提交 。</p></li><li><p><strong>日志记录内容</strong>：事务 ID、对象 ID、<strong>Before Value (用于 UNDO)</strong>、<strong>After Value (用于 REDO)</strong> 。</p></li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>将随机写操作转变为顺序写日志，极大提升了系统吞吐量 。</p><hr><h2 id="5-日志记录方案-Logging-Schemes"><a href="#5-日志记录方案-Logging-Schemes" class="headerlink" title="5. 日志记录方案 (Logging Schemes)"></a>5. 日志记录方案 (Logging Schemes)</h2><p>日志中存储内容的粒度各不相同：</p><ul><li><p><strong>物理日志 (Physical Logging)</strong>：记录数据库特定位置的字节级更改（类似于 git diff） 。</p></li><li><p><strong>逻辑日志 (Logical Logging)</strong>：记录高层操作（如 <code>INSERT</code> 或 <code>UPDATE</code> 语句） 。存储量小，但并发环境下恢复极难且缓慢 。</p></li><li><p><strong>生理日志 (Physiological Logging)</strong>：<strong>最常用的方案</strong> 。日志针对单个数据页，但通过插槽号（Slot Number）标识元组，而不指定页内具体字节位置 。这允许 DBMS 在日志写盘后重新组织页面布局 。</p></li></ul><hr><h2 id="6-检查点-Checkpoints"><a href="#6-检查点-Checkpoints" class="headerlink" title="6. 检查点 (Checkpoints)"></a>6. 检查点 (Checkpoints)</h2><p>如果不受限制，WAL 日志会无限增长，导致系统崩溃后的恢复时间过长 。</p><ul><li><p><strong>机制</strong>：DBMS 定期执行检查点操作，将缓冲池中的所有脏页（Dirty Pages）刷新到磁盘，并写入一个 <code>&lt;CHECKPOINT&gt;</code> 记录 。</p></li><li><p><strong>阻塞式实现</strong>：停止接受新事务，等待当前事务完成，然后刷新数据 。这种方式虽然保证了一致性，但会造成性能瞬时下降 。</p></li></ul><hr><h3 id="补充：原理深度解析-1"><a href="#补充：原理深度解析-1" class="headerlink" title="补充：原理深度解析"></a>补充：原理深度解析</h3><p><strong>为什么随机写会严重拖慢性能？</strong><br>传统的机械硬盘（HDD）在进行随机读写时，需要频繁移动磁头（寻道），延迟极高。即便在 SSD 时代，随机写入也会触发复杂的垃圾回收（GC）和写放大效应 。WAL 将数据修改通过日志转化为<strong>顺序追加 (Sequential Append)</strong>，完美避开了磁盘性能的最弱项，这也是数据库能支撑高并发写操作的关键所在。</p><p>这份 CMU 15-445&#x2F;645 Database Systems (Fall 2024) Lecture #21 <strong>Database Crash Recovery (数据库崩溃恢复)</strong> 的课程笔记整理如下。</p><p>这份笔记在总结课件核心内容的基础上，补充了 <strong>ARIES</strong> 算法背后的设计哲学（如 STEAL&#x2F;NO-FORCE 策略），帮助你从原理层面理解数据库是如何在崩溃后“起死回生”的。</p><hr><h1 id="第二十一讲：Database-Crash-Recovery-数据库崩溃恢复"><a href="#第二十一讲：Database-Crash-Recovery-数据库崩溃恢复" class="headerlink" title="第二十一讲：Database Crash Recovery (数据库崩溃恢复)"></a>第二十一讲：Database Crash Recovery (数据库崩溃恢复)</h1><h2 id="1-核心背景：故障与恢复-Motivation"><a href="#1-核心背景：故障与恢复-Motivation" class="headerlink" title="1. 核心背景：故障与恢复 (Motivation)"></a>1. 核心背景：故障与恢复 (Motivation)</h2><p>DBMS 的恢复系统是为了确保在发生故障（如断电、崩溃）时，依然能维持 ACID 特性，特别是 <strong>Atomicity (原子性)</strong> 和 <strong>Durability (持久性)</strong> 。</p><h3 id="关键前提：STEAL-NO-FORCE-策略"><a href="#关键前提：STEAL-NO-FORCE-策略" class="headerlink" title="关键前提：STEAL + NO-FORCE 策略"></a>关键前提：STEAL + NO-FORCE 策略</h3><p>虽然课件中只简略提到了这几个词 ，但理解它们是理解 ARIES 的基础：</p><ol><li><strong>STEAL (允许偷跑)</strong>：DBMS 允许未提交事务（Uncommitted）修改的脏页被写入磁盘。</li></ol><ul><li><em>后果</em>：如果崩溃，磁盘上可能存有脏数据，恢复时必须 <strong>Undo (撤销)</strong> 这些更改。</li></ul><ol start="2"><li><strong>NO-FORCE (非强制刷盘)</strong>：事务提交时，<strong>不强制</strong>将所有脏页立即刷入磁盘（只刷日志）。</li></ol><ul><li><em>后果</em>：如果崩溃，已提交的数据可能还没写入磁盘，恢复时必须 <strong>Redo (重做)</strong> 这些更改。</li></ul><p><strong>结论</strong>：因为现代数据库为了性能几乎都采用 <strong>STEAL + NO-FORCE</strong>，所以我们需要一个既能 Undo 又能 Redo 的恢复算法——即 <strong>ARIES</strong>。</p><hr><h2 id="2-ARIES-恢复算法概述"><a href="#2-ARIES-恢复算法概述" class="headerlink" title="2. ARIES 恢复算法概述"></a>2. ARIES 恢复算法概述</h2><p><strong>ARIES</strong> (Algorithms for Recovery and Isolation Exploiting Semantics) 是 IBM 在 90 年代研发的恢复算法，现在几乎是所有关系型数据库的标准 。它的三大核心原则是：</p><ol><li><p><strong>Write-Ahead Logging (WAL)</strong>：先写日志，后写数据页。任何修改必须先进入 Stable Storage（磁盘）上的日志文件，才能修改磁盘上的数据文件 。</p></li><li><p><strong>Repeating History (重演历史)</strong>：重启时，重新执行一遍崩溃发生前所有的操作（包括那些后来 abort 的操作），将数据库恢复到崩溃那一瞬间的“准确状态” 。</p></li><li><p><strong>Logging Changes During Undo (Undo 时也要写日志)</strong>：在撤销操作时，也会记录日志（称为 CLR）。这保证了如果恢复过程中再次崩溃，我们不会重复撤销已经撤销过的步骤 。</p></li></ol><hr><h2 id="3-日志与-LSN-Log-Sequence-Numbers"><a href="#3-日志与-LSN-Log-Sequence-Numbers" class="headerlink" title="3. 日志与 LSN (Log Sequence Numbers)"></a>3. 日志与 LSN (Log Sequence Numbers)</h2><p>为了追踪执行顺序，DBMS 使用 <strong>LSN (日志序列号)</strong>，它是全局唯一且单调递增的 。</p><h3 id="关键的-LSN-类型"><a href="#关键的-LSN-类型" class="headerlink" title="关键的 LSN 类型"></a>关键的 LSN 类型</h3><p>理解恢复过程需要分清以下几种 LSN 的位置和作用 ：</p><table><thead><tr><th>LSN 名称</th><th>位置</th><th>定义</th><th>作用</th></tr></thead><tbody><tr><td><strong>flushedLSN</strong></td><td>内存</td><td>已经写入磁盘的最新日志的 LSN</td><td>只有当  时，页面才能刷盘 。</td></tr><tr><td><strong>pageLSN</strong></td><td>数据页 (Page)</td><td>该页面最后一次被更新的 LSN</td><td>即使页面在磁盘上，我们也能知道它最后被谁改过。</td></tr><tr><td><strong>recLSN</strong></td><td>脏页表 (DPT)</td><td>该页面最早变脏的那条日志 LSN</td><td>用于恢复时确定 Redo 从哪里开始。</td></tr><tr><td><strong>lastLSN</strong></td><td>活跃事务表 (ATT)</td><td>事务  产生的最新一条日志 LSN</td><td>用于将同一事务的日志串联起来（链表）。</td></tr><tr><td><strong>MasterRecord</strong></td><td>磁盘</td><td>最近一次 Checkpoint 的 LSN</td><td>恢复的起点 。</td></tr></tbody></table><hr><h2 id="4-正常执行时的关键机制-Normal-Execution"><a href="#4-正常执行时的关键机制-Normal-Execution" class="headerlink" title="4. 正常执行时的关键机制 (Normal Execution)"></a>4. 正常执行时的关键机制 (Normal Execution)</h2><h3 id="事务提交-Commit"><a href="#事务提交-Commit" class="headerlink" title="事务提交 (Commit)"></a>事务提交 (Commit)</h3><ol><li><p>写入 <code>COMMIT</code> 日志记录。</p></li><li><p><strong>强制刷新 (Flush)</strong> 日志到磁盘（直到包含该 <code>COMMIT</code> 记录）。注意：数据页不需要立即刷盘（NO-FORCE）。</p></li><li><p>向用户返回“成功”。</p></li><li><p>稍后写入 <code>TXN-END</code>（用于内部清理）。</p></li></ol><h3 id="事务中止-Abort-与-CLR"><a href="#事务中止-Abort-与-CLR" class="headerlink" title="事务中止 (Abort)与 CLR"></a>事务中止 (Abort)与 CLR</h3><p>当事务回滚时，其实也是一种“修改”（把数据改回旧值）。ARIES 会引入 <strong>CLR (Compensation Log Record，补偿日志记录)</strong> 。</p><ul><li><strong>CLR 的作用</strong>：记录“我做了一个撤销操作”。</li><li><strong>UndoNextLSN</strong>：CLR 中包含一个指针，指向<strong>下一个需要被 Undo 的 LSN</strong>。</li><li><strong>避免死循环</strong>：CLR 本身永远不需要被 Undo。如果在 Undo 过程中崩溃，重启后 DBMS 看到 CLR，会直接跳到 <code>UndoNextLSN</code> 继续撤销更早的操作，而不会重复撤销已经撤销过的步骤 。</li></ul><hr><h2 id="5-检查点-Checkpointing"><a href="#5-检查点-Checkpointing" class="headerlink" title="5. 检查点 (Checkpointing)"></a>5. 检查点 (Checkpointing)</h2><p>为了避免恢复时从头重放所有日志，DBMS 需要定期做 Checkpoint。</p><ul><li><p><strong>Blocking Checkpoint (阻塞式)</strong>：停止所有事务，刷脏页。简单但性能差 。</p></li><li><p><strong>Fuzzy Checkpoint (模糊&#x2F;非阻塞式)</strong>：ARIES 采用的方式 。</p><ul><li><p>允许事务在 Checkpoint 期间继续运行。</p></li><li><p>记录 <code>&lt;CHECKPOINT-BEGIN&gt;</code> 和 <code>&lt;CHECKPOINT-END&gt;</code>。</p></li><li><p>保存当前的 <strong>ATT (活跃事务表)</strong> 和 <strong>DPT (脏页表)</strong> 快照 。</p></li><li><p>这并不保证此时磁盘上的数据页是一致的，但通过日志重放可以修复。</p></li></ul></li></ul><hr><h2 id="6-ARIES-恢复流程-The-3-Phases"><a href="#6-ARIES-恢复流程-The-3-Phases" class="headerlink" title="6. ARIES 恢复流程 (The 3 Phases)"></a>6. ARIES 恢复流程 (The 3 Phases)</h2><p>当数据库崩溃重启后，ARIES 分三个阶段执行恢复 。</p><h3 id="第一阶段：分析-Analysis"><a href="#第一阶段：分析-Analysis" class="headerlink" title="第一阶段：分析 (Analysis)"></a>第一阶段：分析 (Analysis)</h3><p><strong>目标</strong>：搞清楚崩溃那一刻，谁还在运行（需要 Undo），哪些页可能是脏的（需要 Redo）。</p><ol><li><p>从 <code>MasterRecord</code> 指向的 Checkpoint 开始扫描日志。</p></li><li><p><strong>重建 ATT (活跃事务表)</strong>：遇到 <code>BEGIN</code> 加入 ATT，遇到 <code>END</code> 移除。最终留下的就是崩溃时的“失败者 (Losers)” 。</p></li><li><p><strong>重建 DPT (脏页表)</strong>：遇到 <code>UPDATE</code> 且页面不在 DPT 中，则加入并记录 <code>recLSN</code> 。</p></li></ol><h3 id="第二阶段：重做-Redo-——-“Repeating-History”"><a href="#第二阶段：重做-Redo-——-“Repeating-History”" class="headerlink" title="第二阶段：重做 (Redo) —— “Repeating History”"></a>第二阶段：重做 (Redo) —— “Repeating History”</h3><p><strong>目标</strong>：将数据库状态<strong>完全</strong>恢复到崩溃发生的那一秒（包括已提交和未提交的修改）。</p><ol><li><p><strong>起点</strong>：从 DPT 中最小的 <code>recLSN</code> 开始读取日志 。</p></li><li><p><strong>操作</strong>：对每一条更新日志，判断是否需要重做。</p></li><li><p><strong>不需要重做的情况</strong> ：</p><ul><li>页面不在 DPT 中（说明早已刷盘）。</li><li>页面在 DPT 中，但日志 LSN &lt; <code>recLSN</code>（说明该更新在变脏之前）。</li><li><strong>最关键检查</strong>：从磁盘读取页面，如果磁盘上的 <code>pageLSN</code>  日志 LSN（说明磁盘上的页面已经是最新的了）。</li></ul></li><li><p><strong>执行</strong>：如果不满足上述条件，重新执行修改，并将页面的 <code>pageLSN</code> 更新为日志 LSN 。</p></li></ol><h3 id="第三阶段：撤销-Undo"><a href="#第三阶段：撤销-Undo" class="headerlink" title="第三阶段：撤销 (Undo)"></a>第三阶段：撤销 (Undo)</h3><p><strong>目标</strong>：回滚所有在崩溃时未提交的事务（即 ATT 中的 Losers）。</p><ol><li><p><strong>起点</strong>：处理所有 ATT 中状态为 Undo 的事务。</p></li><li><p><strong>顺序</strong>：按照 LSN <strong>从大到小 (Reverse Order)</strong> 回滚。</p></li><li><p><strong>执行</strong>：</p><ul><li><p>找到事务的最后一条记录 (<code>lastLSN</code>)。</p></li><li><p>执行逆操作。</p></li><li><p>为每个逆操作写入 <strong>CLR</strong> 日志 。</p></li><li><p>如果遇到 CLR，直接跳到 <code>undoNextLSN</code>（跳过已经撤销过的部分）。</p></li></ul></li><li><p><strong>结束</strong>：当所有 Loser 事务完全回滚，写入 <code>TXN-END</code> 。</p></li></ol><hr><h3 id="总结：为什么-ARIES-如此强大？"><a href="#总结：为什么-ARIES-如此强大？" class="headerlink" title="总结：为什么 ARIES 如此强大？"></a>总结：为什么 ARIES 如此强大？</h3><ol><li><strong>Redo 一切</strong>：它不猜测谁提交了谁没提交，先无脑重做所有历史，把状态恢复到崩溃点。这大大简化了逻辑。</li><li><strong>Undo Losers</strong>：在状态一致后，再精准地撤销未提交的事务。</li><li><strong>CLR 机制</strong>：确保了<strong>恢复过程本身也是可恢复的</strong>。如果恢复到一半又崩了，重启后不会把数据改乱。</li></ol><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>如果系统在 <strong>Redo 阶段</strong> 崩溃了怎么办？</p><ul><li><strong>答案</strong>：没关系。重启后再次运行 Redo。因为 Redo 操作是<strong>幂等 (Idempotent)</strong> 的（通过检查 <code>pageLSN</code>，如果 <code>pageLSN</code> 已经变大，就不会重复应用同一个 LSN 的修改）。</li></ul><p>这份笔记基于 CMU 15-445&#x2F;645 课程的第 22 讲（Lecture #22: Introduction to Distributed Databases），系统地总结了分布式数据库的核心架构、设计挑战及数据分区策略。</p><hr><h1 id="第二十二讲：分布式数据库导论"><a href="#第二十二讲：分布式数据库导论" class="headerlink" title="第二十二讲：分布式数据库导论"></a>第二十二讲：分布式数据库导论</h1><h2 id="1-分布式数据库概述-Overview"><a href="#1-分布式数据库概述-Overview" class="headerlink" title="1. 分布式数据库概述 (Overview)"></a>1. 分布式数据库概述 (Overview)</h2><p>分布式 DBMS 将单个逻辑数据库拆分并存储在多个物理资源（节点）上 。对于应用程序而言，这种拆分通常是透明的，即应用无需关心数据具体存放在哪里 。</p><p><strong>设计核心目标：</strong> <strong>容错性 (Fault Tolerance)</strong>。确保单个节点的故障不会导致整个系统的瘫痪 。</p><h3 id="分布式-Distributed-vs-并行-Parallel"><a href="#分布式-Distributed-vs-并行-Parallel" class="headerlink" title="分布式 (Distributed) vs. 并行 (Parallel)"></a>分布式 (Distributed) vs. 并行 (Parallel)</h3><p>虽然两者都利用多资源，但环境假设不同：</p><ul><li><p><strong>并行数据库 (Parallel DB)：</strong> 节点间物理距离近，通过高速 LAN 连接，通信成本低且极其可靠 。设计时通常不考虑丢包或节点崩溃 。</p></li><li><p><strong>分布式数据库 (Distributed DB)：</strong> 节点可能跨地域分布，通过公共网络连接，通信慢且不可靠 。通信开销和节点故障是设计中必须处理的一等公民 。</p></li></ul><hr><h2 id="2-系统架构-System-Architectures"><a href="#2-系统架构-System-Architectures" class="headerlink" title="2. 系统架构 (System Architectures)"></a>2. 系统架构 (System Architectures)</h2><p>架构决定了 CPU 可以直接访问哪些共享资源，直接影响协调效率和数据存储方式 。</p><table><thead><tr><th>架构类型</th><th>共享资源</th><th>特点与原理</th></tr></thead><tbody><tr><td><strong>Shared Everything</strong></td><td>CPU, 内存, 磁盘</td><td>单机架构，所有资源由本地控制 。</td></tr><tr><td><strong>Shared Memory</strong></td><td>内存, 磁盘</td><td>多个 CPU 通过高速互连共享内存空间和磁盘 。在操作系统层面实现，实践中较少由 DBMS 直接采用 。</td></tr><tr><td><strong>Shared Disk</strong></td><td>磁盘</td><td>所有 CPU 共享一个逻辑磁盘，但拥有私有内存 。<strong>云原生数据库的主流</strong>，允许计算层与存储层独立扩展 。</td></tr><tr><td><strong>Shared Nothing</strong></td><td>无共享硬件</td><td>每个节点拥有独立的 CPU、内存和磁盘 。节点间仅通过网络通信 。</td></tr></tbody></table><h3 id="原理补充："><a href="#原理补充：" class="headerlink" title="原理补充："></a>原理补充：</h3><ul><li><p><strong>Shared Nothing 的难点：</strong> 增加容量时必须物理迁移数据，且跨节点一致性协调非常困难 。</p></li><li><p><strong>Shared Disk 的优势：</strong> 节点崩溃不影响数据库状态（状态存储在共享磁盘中），且节点可以缓存数据作为本地状态 。</p></li></ul><hr><h2 id="3-数据库分区方案-Partitioning-Schemes"><a href="#3-数据库分区方案-Partitioning-Schemes" class="headerlink" title="3. 数据库分区方案 (Partitioning Schemes)"></a>3. 数据库分区方案 (Partitioning Schemes)</h2><p>分区（在 NoSQL 中常称为 Sharding）旨在将数据分布到不同节点，以提高并行度 。</p><h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><ol><li><p><strong>幼稚分区 (Naive Partitioning)：</strong> 每个节点存储一张完整的表 。虽然简单，但难以扩展，且 JOIN 操作或访问不均时性能极差 。</p></li><li><p><strong>垂直分区 (Vertical Partitioning)：</strong> 将表的属性（列）拆分到不同分区 。</p></li><li><p><strong>水平分区 (Horizontal Partitioning)：</strong> 最常用的方式，将元组（行）拆分为不相交的子集 。通常选择一个列作为 <strong>分区键 (Partitioning Key)</strong> 。</p></li></ol><h3 id="一致性哈希-Consistent-Hashing"><a href="#一致性哈希-Consistent-Hashing" class="headerlink" title="一致性哈希 (Consistent Hashing)"></a>一致性哈希 (Consistent Hashing)</h3><p>传统的哈希分区（如 hash(key) \pmod n）在增加或删除节点时，会导致绝大部分数据需要重新分布 。一致性哈希解决了这个问题：</p><ul><li><p><strong>原理：</strong> 将所有节点和分区键映射到一个逻辑环上 。键由顺时针方向最近的节点负责 。</p></li><li><p><strong>优势：</strong> 当节点变动时，仅影响环上相邻的节点，只有 1&#x2F;n 的键需要迁移 。</p></li></ul><hr><h2 id="4-分布式并发控制-Distributed-Concurrency-Control"><a href="#4-分布式并发控制-Distributed-Concurrency-Control" class="headerlink" title="4. 分布式并发控制 (Distributed Concurrency Control)"></a>4. 分布式并发控制 (Distributed Concurrency Control)</h2><p>分布式事务涉及多个分区，需要昂贵的协调成本 。</p><ul><li><p><strong>集中式协调器 (Centralized Coordinator)：</strong> 一个全局的“交通警察”负责分配锁和管理事务 。</p></li><li><p><strong>优点：</strong> 易于实现分布式 2PL，拥有全局视图，能快速处理死锁 。</p></li><li><p><strong>缺点：</strong> 在高并发下容易成为性能瓶颈 。</p></li><li><p><strong>分散式协调器 (Decentralized Coordinator)：</strong> 节点间自组织，客户端直接与某个“主分区”通信，由该分区负责与其他节点协调 。</p></li></ul><hr><h2 id="5-联邦数据库-Federated-Databases"><a href="#5-联邦数据库-Federated-Databases" class="headerlink" title="5. 联邦数据库 (Federated Databases)"></a>5. 联邦数据库 (Federated Databases)</h2><p>这是一种将多个互不相同的 DBMS 逻辑连接成一个单一系统的架构 。</p><ul><li><p><strong>实现：</strong> 通过中间件（Middleware）和连接器（Connector）将查询转换为各个后端数据库可读的格式 。</p></li><li><p><strong>挑战：</strong> 由于不同系统的查询语言、数据模型和限制各不相同，很难进行统一的查询优化 。</p></li></ul><hr><h3 id="原理深度总结：透明性-Transparency"><a href="#原理深度总结：透明性-Transparency" class="headerlink" title="原理深度总结：透明性 (Transparency)"></a>原理深度总结：透明性 (Transparency)</h3><p>分布式系统的终极目标是<strong>数据透明性</strong> 。即用户发送一条 SQL 查询，他不应该知道这条查询是在单节点执行，还是被切成了 100 个碎片在不同机器上跑，更不应该知道数据是按哈希分布还是按范围分布的 。</p><p>这份 CMU 15-445&#x2F;645 Database Systems (Fall 2024) Lecture #23 <strong>Distributed OLTP Databases (分布式 OLTP 数据库)</strong> 的课程笔记整理如下。</p><p>这份笔记不仅总结了课件的核心内容，还补充了分布式系统中关键的设计权衡（Trade-offs）和原理深度解析，帮助你理解如何构建一个既可靠又高效的分布式数据库。</p><hr><h1 id="第二十三讲：Distributed-OLTP-Databases-分布式-OLTP-数据库"><a href="#第二十三讲：Distributed-OLTP-Databases-分布式-OLTP-数据库" class="headerlink" title="第二十三讲：Distributed OLTP Databases (分布式 OLTP 数据库)"></a>第二十三讲：Distributed OLTP Databases (分布式 OLTP 数据库)</h1><h2 id="1-背景：OLTP-与-OLAP-的区别"><a href="#1-背景：OLTP-与-OLAP-的区别" class="headerlink" title="1. 背景：OLTP 与 OLAP 的区别"></a>1. 背景：OLTP 与 OLAP 的区别</h2><p>在讨论分布式架构之前，首先要明确我们针对的工作负载类型，本节课关注的是 <strong>OLTP</strong>。</p><ul><li><p><strong>OLTP (On-line Transaction Processing)</strong>：</p><ul><li><p><strong>特点</strong>：短生命周期的读写事务，操作重复性高，占用资源少（Small footprint）。</p></li><li><p><strong>目标</strong>：高吞吐量、低延迟。</p></li></ul></li><li><p><strong>OLAP (On-line Analytical Processing)</strong>：</p><ul><li><p><strong>特点</strong>：长运行时间的只读查询，涉及复杂的连接（Joins），通常是探索性的分析查询 。</p></li><li><p><strong>目标</strong>：扫描大量数据并聚合结果。</p></li></ul></li></ul><hr><h2 id="2-分布式架构基础-System-Architecture"><a href="#2-分布式架构基础-System-Architecture" class="headerlink" title="2. 分布式架构基础 (System Architecture)"></a>2. 分布式架构基础 (System Architecture)</h2><p>在分布式 OLTP 系统中，数据被分片（Partition）存储在多个节点上。</p><h3 id="去中心化协调-Decentralized-Coordinator"><a href="#去中心化协调-Decentralized-Coordinator" class="headerlink" title="去中心化协调 (Decentralized Coordinator)"></a>去中心化协调 (Decentralized Coordinator)</h3><ul><li><p><strong>架构</strong>：应用服务器直接与某个节点通信。通常会选出一个分区作为<strong>主节点 (Primary Node)</strong> 。</p></li><li><p><strong>流程</strong>：</p><ol><li>事务的 <code>BEGIN</code> 请求发送给主节点。</li><li>查询被直接路由到相关节点。</li><li><code>COMMIT</code> 请求发送给主节点，由主节点负责判断是否所有参与节点都同意提交 。</li></ol></li><li><p><strong>挑战</strong>：需要确保即使节点故障或消息延迟，所有节点对事务的结果（提交或中止）也能达成一致 。</p></li></ul><hr><h2 id="3-复制-Replication"><a href="#3-复制-Replication" class="headerlink" title="3. 复制 (Replication)"></a>3. 复制 (Replication)</h2><p>为了提高可用性（Availability），DBMS 将数据复制到冗余节点上。这里涉及四个关键的设计决策。</p><h3 id="1-副本配置-Replica-Configuration"><a href="#1-副本配置-Replica-Configuration" class="headerlink" title="(1) 副本配置 (Replica Configuration)"></a>(1) 副本配置 (Replica Configuration)</h3><p>决定了写操作可以发生在哪些节点上。</p><ul><li><p><strong>主从复制 (Primary-Replica)</strong>：</p><ul><li><p><strong>原理</strong>：所有的<strong>更新 (Updates)</strong> 必须发往指定的 Primary 节点。Primary 负责将更新传播给 Replicas 。</p></li><li><p><strong>读操作</strong>：可以读 Replica（如果允许读旧数据），也可以读 Primary。</p></li><li><p><strong>故障</strong>：Primary 挂了需要重新选举 。</p></li><li><p><strong>优点</strong>：没有写冲突，并发控制简单。</p></li></ul></li><li><p><strong>多主复制 (Multi-Primary)</strong>：</p><ul><li><p><strong>原理</strong>：事务可以更新<strong>任意</strong>副本。副本之间必须通过原子提交协议同步 。</p></li><li><p><strong>缺点</strong>：写冲突频繁，需要复杂的同步机制，性能通常较差。</p></li></ul></li></ul><h3 id="2-传播方案-Propagation-Scheme"><a href="#2-传播方案-Propagation-Scheme" class="headerlink" title="(2) 传播方案 (Propagation Scheme)"></a>(2) 传播方案 (Propagation Scheme)</h3><p>决定了客户端何时收到“写入成功”的确认。</p><ul><li><p><strong>同步 (Synchronous &#x2F; Strong Consistency)</strong>：</p><ul><li><p>Primary 发送更新给 Replicas，<strong>等待</strong>它们确认已记录日志后，才向客户端返回成功 。</p></li><li><p><strong>优点</strong>：强一致性，不丢数据 。</p></li><li><p><strong>缺点</strong>：慢，受最慢节点的拖累。</p></li></ul></li><li><p><strong>异步 (Asynchronous &#x2F; Eventual Consistency)</strong>：</p><ul><li><p>Primary 处理完就立即向客户端返回成功，<strong>不等待</strong> Replicas 确认 。</p></li><li><p><strong>优点</strong>：快。</p></li><li><p><strong>缺点</strong>：可能丢数据（如果 Primary 在同步前挂掉），可能读到旧数据（Stale reads）。常见于 NoSQL 系统。</p></li></ul></li></ul><h3 id="3-传播时机-Propagation-Timing"><a href="#3-传播时机-Propagation-Timing" class="headerlink" title="(3) 传播时机 (Propagation Timing)"></a>(3) 传播时机 (Propagation Timing)</h3><ul><li><p><strong>Continuous (连续)</strong>：生成日志时立即发送。大多数系统采用此法 。</p></li><li><p><strong>On Commit (提交时)</strong>：事务提交时一次性发送所有日志。避免了为中止的事务发送日志，但假设事务日志能塞进内存 。</p></li></ul><h3 id="4-更新方式-Update-Method"><a href="#4-更新方式-Update-Method" class="headerlink" title="(4) 更新方式 (Update Method)"></a>(4) 更新方式 (Update Method)</h3><ul><li><p><strong>Active-Active</strong>：SQL 语句在每个副本上都执行一遍。<strong>难点</strong>：必须保证所有节点执行顺序完全一致（非确定性函数如 <code>RAND()</code> 会出问题）。</p></li><li><p><strong>Active-Passive</strong>：在主节点执行，传输<strong>物理字节 (Bytes)</strong> 或逻辑结果给副本。这是主流做法 。</p></li></ul><h3 id="K-Safety"><a href="#K-Safety" class="headerlink" title="K-Safety"></a>K-Safety</h3><ul><li>衡量容错能力的指标。 代表必须随时可用的副本数量。如果可用副本数 ，系统必须停止服务 。</li></ul><hr><h2 id="4-原子提交协议-Atomic-Commit-Protocols"><a href="#4-原子提交协议-Atomic-Commit-Protocols" class="headerlink" title="4. 原子提交协议 (Atomic Commit Protocols)"></a>4. 原子提交协议 (Atomic Commit Protocols)</h2><p>当一个事务跨越多个节点时，必须保证<strong>原子性</strong>：要么所有节点都提交，要么所有节点都中止。</p><p>我们需要满足三个属性：</p><ol><li><p><strong>稳定性 (Stability)</strong>：一旦决定了结果（提交&#x2F;中止），不可更改 。</p></li><li><p><strong>一致性 (Consistency)</strong>：所有节点最终状态一致 。</p></li><li><p><strong>活性 (Liveness)</strong>：协议最终能完成，不会无限阻塞 。</p></li></ol><h3 id="1-两阶段提交-Two-Phase-Commit-2PC"><a href="#1-两阶段提交-Two-Phase-Commit-2PC" class="headerlink" title="(1) 两阶段提交 (Two-Phase Commit, 2PC)"></a>(1) 两阶段提交 (Two-Phase Commit, 2PC)</h3><p>这是最经典的协议（1970s），由协调者 (Coordinator) 和参与者 (Participants) 组成。</p><ul><li><p><strong>Phase 1: Prepare (准备阶段)</strong></p><ul><li>协调者向所有参与者发送 <code>Prepare</code> 消息（包含事务内容）。</li><li>参与者执行验证，如果可以提交，写入日志并回复 <code>OK</code>；否则回复 <code>Abort</code> 。</li></ul></li><li><p><strong>Phase 2: Commit (提交阶段)</strong></p><ul><li>如果<strong>所有</strong>参与者都回复 <code>OK</code>，协调者发送 <code>Commit</code> 消息。</li><li>如果有<strong>任意</strong>一个回复 <code>Abort</code>，协调者发送 <code>Abort</code> 消息 。</li></ul></li><li><p><strong>核心问题</strong>：<strong>阻塞 (Blocking)</strong>。如果协调者在发送 Prepare 后崩溃，参与者不知道该怎么办，必须一直持有锁并阻塞等待，直到协调者恢复 。</p></li><li><p><strong>优化</strong>：</p><ul><li><p><em>Early Prepare Voting</em>：最后一个查询顺便带上投票 。</p></li><li><p><em>Early Acknowledgement</em>：协调者确认全票通过后，在 Phase 2 完成前就告知客户端成功 。</p></li></ul></li></ul><h3 id="2-Paxos-与-Raft"><a href="#2-Paxos-与-Raft" class="headerlink" title="(2) Paxos (与 Raft)"></a>(2) Paxos (与 Raft)</h3><p>现代系统更倾向于使用 Paxos 或 Raft，因为它们容错性更强。</p><ul><li><p><strong>原理</strong>：基于<strong>共识 (Consensus)</strong>。2PC 要求 100% 同意，而 Paxos 只需要 <strong>多数派 (Majority)</strong> 同意。</p></li><li><p><strong>容错</strong>：只要  个节点中有  个活着，系统就能继续运行（非阻塞）。</p></li><li><p><strong>流程</strong>：Proposer 提议一个值（Commit&#x2F;Abort），Acceptors 投票。一旦多数派接受，结果就确定了 。</p></li><li><p><strong>Multi-Paxos</strong>：选出一个 Leader 长期负责提议，跳过第一阶段，提高性能 。</p></li></ul><p><strong>对比总结</strong>：</p><ul><li><p>如果节点在同一数据中心且很少故障，<strong>2PC</strong> 通常更快（消息往返少）。</p></li><li><p>如果需要跨数据中心或高容错，<strong>Paxos&#x2F;Raft</strong> 是必须的。</p></li></ul><hr><h2 id="5-CAP-定理与-PACELC"><a href="#5-CAP-定理与-PACELC" class="headerlink" title="5. CAP 定理与 PACELC"></a>5. CAP 定理与 PACELC</h2><h3 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h3><p>在一个分布式系统中，无法同时满足以下三点，只能三选二 ：</p><ol><li><p><strong>C (Consistency)</strong>：一致性（线性一致性）。写操作完成后，随后的读操作必须能读到该值 。</p></li><li><p><strong>A (Availability)</strong>：可用性。所有存活节点都能处理请求 。</p></li><li><p><strong>P (Partition Tolerance)</strong>：分区容错性。网络断开时系统仍能工作 。</p></li></ol><ul><li><p><strong>现实选择</strong>：由于网络分区（P）在分布式系统中是不可避免的（网线总会被挖断），所以实际上只能在 <strong>CP</strong>（强一致，分区时不可用）和 <strong>AP</strong>（高可用，分区时数据不一致）之间做选择 。</p></li><li><p><em>传统 DBMS &#x2F; NewSQL</em>：倾向于 CP。</p></li><li><p><em>NoSQL</em>：倾向于 AP。</p></li></ul><h3 id="PACELC-定理"><a href="#PACELC-定理" class="headerlink" title="PACELC 定理"></a>PACELC 定理</h3><p>CAP 的扩展版本，考虑了系统正常运行（没有分区）时的权衡 。</p><ul><li><strong>P (Partition)</strong>：如果有分区，选择 <strong>A</strong> 或 <strong>C</strong>。</li><li><strong>E (Else)</strong>：如果没有分区（正常情况），选择 <strong>L (Latency)</strong> 或 <strong>C (Consistency)</strong>。</li><li>比如：如果你想要极低的延迟（L），就必须放弃强一致性（C），改用异步复制。</li></ul><p>这份笔记基于 CMU 15-445&#x2F;645 课程第 23 讲（Lecture #23: Distributed OLAP Databases），系统总结了分布式分析型数据库（OLAP）的设计架构、执行模型及现代云原生趋势。</p><hr><h1 id="第二十四讲：分布式分析型数据库-Distributed-OLAP"><a href="#第二十四讲：分布式分析型数据库-Distributed-OLAP" class="headerlink" title="第二十四讲：分布式分析型数据库 (Distributed OLAP)"></a>第二十四讲：分布式分析型数据库 (Distributed OLAP)</h1><h2 id="1-决策支持系统-Decision-Support-Systems-DSS"><a href="#1-决策支持系统-Decision-Support-Systems-DSS" class="headerlink" title="1. 决策支持系统 (Decision Support Systems, DSS)"></a>1. 决策支持系统 (Decision Support Systems, DSS)</h2><p>OLAP 数据库主要用于执行只读的复杂查询，以支持组织的决策分析 。</p><h3 id="数据摄取：ETL-vs-ELT"><a href="#数据摄取：ETL-vs-ELT" class="headerlink" title="数据摄取：ETL vs. ELT"></a>数据摄取：ETL vs. ELT</h3><ul><li><p><strong>ETL (Extract, Transform, Load)</strong>：在将数据存入数据仓库前，先在外部完成清洗转换 。</p></li><li><p><strong>ELT (Extract, Load, Transform)</strong>：现代趋势，先将原始数据加载入库，利用 OLAP 数据库自身的并行计算能力完成转换 。</p></li></ul><h3 id="模式建模-Schema-Modeling"><a href="#模式建模-Schema-Modeling" class="headerlink" title="模式建模 (Schema Modeling)"></a>模式建模 (Schema Modeling)</h3><ul><li><p><strong>星型模式 (Star Schema)</strong> ：</p><ul><li><p>由<strong>事实表 (Fact Table)</strong> 和一层<strong>维度表 (Dimension Tables)</strong> 组成 。</p></li><li><p><strong>特点</strong>：冗余度高（非规范化），但 <strong>JOIN 次数少，查询速度最快</strong> 。</p></li></ul></li><li><p><strong>雪花模式 (Snowflake Schema)</strong> ：</p><ul><li><p>维度表可以进一步分解，支持多层维度 。</p></li><li><p><strong>特点</strong>：存储更节省（规范化），但由于需要 <strong>更多的 JOIN 操作，查询性能相对较低</strong> 。</p></li></ul></li></ul><hr><h2 id="2-分布式执行模型"><a href="#2-分布式执行模型" class="headerlink" title="2. 分布式执行模型"></a>2. 分布式执行模型</h2><h3 id="Pushing-vs-Pulling"><a href="#Pushing-vs-Pulling" class="headerlink" title="Pushing vs. Pulling"></a>Pushing vs. Pulling</h3><ul><li><p><strong>Pushing (Query to Data)</strong>：将查询逻辑（片段）发送到存储数据的节点上执行，尽可能在本地完成过滤和处理 。</p><ul><li><strong>适用场景</strong>：Shared-nothing 系统，旨在减少昂贵的网络传输 。</li></ul></li><li><p><strong>Pulling (Data to Query)</strong>：将数据从存储节点拉取到执行查询的节点上处理 。</p><ul><li><strong>适用场景</strong>：Shared-disk 系统 。</li></ul></li></ul><h3 id="容错性-Fault-Tolerance"><a href="#容错性-Fault-Tolerance" class="headerlink" title="容错性 (Fault Tolerance)"></a>容错性 (Fault Tolerance)</h3><ul><li><p><strong>现状</strong>：大多数分布式 OLAP 假设节点在查询期间不会失效 。</p></li><li><p><strong>代价</strong>：若某个节点在执行长达数天的查询时崩溃，通常会导致整个查询失败并必须<strong>从头开始重新执行</strong> 。</p></li></ul><hr><h2 id="3-分布式连接算法-Distributed-Joins"><a href="#3-分布式连接算法-Distributed-Joins" class="headerlink" title="3. 分布式连接算法 (Distributed Joins)"></a>3. 分布式连接算法 (Distributed Joins)</h2><p>分布式环境下的 JOIN 是最耗时的操作，其效率取决于数据的分区方式 。</p><table><thead><tr><th>场景</th><th>描述</th><th>策略</th></tr></thead><tbody><tr><td><strong>场景 1</strong></td><td>一个表全量副本在每节点，另一表分区</td><td>本地并行连接</td></tr><tr><td><strong>场景 2</strong></td><td>两个表都按 JOIN 属性进行分区且 ID 匹配</td><td>本地并行连接</td></tr><tr><td><strong>场景 3</strong></td><td>分区键不同，但其中一表很小</td><td><br><strong>广播连接 (Broadcast Join)</strong>：将小表发送给所有节点</td></tr><tr><td><strong>场景 4</strong></td><td>最坏情况：两表分区键均非 JOIN 键</td><td><br><strong>洗牌连接 (Shuffle Join)</strong>：全量重新分配数据</td></tr></tbody></table><hr><h2 id="4-云系统与无服务器架构-Cloud-Serverless"><a href="#4-云系统与无服务器架构-Cloud-Serverless" class="headerlink" title="4. 云系统与无服务器架构 (Cloud &amp; Serverless)"></a>4. 云系统与无服务器架构 (Cloud &amp; Serverless)</h2><h3 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h3><ul><li><p><strong>托管型 (Managed)</strong>：传统 DBMS 搬上云，不感知云环境 。</p></li><li><p><strong>云原生 (Cloud-Native)</strong>：基于 Shared-disk 架构，计算与存储解耦（如 Snowflake, BigQuery） 。</p></li><li><p><strong>无服务器 (Serverless)</strong> ：</p><ul><li><p>当数据库空闲时，驱逐租户并对 Buffer Pool 进行检查点（Checkpoint）存盘，停止计费 。</p></li><li><p>用户仅需为活动查询时间和非活动存储付费 。</p></li></ul></li></ul><hr><h2 id="5-OLAP-商品化-Commoditization"><a href="#5-OLAP-商品化-Commoditization" class="headerlink" title="5. OLAP 商品化 (Commoditization)"></a>5. OLAP 商品化 (Commoditization)</h2><p>现代 OLAP 倾向于将功能解耦为独立的开源组件，极大地提高了系统间的互操作性 ：</p><ul><li><p><strong>查询优化器</strong>：如 Apache Calcite 。</p></li><li><p><strong>数据文件格式</strong>：开源二进制格式（如 <strong>Apache Parquet</strong>, Apache Arrow）取代私有格式 。</p></li><li><p><strong>执行引擎</strong>：如 Velox, DataFusion 。</p></li></ul><hr><h3 id="原理深度总结：为什么-OLAP-偏爱列存？"><a href="#原理深度总结：为什么-OLAP-偏爱列存？" class="headerlink" title="原理深度总结：为什么 OLAP 偏爱列存？"></a>原理深度总结：为什么 OLAP 偏爱列存？</h3><p>虽然笔记中未详细展开列存细节，但列存（Columnar Storage）是 OLAP 性能的核心。</p><ol><li><strong>极高的压缩比</strong>：同一列数据类型相同，压缩效率极高。</li><li><strong>I&#x2F;O 裁剪</strong>：只需读取查询涉及的列，无需扫描整行，极大减少磁盘读取量。</li><li><strong>向量化执行</strong>：适配现代 CPU 的 SIMD 指令，批量处理数据。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CMU15-445</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMU15-445(Bustub):project3实现笔记</title>
    <link href="/2025/12/04/CMU15-445-Bustub-project3%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/12/04/CMU15-445-Bustub-project3%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h2><hr><h3 id="迭代器数据库查询模型"><a href="#迭代器数据库查询模型" class="headerlink" title="迭代器数据库查询模型"></a>迭代器数据库查询模型</h3><p>Volcano 模型（也称为 Iterator Model 或 Pipeline Model）是数据库查询处理中最经典、最通用的执行模型。它由 Goetz Graefe 在 1990 年代提出，几乎被用于所有传统的行式数据库系统（如 PostgreSQL, SQLite, MySQL 等）。</p><p>简单来说，它的核心原理是将所有的查询操作（如扫描、过滤、连接、排序）都抽象为迭代器（Iterator），并通过<strong>拉取 Pull-based</strong>的方式逐行处理数据。</p><h4 id="核心抽象：标准接口"><a href="#核心抽象：标准接口" class="headerlink" title="核心抽象：标准接口"></a>核心抽象：标准接口</h4><p>在 Volcano 模型中，查询计划树（Query Plan Tree）中的每一个节点（Operator）都被看作一个迭代器。无论这个节点是复杂的 Hash Join 还是简单的 Sequential Scan，它们都必须实现一组统一的接口。</p><p>通常包含以下三个核心方法：</p><ol><li><p>Open(): 初始化操作。</p><ul><li><p>设置内部状态，为子节点调用 Open()。</p></li><li><p>例如：Sequential Scan 会打开文件并指向第一条记录；Sort 可能会在此时读取所有子节点数据并进行排序。</p></li></ul></li><li><p>Next(): 核心执行逻辑。</p><ul><li><p>这是驱动数据流动的关键。当父节点调用子节点的 Next() 时，子节点返回**一个元组（Tuple）**或者一个“结束标记”（EOF&#x2F;Null）。</p></li><li><p>关键点：这是一个Tuple-at-a-time（一次处理一行）的模型。</p></li></ul></li><li><p>Close(): 清理操作。</p><ul><li>释放资源，关闭文件句柄，通知子节点关闭。</li></ul></li></ol><h4 id="工作流：自顶向下的“拉取”模式"><a href="#工作流：自顶向下的“拉取”模式" class="headerlink" title="工作流：自顶向下的“拉取”模式"></a>工作流：自顶向下的“拉取”模式</h4><p>Volcano 模型的数据流向和控制流向是相反的：</p><ul><li><p>控制流（Control Flow）：从根节点（Root）向下传递，父节点主动调用子节点的 Next()。</p></li><li><p>数据流（Data Flow）：数据从叶子节点（Leaf）被“拉”向根节点。</p></li></ul><p><strong>执行过程示例</strong><br>假设有一个查询：<code>SELECT * FROM Users WHERE age &gt; 20</code>。 执行计划树通常是：<code>Filter (age &gt; 20) -&gt; SeqScan (Users table)</code>。</p><ol><li><p>用户调用根节点 Filter 的 Next()。</p></li><li><p>Filter 自身没有数据，它调用子节点 SeqScan 的 Next()。</p></li><li><p>SeqScan 读取磁盘上的第一行数据（例如 age&#x3D;18），并将其返回给 Filter。</p></li><li><p>Filter 拿到数据进行检查：</p><ul><li><p>如果 age &gt; 20 为真：Filter 将该行返回给用户。</p></li><li><p>如果 age &gt; 20 为假（如本例）：Filter 丢弃该行，再次调用 SeqScan 的 Next()，直到找到符合条件的行或收到 EOF。</p></li></ul></li></ol><hr><h3 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h3><h4 id="核心思想：读写不冲突"><a href="#核心思想：读写不冲突" class="headerlink" title="核心思想：读写不冲突"></a>核心思想：读写不冲突</h4><p>MVCC 的核心逻辑是：“即便有人在改数据，我依然可以读到该数据在该操作之前的旧版本。”</p><ul><li>读不阻塞写</li><li>写不阻塞读</li></ul><p>这就好比你在编辑一份在线文档，当你还没点击“保存”时，其他人看到的依然是修改前的版本，而互不干扰。</p><h4 id="MVCC实现"><a href="#MVCC实现" class="headerlink" title="MVCC实现"></a>MVCC实现</h4><p>MVCC 的实现依赖于三个关键组件：隐藏列、回滚日志（Undo Log） 和 一致性视图（Read View）。</p><ol><li><p>隐藏列</p><p>InnoDB 会在每一行数据的后面悄悄加上几个隐藏字段：</p><ul><li><p>DB_TRX_ID：记录最后一次修改该行数据的事务 ID。</p></li><li><p>DB_ROLL_PTR：回滚指针，指向该行数据上一个版本的 Undo Log 记录。</p></li></ul></li><li><p>回滚日志（Undo Log）<br>每当一条记录被修改时，InnoDB 不会直接覆盖旧数据，而是把旧数据写入 Undo Log 中。通过 DB_ROLL_PTR，这些旧版本的数据会像链表一样串起来，形成一个版本链。</p></li><li><p>一致性视图<br>当一个事务发起查询时，MVCC 会生成一个 Read View。它像一张“快照”，记录了当前系统中哪些事务是活跃的（还没提交的）。</p><p>根据 Read View 的规则，系统会判断版本链中哪个版本对当前事务是可见的：</p><ul><li><p>如果版本 ID 在 Read View 创建前已提交 -&gt; 可见。</p></li><li><p>如果版本 ID 在 Read View 创建后才开启 -&gt; 不可见。</p></li><li><p>如果版本 ID 属于当前正在运行且未提交的事务 -&gt; 不可见。</p></li></ul></li></ol><hr><h2 id="部件实现：访问方法执行器"><a href="#部件实现：访问方法执行器" class="headerlink" title="部件实现：访问方法执行器"></a>部件实现：访问方法执行器</h2><p>在本项目中，将实现允许 BusTub 执行查询的组件。将创建执行 SQL 查询的操作符执行器，并实现优化规则以转换查询计划。</p><hr><h3 id="SeqScanExecutor类"><a href="#SeqScanExecutor类" class="headerlink" title="SeqScanExecutor类"></a>SeqScanExecutor类</h3><p><strong>功能：</strong> SeqScanExecutor 遍历一个表，并逐个返回其元组。</p><p><strong>类函数：</strong></p><ol><li><p>Init()：初始化阶段：</p><ul><li>这是 Volcano 模型中的 Open() 操作。</li><li>逻辑：准备工作。它不读取数据，<code>只是把“迭代器指针”指向表的开头</code>。</li></ul></li><li><p>Next()：执行阶段：</p><ul><li>这是 Volcano 模型中的 Next() 操作。父节点会不断调用这个函数来“拉取”数据。</li><li>逻辑：<code>获取当前迭代器指向的数据</code>-&gt;<code>代器前移，为下一次调用做准备</code>-&gt;<code>循环直到表读完</code></li><li>注意：对已删除数据的处理，因为物理上存在的行（在磁盘 Page 上），逻辑上可能已经被删除了，所以要检查is_deleted_。</li></ul></li></ol><hr><h3 id="InsertExecutor类"><a href="#InsertExecutor类" class="headerlink" title="InsertExecutor类"></a>InsertExecutor类</h3><p><strong>功能：</strong> InsertExecutor 将元组插入表并更新受影响的索引。它恰好有一个子节点，用于生成要插入表中的值。规划器将确保这些值与表的架构相同。执行器将产生一个整数类型的单个元组作为输出，指示已插入表中的行数。在向表中插入数据时，请记住更新索引，如果该表有关联的索引。</p><p><strong>类函数：</strong></p><ol><li>Init():初始化子节点以便后续拉取数据</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">void InsertExecutor::<span class="hljs-built_in">Init</span>() &#123; <br>    child_-&gt;<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">// 递归调用，让子节点（比如 ValuesExecutor 或 SeqScan）准备好数据</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>Next()：执行阶段：<ul><li>插入操作最终只返回一行数据（即受影响的行数 insert_count），所以如果 Next 被第二次调用，必须直接返回 false，表示执行结束。</li><li>逻辑：<code>检查 is_end_ 标志</code>-&gt;<code>循环拉取与物理写入(从子节点获取数据、写入堆表、同步更新所有索引)</code>-&gt;<code>构造返回结果</code></li></ul></li></ol><hr><h3 id="UpdateExecutor类"><a href="#UpdateExecutor类" class="headerlink" title="UpdateExecutor类"></a>UpdateExecutor类</h3><p><strong>功能：</strong> UpdateExecutor 修改指定表中的现有元组。执行器将产生一个整数类型的单个元组作为输出，指示已更新的行数。请记住更新受更新影响的任何索引。</p><p><strong>类函数：</strong><br>和 InsertExecutor 一样，Update 也是一个<strong>Pipeline Breaker（流水线阻断点）</strong>。</p><ul><li>它会一次性处理完子节点传来的所有需要更新的数据。</li><li>最终只返回一行结果：更新成功的条数 (count)。</li></ul><p>Next()：执行阶段：<br><code>遍历要更新的数据</code>-&gt;<code>逻辑删除旧数据</code>-&gt;<code>构造新数据</code>-&gt;<code>插入新数据</code>-&gt;<code>更新索引</code></p><hr><h3 id="DeleteExecutor类"><a href="#DeleteExecutor类" class="headerlink" title="DeleteExecutor类"></a>DeleteExecutor类</h3><p><strong>功能：</strong> 它与要从表中删除的记录恰好有一个子节点。删除执行器应产生一个整数输出，表示它从表中删除的行数。它还需要更新任何受影响的索引。</p><p><strong>类函数：</strong></p><ol><li>Init():初始化子节点以便后续拉取数据</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">void InsertExecutor::<span class="hljs-built_in">Init</span>() &#123; <br>    child_-&gt;<span class="hljs-built_in">Init</span>(); <span class="hljs-comment">// 递归调用，让子节点（比如 ValuesExecutor 或 SeqScan）准备好数据</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>Next():<br><code>遍历待删除数据</code>-&gt;<code>获取当前行的元数据、将删除标记置为 true、写回元数据</code>-&gt;<code>更新索引</code></li></ol><hr><h3 id="IndexScanExecutor类"><a href="#IndexScanExecutor类" class="headerlink" title="IndexScanExecutor类"></a>IndexScanExecutor类</h3><p><strong>功能：</strong> IndexScanExecutor 遍历索引以检索 RIDs 以获取元组。然后，该操作员使用这些 RID 来检索相应表中的元组。接着逐个发出这些元组。</p><p>如果说之前的 SeqScan 是“傻瓜式”地从第一页翻到最后一页，那么 IndexScan 就是 <strong>“查字典”</strong> ：先通过 B+树索引找到数据的 <strong>物理地址（RID）</strong>，然后再去堆表（Table Heap）里抓取真正的数据。</p><p><strong>类函数：</strong></p><p>Next():</p><ul><li>这个算子的工作流程可以概括为：<code>遍历 B+树叶子节点</code> -&gt; <code>拿到 RID</code> -&gt; <code>回表查数据</code>。</li><li>为什么需要回表?:B+树里只存了 &lt;Key, RID&gt;，光有 Key 是不够的。所以必须通过 RID 去 Heap 中读取完整数据</li></ul><hr><h2 id="部件实现：聚合与连接执行器"><a href="#部件实现：聚合与连接执行器" class="headerlink" title="部件实现：聚合与连接执行器"></a>部件实现：聚合与连接执行器</h2><p>需要添加一个聚合执行器、多个连接执行器，并使优化器在规划查询时能够在嵌套循环连接和哈希连接之间进行选择。</p><hr><h3 id="AggregationExecutor类"><a href="#AggregationExecutor类" class="headerlink" title="AggregationExecutor类"></a>AggregationExecutor类</h3><p><strong>功能：</strong> 聚合执行器为每个输入分组计算聚合函数。它有一个子节点。输出模式由分组列和聚合列组成。BusTub 采用的是 <strong>哈希聚合</strong> ，以分组列为键。</p><p><strong>示例：</strong><br>假设有一张表 Student，我们要执行：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Major, <span class="hljs-built_in">COUNT</span>(*), <span class="hljs-built_in">AVG</span>(GPA) <br><span class="hljs-keyword">FROM</span> Student <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Major;<br></code></pre></td></tr></table></figure><p>输入数据流：</p><pre><code class="hljs">&#123;CS, 3.5&#125;&#123;Math, 3.8&#125;&#123;CS, 3.9&#125;&#123;English, 3.2&#125;</code></pre><p>执行过程：</p><ul><li><p>读第 1 行 {CS, 3.5}:</p><ul><li><p>哈希表中没有 “CS”。</p></li><li><p>插入: Key&#x3D;”CS”, Val&#x3D;{Count&#x3D;1, SumGPA&#x3D;3.5}</p></li></ul></li><li><p>读第 2 行 {Math, 3.8}:</p><ul><li><p>哈希表中没有 “Math”。</p></li><li><p>插入: Key&#x3D;”Math”, Val&#x3D;{Count&#x3D;1, SumGPA&#x3D;3.8}</p></li></ul></li><li><p>读第 3 行 {CS, 3.9}:</p><ul><li><p>哈希表中已有 “CS”。</p></li><li><p>更新: 拿出旧值，Count变成 1+1&#x3D;2，SumGPA变成 3.5+3.9&#x3D;7.4。</p></li><li><p>当前 “CS” 条目: Val&#x3D;{Count&#x3D;2, SumGPA&#x3D;7.4}</p></li></ul></li><li><p>读第 4 行 {English, 3.2}:</p><ul><li>插入: Key&#x3D;”English”, Val&#x3D;{Count&#x3D;1, SumGPA&#x3D;3.2}</li></ul></li></ul><p>最终输出: 遍历哈希表，计算 AVG (Sum&#x2F;Count)，输出结果</p><p><strong>类函数：</strong></p><ol><li>Init():<ul><li>这是最关键的一步。在 Init 结束前，父节点拿不到任何数据。</li><li>逻辑： <code>遍历子节点的所有数据</code>-&gt;<code>生成 Key (分组依据)、生成 Value (待聚合的值)</code>-&gt;<code>插入或更新哈希表</code>-&gt;<code>准备迭代器，供 Next 阶段使用</code></li></ul></li><li>Next():<ul><li>当 Init 把哈希表建好后，Next 的工作就很简单了：遍历哈希表，把结果吐出来。<br> 逻辑：</li><li><code>情况 A: 哈希表里有数据</code>-&gt;<code>获取 Group By 的列 (Key)</code>-&gt;<code>获取聚合后的结果 (Value)</code>-&gt;<code>封装成 Tuple 返回</code></li><li><code>情况 B: 哈希表是空的</code>-&gt;<code>没有‘GROUP BY’，例如：SELECT COUNT(*) FROM empty_table; -&gt; 结果应该是 0</code>、<code>有‘GROUP BY’，SELECT COUNT(*) FROM empty_table GROUP BY id; -&gt; 结果应该是null</code></li></ul></li></ol><hr><h3 id="HashJoinExecutor类"><a href="#HashJoinExecutor类" class="headerlink" title="HashJoinExecutor类"></a>HashJoinExecutor类</h3><p><strong>功能：</strong> HashJoinExecutor 实现内连接和外连接。该操作符的输出模式是左表的所有列，然后是右表的所有列。与聚合类似，你可以假设用于连接的哈希表可以完全放入内存中。</p><p><strong>类函数：</strong></p><ol><li><p>Init():</p><ul><li>逻辑：<code>初始化左右两个子节点，准备好从它们那里拉取数据</code>-&gt;<code>构建阶段 (Build Phase) - 处理右表(遍历右表-&gt;计算 Key-&gt;插入哈希表)</code>-&gt;<code>探测阶段 (Probe Phase) - 处理左表(这一步遍历左表（Left Child），并根据连接类型（Inner vs Left）执行不同的逻辑)</code></li></ul></li><li><p>Next():</p><ul><li>Init函数已经得到连接后的结果，所以Next函数只进行迭代器递增和判断是否到最后</li></ul></li></ol><hr><h2 id="部件实现：排序、限制执行器"><a href="#部件实现：排序、限制执行器" class="headerlink" title="部件实现：排序、限制执行器"></a>部件实现：排序、限制执行器</h2><p>如果表上有索引，查询处理层将自动选择它进行排序。在其他情况下，需要使用特殊的排序执行器来完成此操作。</p><hr><h3 id="SortExecutor类"><a href="#SortExecutor类" class="headerlink" title="SortExecutor类"></a>SortExecutor类</h3><p><strong>类函数：</strong></p><ol><li>Init():<ul><li>逻辑：<code>循环读取子节点的所有数据,放入内存变量</code>-&gt;<code>在内存中根据特定的规则重排顺序</code>-&gt;<code>将迭代器指向排序后结果的开头</code></li></ul></li><li>Next():<ul><li>只进行迭代器递增和判断是否继续</li></ul></li></ol><hr><h3 id="LimitExecutor类"><a href="#LimitExecutor类" class="headerlink" title="LimitExecutor类"></a>LimitExecutor类</h3><p><strong>功能：</strong> LimitExecutor限制了其子执行器输出的元组数量。如果其子执行器产生的元组数量少于计划节点中指定的限制，则该执行器无效，并输出它接收到的所有元组。</p><p>与 Sort 或 Aggregation 不同，LimitExecutor 不是 Pipeline Breaker。 它不需要等待子节点把数据全读完才开始工作。相反，它是一个 <strong>“计数器 + 闸门”</strong>：</p><ul><li><p>子节点给一条，它就数一条，放行一条。</p></li><li><p>一旦数到了限制值（Limit），立刻关闸。</p></li></ul><p><strong>类函数：</strong></p><ol><li><p>Init()</p><ul><li>让子类做好准,计数器归零</li></ul></li><li><p>Next()</p><ul><li>逻辑：<code>检查是否达到上限,到达上限不返回数据</code>-&gt;<code>计数器+1</code>-&gt;<code>直接调用子节点的 Next，尝试拉取一条数据</code></li><li>计数器cursor_:作为成员变量（而不是局部变量），就起到了 <strong>“记忆”</strong> 的作用。它记录了从 Init() 开始到现在，已经成功向上传递了多少行数据，到达上限就截止。</li></ul></li></ol><p><strong>注意：</strong> 与 Sort 的配合 (Top-N 查询)<br>通常 LIMIT 会和 ORDER BY 一起出现（例如 ORDER BY score DESC LIMIT 10）。</p><ul><li><p>在目前的实现中： 查询计划通常是 Limit -&gt; Sort -&gt; Scan。 由于 Sort 是 Pipeline Breaker（必须读完所有数据才能排序），所以在这种架构下，Limit 无法 节省 Scan 的 I&#x2F;O。Sort 依然会把 1000 万行读出来排好序，然后 Limit 从内存里取前 10 个。</p></li><li><p>优化方向 (Top-N Optimization)： 在更高级的优化中，会将 Limit 压入 Sort 内部，使用 堆排序 (Heap Sort) 维护一个大小为 N 的堆。这样虽然还是要读完数据，但不需要对所有数据进行全量排序，能节省内存和 CPU。</p></li></ul><hr><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><img src="/img/CMU15-445-Bustub-project3实现笔记/result.png" alt="测试结果" style="display: block; margin: 0 auto; width: 70%; height:70%;">]]></content>
    
    
    <categories>
      
      <category>CMU15-445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Bustub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15-445(Bustub):project2实现笔记</title>
    <link href="/2025/12/03/CMU15-445-Bustub-project2%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/12/03/CMU15-445-Bustub-project2%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CMU-15-445-Project-2-B-Tree-Index-实现过程文档"><a href="#CMU-15-445-Project-2-B-Tree-Index-实现过程文档" class="headerlink" title="CMU 15-445 Project 2: B+Tree Index 实现过程文档"></a>CMU 15-445 Project 2: B+Tree Index 实现过程文档</h1><h2 id="1-项目概览"><a href="#1-项目概览" class="headerlink" title="1. 项目概览"></a>1. 项目概览</h2><p>本项目实现了一个支持高并发、基于磁盘的 B+ 树动态索引结构。它支持插入、点查询（Search）、删除以及范围扫描（Iterator）。核心难点在于页面布局的设计、递归的分裂与合并逻辑、以及使用 <strong>Latch Crabbing</strong> 技术实现的细粒度锁并发控制。</p><h2 id="2-核心数据结构设计-Page-Layout"><a href="#2-核心数据结构设计-Page-Layout" class="headerlink" title="2. 核心数据结构设计 (Page Layout)"></a>2. 核心数据结构设计 (Page Layout)</h2><p>B+ 树的节点分为 <strong>内部页 (Internal Page)</strong> 和 <strong>叶子页 (Leaf Page)</strong>，它们都继承自基础页类。</p><img src="/img/CMU15-445-Bustub-project2实现笔记/B+TreeSt.png" alt="B+树数据结构" style="display: block; margin: 0 auto; width: 70%; height:70%;"><img src="/img/CMU15-445-Bustub-project2实现笔记/B+TreeLayout.png" alt="B+树实现" style="display: block; margin: 0 auto; width: 70%; height:70%;"><h3 id="2-1-基础页类-b-plus-tree-page-cpp"><a href="#2-1-基础页类-b-plus-tree-page-cpp" class="headerlink" title="2.1 基础页类 (b_plus_tree_page.cpp)"></a>2.1 基础页类 (<code>b_plus_tree_page.cpp</code>)</h3><ul><li><p><strong>作用</strong>：存储所有节点共有的元数据。</p></li><li><p><strong>核心字段</strong>：</p><ul><li><code>page_type_</code>: 枚举类型，标记当前是 Internal 还是 Leaf。</li><li><code>size_</code>: 当前页面存储的键值对数量。</li><li><code>max_size_</code>: 页面最大容量。</li></ul></li><li><p><strong>关键逻辑</strong>：</p><ul><li><code>GetMinSize()</code>: 计算节点合并的阈值。</li><li><strong>根节点</strong>：特殊处理，Internal 根至少 2 个子节点，Leaf 根可以是 0。</li><li><strong>Internal</strong>：$\lceil (MaxSize + 1) &#x2F; 2 \rceil$ (这是因为 Internal 节点存储 N 个键，N+1 个指针)。</li><li><strong>Leaf</strong>：MaxSize &#x2F; 2。</li></ul></li></ul><h3 id="2-2-内部页-b-plus-tree-internal-page-cpp"><a href="#2-2-内部页-b-plus-tree-internal-page-cpp" class="headerlink" title="2.2 内部页 (b_plus_tree_internal_page.cpp)"></a>2.2 内部页 (<code>b_plus_tree_internal_page.cpp</code>)</h3><ul><li><p><strong>存储结构</strong>：存储 <code>MappingType</code> 为 <code>std::pair&lt;KeyType, page_id_t&gt;</code>。</p></li><li><p><strong>关键特性</strong>：</p></li><li><p>第 0 个 Key 是无效的（Invalid），只有 Value（指向子节点的指针）是有效的。</p></li><li><p><strong>核心函数解析</strong>：</p><ul><li><p><code>Lookup(key, comparator)</code>: 使用 <strong>二分查找 (Binary Search)</strong>。</p></li><li><p>返回指向 <strong>第一个 Key &gt; target</strong> 的前一个位置的 Value。这保证了能够正确导航到包含该 Key 的子树。</p></li><li><p><code>MoveHalfTo(recipient)</code>: <strong>分裂 (Split)</strong> 逻辑。</p></li><li><p>将当前页面后半部分移动到新创建的兄弟页面 (<code>recipient</code>)。</p></li><li><p>Internal 节点分裂时，中间的 Key 会被<strong>上提 (Push Up)</strong> 到父节点，而不是留在叶子中。</p></li><li><p><code>MoveAllTo(recipient)</code>: <strong>合并 (Merge)</strong> 逻辑。</p></li><li><p>将当前页面的所有内容移动到兄弟页面中，用于节点被删除后的合并操作。</p></li></ul></li></ul><h3 id="2-3-叶子页-b-plus-tree-leaf-page-cpp"><a href="#2-3-叶子页-b-plus-tree-leaf-page-cpp" class="headerlink" title="2.3 叶子页 (b_plus_tree_leaf_page.cpp)"></a>2.3 叶子页 (<code>b_plus_tree_leaf_page.cpp</code>)</h3><ul><li><p><strong>存储结构</strong>：存储 <code>MappingType</code> 为 <code>std::pair&lt;KeyType, ValueType&gt;</code> (即 <code>RID</code>)。</p></li><li><p><strong>关键特性</strong>：</p><ul><li>维护 <code>next_page_id_</code>，将所有叶子节点串联成单向链表，支持范围查询。</li></ul></li><li><p><strong>核心函数解析</strong>：</p><ul><li><p><code>Lookup(key, comparator)</code>: <strong>二分查找</strong>。</p><ul><li>找到第一个 <code>Key &gt;= target</code> 的位置（<code>lower_bound</code> 语义）。</li></ul></li><li><p><code>Insert(key, value)</code>: 插入时保持有序性。</p><ul><li>因为数组是有序的，插入需要 O(N) 的数据搬移。</li></ul></li><li><p><code>MoveHalfTo(recipient)</code>:</p><ul><li>叶子节点分裂时，中间 Key <strong>复制 (Copy Up)</strong> 到父节点（仍然保留在叶子中）。更新 <code>next_page_id_</code> 链表。</li></ul></li></ul></li></ul><hr><h2 id="3-并发控制-Concurrency-Control"><a href="#3-并发控制-Concurrency-Control" class="headerlink" title="3. 并发控制 (Concurrency Control)"></a>3. 并发控制 (Concurrency Control)</h2><p>为了支持多线程，避免使用全局大锁，项目采用了 <strong>Latch Crabbing (锁耦合)</strong> 协议。</p><h3 id="3-1-Page-Guard机制"><a href="#3-1-Page-Guard机制" class="headerlink" title="3.1 Page Guard机制"></a>3.1 Page Guard机制</h3><p>(<code>page_guard.cpp</code>)这是一个 RAII (Resource Acquisition Is Initialization) 风格的封装类，用于管理 <code>BufferPoolManager</code> 的页面引脚 (Pin) 和锁 (Latch)。</p><ul><li><strong>BasicPageGuard</strong>: 负责 <code>UnpinPage</code>。析构时自动 Unpin，防止内存泄漏。</li><li><strong>ReadPageGuard &#x2F; WritePageGuard</strong>: 继承自 Basic，额外负责 <code>RUnlatch</code> &#x2F; <code>WUnlatch</code>。析构时自动释放锁，防止死锁。</li></ul><h3 id="3-2-锁耦合逻辑-Latch-Crabbing"><a href="#3-2-锁耦合逻辑-Latch-Crabbing" class="headerlink" title="3.2 锁耦合逻辑 (Latch Crabbing)"></a>3.2 锁耦合逻辑 (Latch Crabbing)</h3><p>基本思想是：在遍历树时，先锁住子节点，再释放父节点的锁。</p><ul><li><strong>Search (读操作)</strong>:</li></ul><ol><li>获取父节点读锁。</li><li>获取子节点读锁。</li><li>释放父节点读锁。</li></ol><ul><li><strong>Insert&#x2F;Delete (写操作)</strong>:</li></ul><ol><li><p>获取父节点写锁。</p></li><li><p>获取子节点写锁。</p></li><li><p><strong>安全检测 (Safe Check)</strong>:</p><ul><li><strong>插入安全</strong>：当前节点未满 (<code>Size &lt; MaxSize</code>)。</li><li><strong>删除安全</strong>：当前节点大于半满 (<code>Size &gt; MinSize</code>)。</li></ul></li><li><p>如果子节点是“安全”的，说明操作不会波及到父节点（不会分裂或合并），此时可以<strong>提前释放所有祖先节点的写锁</strong>。这极大地提高了并发性能。</p></li></ol><img src="/img/CMU15-445-Bustub-project2实现笔记/LatchLogic.png" alt="锁逻辑" style="display: block; margin: 0 auto; width: 70%; height:70%;"><p>代码体现见 <code>b_plus_tree.cpp</code> 中的 <code>InsertGetKeyAt</code> 和 <code>DeleteGetKeyAt</code> 函数中的 <code>ctx.write_set_.clear()</code> 逻辑。</p><hr><h2 id="4-B-树核心操作实现原理-b-plus-tree-cpp"><a href="#4-B-树核心操作实现原理-b-plus-tree-cpp" class="headerlink" title="4. B+树核心操作实现原理 (b_plus_tree.cpp)"></a>4. B+树核心操作实现原理 (<code>b_plus_tree.cpp</code>)</h2><h3 id="4-1-查询操作-GetValue"><a href="#4-1-查询操作-GetValue" class="headerlink" title="4.1 查询操作 (GetValue)"></a>4.1 查询操作 (<code>GetValue</code>)</h3><ol><li><p><strong>初始化</strong>：创建一个 <code>Context</code> 上下文对象。</p></li><li><p><strong>定位叶子</strong>：调用 <code>GetKeyAt</code>，从 Root 开始向下遍历。</p><ul><li>使用 <code>FetchPageRead</code> 获取读锁。</li><li>每进入下一层，释放上一层的锁（通过 <code>read_set_.pop_front()</code>）。</li></ul></li><li><p><strong>页内查找</strong>：在叶子节点调用 <code>LeafPage::Lookup</code> 找到 Value。</p></li><li><p><strong>返回结果</strong>：读取后释放叶子节点的锁。</p></li></ol><img src="/img/CMU15-445-Bustub-project2实现笔记/GetValue.png" alt="查询操作" style="display: block; margin: 0 auto; width: 70%; height:70%;"><h3 id="4-2-插入操作-Insert"><a href="#4-2-插入操作-Insert" class="headerlink" title="4.2 插入操作 (Insert)"></a>4.2 插入操作 (<code>Insert</code>)</h3><ol><li><p><strong>定位并锁定</strong>：调用 <code>InsertGetKeyAt</code>。</p><ul><li><strong>Pessimistic Locking</strong>: 也就是代码中使用的策略，一路加<strong>写锁</strong>。</li><li>若遇到安全节点，清空 <code>write_set_</code>（释放祖先锁）。</li></ul></li><li><p><strong>叶子插入</strong>：</p><ul><li><strong>Case A: 也就是未满</strong>：直接 <code>leaf_page-&gt;Insert</code>，成功后返回。</li><li><strong>Case B: 叶子已满 (Split)</strong>：</li></ul></li><li><p>创建新叶子页 <code>NewPageGuarded</code>。</p></li><li><p><code>MoveHalfTo</code>: 将一半数据移到新页。</p></li><li><p>更新链表 <code>next_page_id</code>。</p></li><li><p><strong>向上递归</strong>：调用 <code>InsertIntoParent</code> 将中间 Key (<code>mid_key</code>) 插入父节点。</p></li><li><p><strong>父节点插入 (<code>InsertIntoParent</code>)</strong>:</p><ul><li>如果父节点未满：直接插入，结束。</li><li>如果父节点已满：<ol><li>分裂父节点（Internal Page Split）。</li><li>注意：Internal Split 会将中间 Key <strong>提拔</strong> 到更上一层，而不是像 Leaf 那样复制。</li><li>递归调用 <code>InsertIntoParent</code> 直到根节点。</li></ol></li></ul></li></ol><ul><li><strong>根分裂</strong>：如果根节点分裂，创建新的 Root，更新 Header Page 的 <code>root_page_id</code>。</li></ul><img src="/img/CMU15-445-Bustub-project2实现笔记/Insert.png" alt="插入操作" style="display: block; margin: 0 auto; width: 70%; height:70%;"><h3 id="4-3-删除操作-Remove"><a href="#4-3-删除操作-Remove" class="headerlink" title="4.3 删除操作 (Remove)"></a>4.3 删除操作 (<code>Remove</code>)</h3><p>这是最复杂的逻辑。</p><ol><li><strong>定位并锁定</strong>：调用 <code>DeleteGetKeyAt</code>，一路加写锁，如果节点安全（删除一个元素后仍大于 MinSize），则释放祖先锁。</li><li><strong>叶子删除</strong>：调用 <code>leaf_page-&gt;RemoveKeyAt</code>。</li><li><strong>处理下溢 (Underflow)</strong>：如果删除后 <code>Size &lt; MinSize</code>，需要调整。</li></ol><ul><li><p>获取兄弟节点：调用 <code>GetSiblingPageId</code>。优先找左兄弟，没有则找右兄弟。</p></li><li><p><strong>策略 1：借调 (Redistribute &#x2F; Borrow)</strong>：</p><ul><li>如果兄弟节点有多余的键 (<code>Size &gt; MinSize</code>)。</li><li><strong>从兄弟借一个</strong>：如果是左兄弟，借最大的；右兄弟，借最小的。</li><li><strong>更新父节点</strong>：借调后，父节点的分隔 Key 需要更新（<code>ReplaceKeyAt</code>）。</li></ul></li><li><p><strong>策略 2：合并 (Merge &#x2F; Coalesce)</strong>：</p><ul><li><p>如果兄弟节点也是刚过及格线，不够借。</p></li><li><p>将当前节点和兄弟节点合并成一个节点。</p></li><li><p><strong>标记删除</strong>：将其中一个页面标记为删除 (<code>bpm_-&gt;DeletePage</code>)。</p></li><li><p><strong>递归删除</strong>：合并导致父节点少了一个子节点，必须在父节点中删除对应的 Key 和 Pointer。这可能触发父节点的递归合并。</p></li><li><p><strong>根节点处理</strong>：如果根节点被删空，或者 Internal 类型的根节点只剩 1 个子节点，则将该子节点设为新根（树层高 -1）。</p></li></ul></li></ul><img src="/img/CMU15-445-Bustub-project2实现笔记/Remove.png" alt="操作" style="display: block; margin: 0 auto; width: 70%; height:70%;"><hr><h2 id="5-迭代器-IndexIterator-文件：index-iterator-cpp"><a href="#5-迭代器-IndexIterator-文件：index-iterator-cpp" class="headerlink" title="5. 迭代器 (IndexIterator)文件：index_iterator.cpp"></a>5. 迭代器 (<code>IndexIterator</code>)文件：<code>index_iterator.cpp</code></h2><ul><li><p><strong>实现标准</strong>：实现了 C++ STL 风格的迭代器，支持 <code>begin()</code>, <code>end()</code>, <code>++</code>, <code>*</code>, <code>==</code>。</p></li><li><p><strong>状态保持</strong>：</p><ul><li><code>B_PLUS_TREE_LEAF_PAGE_TYPE *page_</code>: 当前所在的叶子页指针。</li><li><code>int index_</code>: 当前在叶子页中的下标。</li><li><code>ReadPageGuard page_guard_</code>: <strong>关键</strong>。迭代器持有当前页面的读锁。</li></ul></li><li><p><strong>跨页遍历 (<code>operator++</code>)</strong>:</p><ul><li>当 <code>index_</code> 达到当前页末尾时，通过 <code>page_-&gt;GetNextPageId()</code> 获取下一页 ID。</li></ul></li><li><p><strong>锁交接</strong>：先获取下一页的锁，再释放当前页的锁（通过 Guard 的移动赋值自动处理），保证并发扫描的安全性。</p></li></ul><hr><h2 id="6-总结该项目通过三个层次实现了高性能索引："><a href="#6-总结该项目通过三个层次实现了高性能索引：" class="headerlink" title="6. 总结该项目通过三个层次实现了高性能索引："></a>6. 总结该项目通过三个层次实现了高性能索引：</h2><ol><li><strong>存储层</strong>：精心设计的 Internal&#x2F;Leaf Page 布局，利用二分查找优化页内搜索。</li><li><strong>逻辑层</strong>：完整的 Split (自底向上生长) 和 Merge (自底向上收缩) 算法，维持 B+ 树平衡特性。</li><li><strong>控制层</strong>：使用 <code>PageGuard</code> 和 <code>Context</code> 实现 Latch Crabbing，在保证线程安全的前提下最大化并发度。</li></ol><p><strong>测试结果如下：</strong></p><img src="/img/CMU15-445-Bustub-project2实现笔记/result.png" alt="结果" style="display: block; margin: 0 auto; width: 70%; height:70%;">]]></content>
    
    
    <categories>
      
      <category>CMU15-445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Bustub</tag>
      
      <tag>B+Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB命令大全</title>
    <link href="/2025/11/26/GDB%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <url>/2025/11/26/GDB%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="GDB-命令大全（超全版）"><a href="#GDB-命令大全（超全版）" class="headerlink" title="GDB 命令大全（超全版）"></a>GDB 命令大全（超全版）</h1><h2 id="一、启动与退出"><a href="#一、启动与退出" class="headerlink" title="一、启动与退出"></a>一、启动与退出</h2><ul><li><p><code>gdb &lt;program&gt;</code><br>启动 GDB 并加载可执行文件。</p></li><li><p><code>gdb &lt;program&gt; &lt;core&gt;</code><br>调试 core dump 文件。</p></li><li><p><code>gdb -tui &lt;program&gt;</code><br>使用 TUI 模式（分屏显示代码和调试信息）。</p></li><li><p><code>file &lt;program&gt;</code><br>在 GDB 内加载可执行文件。</p></li><li><p><code>quit</code> &#x2F; <code>q</code><br>退出 GDB。</p></li></ul><hr><h2 id="二、运行与进程控制"><a href="#二、运行与进程控制" class="headerlink" title="二、运行与进程控制"></a>二、运行与进程控制</h2><ul><li><p><code>run</code> &#x2F; <code>r</code><br>运行程序（可附带参数）。</p></li><li><p><code>run arg1 arg2</code><br>运行程序并传参。</p></li><li><p><code>set args arg1 arg2</code><br>设置程序运行时的默认参数。</p></li><li><p><code>show args</code><br>查看当前参数设置。</p></li><li><p><code>attach &lt;pid&gt;</code><br>附加调试正在运行的进程。</p></li><li><p><code>detach</code><br>从进程分离，不终止程序。</p></li><li><p><code>kill</code><br>终止正在调试的程序。</p></li></ul><hr><h2 id="三、断点（Breakpoints）"><a href="#三、断点（Breakpoints）" class="headerlink" title="三、断点（Breakpoints）"></a>三、断点（Breakpoints）</h2><h3 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1. 设置断点"></a>1. 设置断点</h3><ul><li><p><code>break &lt;line&gt;</code> &#x2F; <code>b &lt;line&gt;</code><br>在指定行设置断点。</p></li><li><p><code>break &lt;function&gt;</code><br>在函数入口处设置断点。</p></li><li><p><code>break &lt;file:line&gt;</code><br>指定文件中的某一行断点。</p></li><li><p><code>break *&lt;address&gt;</code><br>在指定内存地址设置断点。</p></li><li><p><code>tbreak &lt;location&gt;</code><br>设置一次性断点（触发一次后自动删除）。</p></li></ul><h3 id="2-条件断点"><a href="#2-条件断点" class="headerlink" title="2. 条件断点"></a>2. 条件断点</h3><ul><li><code>condition &lt;num&gt; &lt;expr&gt;</code><br>给断点加条件。</li></ul><h3 id="3-管理断点"><a href="#3-管理断点" class="headerlink" title="3. 管理断点"></a>3. 管理断点</h3><ul><li><p><code>info breakpoints</code> &#x2F; <code>i b</code><br>查看所有断点。</p></li><li><p><code>delete &lt;num&gt;</code> &#x2F; <code>d &lt;num&gt;</code><br>删除断点。</p></li><li><p><code>disable &lt;num&gt;</code><br>禁用断点。</p></li><li><p><code>enable &lt;num&gt;</code><br>启用断点。</p></li></ul><hr><h2 id="四、程序执行控制"><a href="#四、程序执行控制" class="headerlink" title="四、程序执行控制"></a>四、程序执行控制</h2><ul><li><p><code>continue</code> &#x2F; <code>c</code><br>恢复执行直到下一个断点。</p></li><li><p><code>next</code> &#x2F; <code>n</code><br>单步执行（不进入函数）。</p></li><li><p><code>step</code> &#x2F; <code>s</code><br>单步执行（会进入函数）。</p></li><li><p><code>finish</code><br>执行直到当前函数返回。</p></li><li><p><code>until</code><br>运行直到当前循环或函数的下一行。</p></li><li><p><code>jump &lt;line/address&gt;</code><br>强制跳转到某行或某地址。</p></li></ul><hr><h2 id="五、查看源码"><a href="#五、查看源码" class="headerlink" title="五、查看源码"></a>五、查看源码</h2><ul><li><p><code>list</code> &#x2F; <code>l</code><br>查看源码（每次显示 10 行）。</p></li><li><p><code>list &lt;line&gt;</code><br>查看特定行附近的代码。</p></li><li><p><code>list &lt;function&gt;</code><br>显示某函数代码。</p></li><li><p>重复 <code>list</code><br>显示下一段代码。</p></li></ul><hr><h2 id="六、查看栈与调用信息"><a href="#六、查看栈与调用信息" class="headerlink" title="六、查看栈与调用信息"></a>六、查看栈与调用信息</h2><ul><li><p><code>backtrace</code> &#x2F; <code>bt</code><br>打印调用栈。</p></li><li><p><code>backtrace full</code><br>打印调用栈和每一帧的局部变量。</p></li><li><p><code>frame &lt;num&gt;</code> &#x2F; <code>f &lt;num&gt;</code><br>切换到指定栈帧。</p></li><li><p><code>up</code><br>切换到上层栈帧。</p></li><li><p><code>down</code><br>切换到下层栈帧。</p></li><li><p><code>info args</code><br>显示当前函数的参数。</p></li><li><p><code>info locals</code><br>显示当前函数的局部变量。</p></li></ul><hr><h2 id="七、打印变量-内存-类型"><a href="#七、打印变量-内存-类型" class="headerlink" title="七、打印变量 &#x2F; 内存 &#x2F; 类型"></a>七、打印变量 &#x2F; 内存 &#x2F; 类型</h2><h3 id="1-打印变量"><a href="#1-打印变量" class="headerlink" title="1. 打印变量"></a>1. 打印变量</h3><ul><li><p><code>print &lt;expr&gt;</code> &#x2F; <code>p &lt;expr&gt;</code><br>打印变量或表达式值。</p></li><li><p><code>p /x &lt;expr&gt;</code><br>以十六进制打印。</p></li><li><p><code>display &lt;expr&gt;</code><br>每次单步后自动显示表达式。</p></li><li><p><code>undisplay &lt;num&gt;</code><br>删除自动显示项。</p></li></ul><h3 id="2-查看内存（x-命令）"><a href="#2-查看内存（x-命令）" class="headerlink" title="2. 查看内存（x 命令）"></a>2. 查看内存（x 命令）</h3><p>格式： <code>x /&lt;n&gt;&lt;format&gt;&lt;size&gt; &lt;address&gt;</code></p><p>常用格式：</p><ul><li><code>x/10xb &lt;addr&gt;</code> — 查看 10 个字节（hex）</li><li><code>x/4i &lt;addr&gt;</code> — 反汇编 4 条指令</li><li><code>x/20xw &lt;addr&gt;</code> — 查看 20 个 4 字节字(word)</li></ul><h3 id="3-查看类型"><a href="#3-查看类型" class="headerlink" title="3. 查看类型"></a>3. 查看类型</h3><ul><li><p><code>ptype &lt;var&gt;</code><br>显示变量类型。</p></li><li><p><code>whatis &lt;expr&gt;</code><br>显示表达式类型。</p></li></ul><hr><h2 id="八、寄存器和汇编级调试（重要）"><a href="#八、寄存器和汇编级调试（重要）" class="headerlink" title="八、寄存器和汇编级调试（重要）"></a>八、寄存器和汇编级调试（重要）</h2><h3 id="1-汇编级单步"><a href="#1-汇编级单步" class="headerlink" title="1. 汇编级单步"></a>1. 汇编级单步</h3><ul><li><p><code>stepi</code> &#x2F; <code>si</code><br>执行一条机器指令。</p></li><li><p><code>nexti</code> &#x2F; <code>ni</code><br>跳过函数执行一条机器指令。</p></li></ul><h3 id="2-查看汇编"><a href="#2-查看汇编" class="headerlink" title="2. 查看汇编"></a>2. 查看汇编</h3><ul><li><p><code>disassemble</code><br>反汇编当前函数。</p></li><li><p><code>disassemble &lt;address&gt;</code><br>反汇编指定地址范围。</p></li></ul><h3 id="3-寄存器"><a href="#3-寄存器" class="headerlink" title="3. 寄存器"></a>3. 寄存器</h3><ul><li><p><code>info registers</code><br>查看所有寄存器。</p></li><li><p><code>p $rax</code><br>打印寄存器（如 x86_64 的 rax）。</p></li></ul><hr><h2 id="九、线程调试（多线程程序）"><a href="#九、线程调试（多线程程序）" class="headerlink" title="九、线程调试（多线程程序）"></a>九、线程调试（多线程程序）</h2><ul><li><p><code>info threads</code><br>查看所有线程。</p></li><li><p><code>thread &lt;id&gt;</code><br>切换到指定线程。</p></li><li><p><code>thread apply all &lt;cmd&gt;</code><br>对所有线程执行命令。</p></li><li><p><code>thread apply &lt;id&gt; &lt;cmd&gt;</code><br>只对某线程执行命令。</p></li></ul><hr><h2 id="十、多进程（fork-exec）"><a href="#十、多进程（fork-exec）" class="headerlink" title="十、多进程（fork &#x2F; exec）"></a>十、多进程（fork &#x2F; exec）</h2><ul><li><p><code>set follow-fork-mode child|parent</code><br>设置调试 fork 后跟踪谁。</p></li><li><p><code>set detach-on-fork on|off</code><br>控制是否同时调试两进程。</p></li><li><p><code>info inferiors</code><br>查看当前所有被调试的进程。</p></li><li><p><code>inferior &lt;id&gt;</code><br>切换当前进程。</p></li></ul><hr><h2 id="十一、Watchpoint（监视变量）"><a href="#十一、Watchpoint（监视变量）" class="headerlink" title="十一、Watchpoint（监视变量）"></a>十一、Watchpoint（监视变量）</h2><ul><li><p><code>watch &lt;expr&gt;</code><br>当表达式的值发生变化停止。</p></li><li><p><code>rwatch &lt;expr&gt;</code><br>读表达式时停止。</p></li><li><p><code>awatch &lt;expr&gt;</code><br>读写任何访问都停止。</p></li><li><p><code>info watchpoints</code><br>查看所有 watchpoints。</p></li></ul><hr><h2 id="十二、脚本-自动化"><a href="#十二、脚本-自动化" class="headerlink" title="十二、脚本 &#x2F; 自动化"></a>十二、脚本 &#x2F; 自动化</h2><ul><li><p><code>source &lt;file&gt;</code><br>运行一组 GDB 命令（脚本）。</p></li><li><p><code>.gdbinit</code><br>在当前目录或主目录下自动执行。</p></li></ul><hr><h2 id="十三、其他常用命令"><a href="#十三、其他常用命令" class="headerlink" title="十三、其他常用命令"></a>十三、其他常用命令</h2><ul><li><p><code>help</code><br>显示帮助。</p></li><li><p><code>help &lt;command&gt;</code><br>查看某命令帮助。</p></li><li><p><code>set pagination off</code><br>关闭分页显示（打印长输出不需按回车）。</p></li><li><p><code>set print pretty on</code><br>格式化输出结构体内容。</p></li><li><p><code>info functions</code><br>显示所有函数列表。</p></li><li><p><code>info variables</code><br>显示所有全局变量。</p></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>GDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GDB</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda的使用</title>
    <link href="/2025/11/10/Anaconda%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/11/10/Anaconda%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p>Anaconda 的运作主要基于以下两个核心机制：</p><ul><li><strong>环境隔离</strong></li></ul><p>Anaconda 通过创建独立的虚拟环境来实现隔离。每个环境都拥有自己的 Python 解释器、依赖包以及其各自的安装路径（通常是 anaconda3&#x2F;envs&#x2F;你的环境名称&#x2F;目录）。当你切换环境时，Anaconda 会通过调整系统的 PATH 等环境变量，来确保命令指向的是当前活跃环境中的正确版本。这使得你可以在同一台计算机上为不同的项目维护多个互不干扰的独立环境，例如一个使用 Python 3.7 配合 TensorFlow 1.x 的环境，和另一个使用 Python 3.9 配合 TensorFlow 2.x 的环境。</p><ul><li><strong>包管理与缓存机制</strong></li></ul><p>Conda 不仅是环境管理器，也是一个强大的包管理器。它会自动处理软件包之间复杂的依赖关系，确保安装的所有库版本兼容。为了提高效率，Conda 在本地有一个包缓存目录（通常是 anaconda3&#x2F;pkgs&#x2F;）。当你在某个环境中安装一个包时，Conda 会先检查缓存，如果缓存中存在，则直接将其链接或复制到当前环境 site-packages目录下；如果不存在，则先从仓库下载到缓存，再进行安装。这种机制避免了在不同环境中重复下载同一个包，节省了时间和磁盘空间。</p><h2 id="Conda-与-Pip-的对比"><a href="#Conda-与-Pip-的对比" class="headerlink" title="Conda 与 Pip 的对比"></a>Conda 与 Pip 的对比</h2><p>虽然 Python 自带的 pip 也能安装包，但 Conda 在管理科学计算领域的库时更具优势，特别是在处理非 Python 依赖（如 C&#x2F;C++ 库）方面。为了清晰地展示它们的区别，请看下表：</p><table><thead><tr><th align="left">特性</th><th align="left">conda</th><th align="left">pip</th></tr></thead><tbody><tr><td align="left">管理范围</td><td align="left">可管理 Python 包和非 Python 依赖（如 C 库）</td><td align="left">主要管理python包</td></tr><tr><td align="left">环境管理</td><td align="left">内置虚拟环境管理功能</td><td align="left">依赖virtualenv</td></tr><tr><td align="left">依赖解决</td><td align="left">严格的依赖关系检测机制</td><td align="left">依赖解决能力弱</td></tr><tr><td align="left">包来源</td><td align="left">主要从 Conda 渠道（如 conda-forge）安装</td><td align="left">从 Python Package Index (PyPI)安装</td></tr></tbody></table><p>一个重要的建议是：<strong>在同一个项目环境中，应优先使用 Conda 安装包</strong>。如果某个包在 Conda 渠道中找不到，再使用 pip 安装，这有助于减少潜在的依赖冲突。</p><h2 id="核心组件与工作流程"><a href="#核心组件与工作流程" class="headerlink" title="核心组件与工作流程"></a>核心组件与工作流程</h2><ul><li><p>Conda: 这是 Anaconda 的灵魂，是命令行工具的核心。你通过它执行创建环境、安装包等所有操作。</p></li><li><p>Anaconda Navigator: 这是一个图形化界面（GUI），为不习惯命令行的用户提供了直观的环境和应用程序管理方式。</p></li><li><p>工作流程: 典型的开发流程是：使用 <strong>conda create -n 环境名 python&#x3D;版本号创建新环境</strong> -&gt; 使用 <strong>conda activate 环境名激活环境</strong> -&gt; 在该环境下使用 <strong>conda install</strong>或 pip install安装所需包 -&gt; 开始开发工作。</p></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><p>虚拟环境是 Anaconda 的核心，它允许你为不同项目创建独立的、互不干扰的 Python 运行空间。</p><table><thead><tr><th align="left">操作</th><th align="left">命令</th><th align="left">备注&amp;示例</th></tr></thead><tbody><tr><td align="left">创建环境</td><td align="left">conda create -n 环境名 [python&#x3D;版本号] [包名]</td><td align="left">例如：conda create -n my_project python&#x3D;3.9 numpy pandas会创建一个名为 my_project、Python 版本为 3.9 并预安装 numpy 和 pandas 包的环境</td></tr><tr><td align="left">激活环境</td><td align="left">conda activate 环境名</td><td align="left">激活后，命令行的提示符前会显示当前环境名，如 (my_project)</td></tr><tr><td align="left">退出环境</td><td align="left">conda deactivate</td><td align="left">退出当前环境，回到基础（base）环境</td></tr><tr><td align="left">查看所有环境</td><td align="left">conda env list或 conda info –envs</td><td align="left">列表中带有 *号标识的为当前所在环境</td></tr><tr><td align="left">删除环境</td><td align="left">conda remove -n 环境名 –all</td><td align="left">这会彻底删除该环境及其中安装的所有包</td></tr><tr><td align="left">克隆环境</td><td align="left">conda create -n 新环境名 –clone 被克隆环境名</td><td align="left">快速复制一个完全相同的环境，适用于备份或创建相似环境</td></tr><tr><td align="left">导出环境</td><td align="left">conda env export –name 环境名 &gt; environment.yml</td><td align="left">将环境的详细配置（包括所有包的版本）导出到 YAML 文件，便于共享和复现</td></tr><tr><td align="left">导入环境</td><td align="left">conda env create -f environment.yml</td><td align="left">根据 YAML 文件快速创建一个一模一样的环境</td></tr></tbody></table><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><table><thead><tr><th align="left">操作</th><th align="left">命令</th><th align="left">备注&amp;示例</th></tr></thead><tbody><tr><td align="left">安装包</td><td align="left">conda install 包名[&#x3D;版本号]</td><td align="left">例如：conda install numpy&#x3D;1.21会安装指定版本的 numpy。可以同时安装多个包，用空格隔开</td></tr><tr><td align="left">从特定渠道安装</td><td align="left">conda install 包名 -c 渠道名</td><td align="left">例如从 conda-forge社区安装：conda install pkg_name -c conda_forge</td></tr><tr><td align="left">使用 pip 安装</td><td align="left">pip install 包名&#x3D;&#x3D;版本号</td><td align="left">当某个包无法通过 conda 安装时，可以使用 pip 作为补充。注意：建议在同一个环境中优先使用 conda，混合使用 conda 和 pip 可能导致依赖冲突</td></tr><tr><td align="left">查看已安装包</td><td align="left">conda list</td><td align="left">列出当前环境中所有已安装的包。</td></tr><tr><td align="left">搜索包</td><td align="left">conda search 搜索词</td><td align="left">查看可供安装的包版本。</td></tr><tr><td align="left">更新包</td><td align="left">conda update 包名</td><td align="left">更新单个包。使用 conda update –all可以更新环境中的所有包。</td></tr><tr><td align="left">卸载包</td><td align="left">conda remove 包名</td><td align="left">从当前环境中移除指定的包</td></tr></tbody></table><h3 id="配置与维护"><a href="#配置与维护" class="headerlink" title="配置与维护"></a>配置与维护</h3><table><thead><tr><th align="left">操作</th><th align="left">命令</th><th align="left">备注&amp;示例</th></tr></thead><tbody><tr><td align="left">查看 Conda 信息</td><td align="left">conda –version</td><td align="left">查看 Conda 版本</td></tr><tr><td align="left">更新 Conda</td><td align="left">conda update conda</td><td align="left">将 Conda 自身更新到最新版本</td></tr><tr><td align="left">配置镜像源</td><td align="left">添加：conda config –add channels 镜像地址</td><td align="left">为了提升下载速度，可以配置国内镜像源（如清华、中科大镜像）。添加后，建议执行 conda config –set show_channel_urls yes以便安装时显示包来源</td></tr><tr><td align="left">查看当前源</td><td align="left">conda config –get channels</td><td align="left">查看当前已配置的渠道（channels）列表</td></tr><tr><td align="left">恢复默认源</td><td align="left">conda config –remove-key channels</td><td align="left">移除所有添加的镜像源，恢复为 Anaconda 官方源</td></tr><tr><td align="left">清理缓存</td><td align="left">conda clean -pconda clean -tconda clean -y –all</td><td align="left">-p：删除无用的包。-t：删除 tar 打包文件。-y –all：清理所有安装包和缓存（索引缓存、锁定文件、未使用过的包和tar包）。这可以释放磁盘空间</td></tr></tbody></table><h2 id="使用流程建议"><a href="#使用流程建议" class="headerlink" title="使用流程建议"></a>使用流程建议</h2><ol><li><p>创建环境：为你的新项目创建一个指定 Python 版本的环境，例如 conda create -n my_analysis python&#x3D;3.11</p></li><li><p>激活环境：开始工作前，先激活它：conda activate my_analysis</p></li><li><p>安装依赖：在激活的环境中安装所需的包，例如 conda install pandas matplotlib jupyter</p></li><li><p>开展工作：在隔离的环境中进行编码、数据分析等</p></li><li><p>退出环境：工作完成后，使用 conda deactivate退出</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Anaconda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15-445(Bustub):课程学习笔记1</title>
    <link href="/2025/11/07/CMU15-445-Bustub-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2025/11/07/CMU15-445-Bustub-%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h2 id="课程第七讲：哈希表"><a href="#课程第七讲：哈希表" class="headerlink" title="课程第七讲：哈希表"></a>课程第七讲：哈希表</h2><h3 id="数据结构在DBMS中的角色"><a href="#数据结构在DBMS中的角色" class="headerlink" title="数据结构在DBMS中的角色"></a>数据结构在DBMS中的角色</h3><p>哈希表是DBMS内部使用的多种数据结构之一，主要用于：</p><ul><li><p><strong>内部元数据管理</strong>：如页表、页目录。</p></li><li><p><strong>核心数据存储</strong>：存储元组本身。</p></li><li><p><strong>临时数据结构</strong>：用于加速查询执行，如连接操作中的哈希表。</p></li><li><p><strong>表索引</strong>：帮助快速定位特定元组。</p></li></ul><p>设计数据结构时需考虑两个关键因素：<strong>数据组织</strong>（布局对性能的影响）和<strong>并发控制</strong>（多线程安全访问）。</p><h3 id="哈希表基础"><a href="#哈希表基础" class="headerlink" title="哈希表基础"></a>哈希表基础</h3><p>哈希表是一种将键映射到值的数据结构，提供平均O(1)时间复杂度的操作。它包含两个核心部分：</p><ul><li><p><strong>哈希函数</strong>：将键映射到较小范围的整数。关键是在<strong>速度</strong>和<strong>碰撞率</strong>之间取得平衡。推荐使用像Facebook XXHash3这样高速且低碰撞率的非加密哈希函数。</p></li><li><p><strong>哈希方案</strong>：定义如何处理哈希碰撞。</p></li></ul><h3 id="静态哈希方案"><a href="#静态哈希方案" class="headerlink" title="静态哈希方案"></a>静态哈希方案</h3><p>静态哈希表的大小是固定的。如果空间不足，需要昂贵地重建整个表（通常加倍大小）。</p><ul><li><p><strong>线性探测法</strong></p><ul><li><p><strong>原理</strong>：发生碰撞时，<strong>按顺序线性扫描后续的槽位，直到找到空位</strong>。</p></li><li><p><strong>操作</strong>：</p><ul><li><p><strong>插入</strong>：哈希后线性查找空位或墓碑标记的位置插入。</p></li><li><p><strong>查找</strong>：哈希后线性查找，直到找到键或遇到空位。</p></li><li><p><strong>删除</strong>：使用<strong>墓碑标记</strong>来避免破坏后续的查找链（墓碑标记这位被删除），这是最常用的方法。</p></li></ul></li><li><p><strong>特点</strong>：实现简单，通常最快。是许多现代实现（如Google的<code>absl::flat_hash_map</code>）的基础。</p></li></ul></li><li><p><strong>布谷鸟哈希法</strong><br>布谷鸟的含义：</p></li></ul><ol><li><p>布谷鸟妈妈从不筑巢，它将自己的鸟蛋生在其他鸟类的巢穴里，要别的鸟给它孵蛋</p></li><li><p><strong>新出生的布谷鸟会本能地将巢穴里的其他蛋踢开（kick out ）</strong>，<strong>推出鸟巢</strong>，以确保自己在鸟巢里可以独享宠爱</p><ul><li><p><strong>原理</strong>：使用<strong>多个哈希表</strong>（或同一表的不同哈希函数）。插入时检查所有表，选择有空位的表；若均满，则随机选择一个表，驱逐原有条目，并将原有条目重新哈希到另一个表中。</p></li><li><p><strong>特点</strong>：保证O(1)的查找和删除，但插入可能更昂贵，且在最坏情况下可能需要重建表。</p></li></ul></li></ol><h3 id="动态哈希方案"><a href="#动态哈希方案" class="headerlink" title="动态哈希方案"></a>动态哈希方案</h3><p>动态哈希表可以根据需要动态调整大小，而无需重建整个表。</p><img src="/img/CMU15-445-Bustub-project-课程学习笔记1/hash.jpg" alt="链式哈希" style="display: block; margin: 0 auto; width: 50%; height:50%;"><ul><li><p><strong>链式哈希</strong></p><ul><li><p><strong>原理</strong>：每个槽位维护一个桶的链表。哈希到同一槽位的所有键值对都存储在对应的链表中。</p></li><li><p><strong>特点</strong>：最常见、最简单的动态方案，但链表可能变得很长，影响性能。</p></li></ul></li></ul><p><a href="https://blog.csdn.net/MelroseLbt/article/details/129329316">可扩展哈希案例</a></p><ul><li><p><strong>可扩展哈希</strong></p><ul><li><p><strong>原理</strong>：核心概念是<strong>目录</strong>和<strong>桶</strong>，目录储存指向桶是指针。通过一个目录指针数组来指向桶。使用<strong>全局深度-目录</strong>和<strong>局部深度-桶</strong>来控制需要检查的比特位数。</p></li><li><p><strong>特点</strong>：当桶溢出时，<strong>只分裂溢出的桶</strong>，并可能<strong>倍增目录数组</strong>。优点是<strong>重哈希只涉及分裂的桶</strong>，而非整个表。</p></li><li><p><strong>查找</strong>：计算哈希值-&gt;截取低位（长度为全局深度）-&gt;定位目录页-&gt;访问目标桶-&gt;扫描目标桶</p></li></ul></li><li><p><strong>线性哈希</strong></p><ul><li><p><strong>原理</strong>：<strong>维护一个分裂指针，指向下一个要分裂的桶</strong>。当任何桶溢出时，并不立即分裂它，而是分裂指针当前所指的桶。通过<strong>增加新的哈希函数来逐步扩展表</strong>。</p></li><li><p><strong>特点</strong>：通过分裂指针的线性移动来实现平滑的扩展和收缩，避免了可扩展哈希中可能出现的集中式分裂。</p></li></ul></li></ul><h3 id="关键要点与对比"><a href="#关键要点与对比" class="headerlink" title="关键要点与对比"></a>关键要点与对比</h3><table><thead><tr><th align="left">特性</th><th align="left">静态哈希</th><th align="left">动态哈希</th></tr></thead><tbody><tr><td align="left"><strong>大小</strong></td><td align="left">固定，需预知数据量</td><td align="left">动态增长&#x2F;收缩</td></tr><tr><td align="left"><strong>扩容成本</strong></td><td align="left">高（需要重建整个表）</td><td align="left">低（局部调整）</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">数据量已知或变化不大</td><td align="left">数据量未知或变化频繁</td></tr></tbody></table><ul><li><p><strong>线性探测</strong>与<strong>链式哈希</strong>是两种最基础且广泛应用的方案，分别代表了开放寻址和链地址法两种思想。</p></li><li><p><strong>可扩展哈希</strong>和<strong>线性哈希</strong>是更复杂的动态方案，旨在减少扩容时的开销，分别适用于读优化和写优化的场景。</p></li></ul><p>哈希表是一种将键映射到值的数据结构，提供平均O(1)时间复杂度的操作。它包含两个核心部分：</p><ul><li><p><strong>哈希函数</strong>：将键映射到较小范围的整数。关键是在<strong>速度</strong>和<strong>碰撞率</strong>之间取得平衡。推荐使用像Facebook XXHash3这样高速且低碰撞率的非加密哈希函数。</p></li><li><p><strong>哈希方案</strong>：定义如何处理哈希碰撞。</p></li></ul><h2 id="课程第八讲：索引1"><a href="#课程第八讲：索引1" class="headerlink" title="课程第八讲：索引1"></a>课程第八讲：索引1</h2><h3 id="表索引"><a href="#表索引" class="headerlink" title="表索引"></a>表索引</h3><p>表索引是表中部分列的<strong>副本</strong>，这些列经过特殊组织或排序，旨在通过特定属性实现高效数据访问。它是避免全表顺序扫描、提升查询性能的关键技术</p><ul><li><p>作用：<strong>DBMS通过索引快速定位目标元组，并确保表数据与索引数据在逻辑上始终同步</strong>。</p></li><li><p>权衡：索引越多，查询可能越快，但会占用更多存储空间，增加维护开销（插入、删除、更新时需同步更新索引），并引入并发控制复杂度。DBMS的查询优化器负责选择最佳索引执行查询。</p></li></ul><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h3><img src="/img/CMU15-445-Bustub-project-课程学习笔记1/bTree.png" alt="3阶B Tree" style="display: block; margin: 0 auto; width: 50%; height:50%;"><p>B树（B-tree），全称平衡树（Balanced Tree），是一种自平衡的树数据结构，主要用于优化对磁盘等辅助存储设备的数据访问。与二叉查找树不同，B树的每个节点可以有多个子节点（通常为2到m个），从而显著降低了树的高度，减少了昂贵的磁盘I&#x2F;O操作次数，提高了数据检索效率。</p><ul><li>主要特点<ul><li>多路查找树: 每个节点可以存储多个键（key）和拥有多个子节点。</li><li>自平衡: 树结构始终保持平衡，确保所有叶子节点都位于同一深度（同一层），从而保证一致的查找时间。</li><li>减少磁盘I&#x2F;O: B树的设计考虑了磁盘读写是以数据块（block）为单位的特性，将相关数据尽量集中存储在同一个节点（对应一个或多个磁盘块）中，一次性读取，有效减少了磁盘访问次数。</li><li>有序性: 节点内的键值按升序排列，并且子节点中的值也遵循左小右大的规则。</li><li>高效操作: 搜索、插入和删除操作的时间复杂度均为对数时间 O(log n)，性能稳定。</li></ul></li></ul><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><img src="/img/CMU15-445-Bustub-project-课程学习笔记1/b+Tree.png" alt="3阶B+ Tree" style="display: block; margin: 0 auto; width: 50%; height:50%;"><p>B+Tree是一种自平衡树状数据结构，适用于磁盘导向的DBMS，支持在O(log(n))时间复杂度内进行搜索、顺序访问、插入和删除操作。它是现代DBMS中实现有序索引的事实标准。</p><ul><li>基本特性<ul><li><p>完美平衡：<strong>所有叶子节点位于同一深度</strong>。</p></li><li><p>半满约束：除根节点外，每个内部节点至少半满（键数在 M&#x2F;2 - 1到 M-1之间）。</p></li><li><p>键值对：每个节点包含一个键值对数组。</p></li><li><p>叶子节点：<strong>值只存于叶子节点</strong>。值可以是记录ID（指向元组位置的指针）或元组数据本身。</p></li><li><p>内部节点：值是指向其他节点的指针，键作为路标（guide posts）指导遍历。</p></li></ul></li></ul><p><strong>插入操作</strong><br>B+树中做插入关键字的操作，有以下 3 种情况:</p><ul><li><p><a href="https://pic4.zhimg.com/v2-386cefe3c3c93b726387ee2abc577691_b.webp">若被插入关键字所在的结点，其含有关键字数目小于阶数 M，则直接插入。</a></p></li><li><p><a href="https://pic1.zhimg.com/v2-4e621ab9044dcb42643066f6031226b0_b.webp">若被插入关键字所在的结点，其含有关键字数目等于阶数 M，则需要将该结点分裂为两个结点，一个结点包含 ⌊M&#x2F;2⌋ ，另一个结点包含 ⌈M&#x2F;2⌉ 。同时，将⌈M&#x2F;2⌉的关键字上移至其双亲结点。假设其双亲结点中包含的关键字个数小于 M，则插入操作完成。</a></p></li></ul><img src="/img/CMU15-445-Bustub-project-课程学习笔记1/b+Tree01.png" alt="3阶B+ Tree插入" style="display: block; margin: 0 auto; width: 50%; height:50%;"><ul><li><a href="https://pica.zhimg.com/v2-85fb69b1f6d5134f45808fc884ad2e4a_b.webp">若插入的关键字比当前结点中的最大值还大，破坏了B+树中从根结点到当前结点的所有索引值，此时需要及时修正后，再做其他操作。</a></li></ul><p><strong>删除操作</strong></p><ul><li><p><a href="https://pic3.zhimg.com/v2-7607b34265b14b3527101d53ce9c2b70_b.webp">找到存储有该关键字所在的结点时，由于该结点中关键字个数大于⌈M&#x2F;2⌉，做删除操作不会破坏 B+树，则可以直接删除。</a></p></li><li><p><a href="https://pic2.zhimg.com/v2-3aee225a4ba3e3a1b428e3f30e312637_b.webp">当删除某结点中最大或者最小的关键字，就会涉及到更改其双亲结点一直到根结点中所有索引值的更改。</a></p></li><li><p><a href="https://pic2.zhimg.com/v2-8dae05b8aa006d6d1fc6bb54c24169a5_b.webp">当删除该关键字，导致当前结点中关键字个数小于 ⌈M&#x2F;2⌉，若其兄弟结点中含有多余的关键字，可以从兄弟结点中借关键字完成删除操作。</a></p></li><li><p><a href="https://pic1.zhimg.com/v2-c33a70c8eaa38e96c3052a6bddc9d0d4_b.webp">第3种情况中，如果其兄弟结点没有多余的关键字，则需要同其兄弟结点进行合并。</a></p></li><li><p><a href="https://pic3.zhimg.com/v2-ae4011609fdf74e80d10fefb9e47dbb8_b.webp"> 当进行合并时，可能会产生因合并使其双亲结点破坏 B+树的结构，需要依照以上规律处理其双亲结点。</a></p></li></ul><p><strong>B树&amp;B+树 核心区别速览</strong></p><table><thead><tr><th align="left">特性</th><th align="left">B树</th><th align="left">B+树</th></tr></thead><tbody><tr><td align="left">数据存储位置</td><td align="left">所有节点（包括内部节点）都可能存储数据指针&#x2F;完整数据。</td><td align="left">仅叶子节点存储数据指针&#x2F;完整数据。内部节点只存储键（索引）。</td></tr><tr><td align="left">叶子节点连接</td><td align="left">叶子节点之间没有指针连接。</td><td align="left">所有叶子节点通过双向链表连接在一起。</td></tr><tr><td align="left">查找性能</td><td align="left">平均查找可能更快（可能在内部节点就命中）。</td><td align="left">任何查找都必须走到叶子节点，路径长度稳定。</td></tr><tr><td align="left">范围查询&#x2F;全表扫描</td><td align="left">效率低。需要进行复杂的中序遍历。</td><td align="left">效率极高。找到起始点后，沿链表顺序扫描即可。</td></tr><tr><td align="left">结构稳定性</td><td align="left">删除操作可能导致内部节点数据被移除，树结构变化更频繁。</td><td align="left">删除操作只在叶子节点进行，树结构更加稳定。</td></tr><tr><td align="left">空间利用率</td><td align="left">内部节点也存储数据，导致每个节点能容纳的键更少，树可能更高。</td><td align="left">内部节点只存键，能容纳更多键，树更矮胖，减少I&#x2F;O次数。</td></tr></tbody></table><h2 id="课程第九讲：索引2"><a href="#课程第九讲：索引2" class="headerlink" title="课程第九讲：索引2"></a>课程第九讲：索引2</h2><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器是一种概率型数据结构，<strong>用于快速判断一个元素是否不在某个集合中</strong>，从而避免不必要的查找开销。它<strong>使用一个位图和多个哈希函数</strong>。</p><ul><li><p><strong>工作原理</strong>：插入元素时，通过多个哈希函数计算其位置并将位图中对应位设为1。查询时，若所有哈希函数对应的位均为1，则元素可能存在（可能存在误判）；若有任一位为0，则元素肯定不存在。</p></li><li><p>特点：确保无假阴性，但可能存在假阳性。可通过调整位图大小和哈希函数数量控制误判率。</p></li><li><p>变种：</p><ul><li><p>计数布隆过滤器：支持删除操作。</p></li><li><p>布谷鸟过滤器：基于布谷鸟哈希，存储元素指纹。</p></li><li><p>简洁范围过滤器：不可变，支持范围查询。</p></li></ul></li></ul><img src="/img/CMU15-445-Bustub-project-课程学习笔记1/bloomFilter.png" alt="布隆过滤器" style="display: block; margin: 0 auto; width: 50%; height:50%;"><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>跳表是一种多层级有序链表，用于内存数据（如MemTable），支持快速查找、插入和删除，无需重新平衡。</p><ul><li><p>查找：从顶层链表开始遍历，当下一节点值大于目标值时，下降至下一层继续遍历，直至底层。</p></li><li><p>插入：<strong>通过抛硬币决定新节点的层级</strong>，并从底层向上逐层插入，通常通过原子指针交换实现无锁操作。</p></li><li><p>删除：先标记节点为已删除，待后续物理删除；删除顺序为自上而下，以保持结构完整性。</p></li><li><p>优缺点：</p><ul><li><p>优点：内存占用可能低于B+树（无反向指针），无需重新平衡。</p></li><li><p>缺点：对磁盘&#x2F;缓存不友好（局部性差），反向扫描实现复杂。</p></li></ul></li></ul><img src="/img/CMU15-445-Bustub-project-课程学习笔记1/skipList.png" alt="跳表" style="display: block; margin: 0 auto; width: 50%; height:50%;"><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>字典树是一种有序数据结构，将键按位（如字符或比特）拆分为前缀树，查询复杂度取决于键长。</p><ul><li><p>压缩技术：</p><ul><li><p>水平压缩：将节点压缩为数组（已知跨度时）。</p></li><li><p>垂直压缩（Radix树）：合并单分支节点，但可能导致假阳性（需验证实际数据）。</p></li></ul></li></ul><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>专用于<strong>关键词搜索</strong>（如全文检索），建立词项到包含该词项的记录列表（称为<strong>倒排列表</strong>）的映射。</p><ul><li><p>Lucene实现：使用类似字典树的有限状态转换器存储词项字典，通过边权重定位数据位置，并采用增量压缩、位打包等压缩技术。</p></li><li><p>PostgreSQL实现：基于B+树构建词项字典；小倒排列表用有序数组存储，大列表则用额外B+树管理。通过待处理列表积累小批量更新。</p></li></ul><p>来详细探讨倒排索引中的关键组件——有限状态转换器。<br>可以将其理解为一个经过高度优化的、确定性的字典树。与普通字典树不同的是，<strong>FST</strong>在存储和查询效率上做了重大改进：</p><ul><li>确定性：对于任意给定的输入词项，FST总会沿着唯一的一条路径进行转换。</li><li><strong>共享前缀与后缀</strong>：FST能够最大限度地压缩共享相同前缀和后缀的词项，显著减少内存占用。例如，单词 “sport” 和 “sports” 共享前缀 “sport”，FST会合并存储这个公共部分。</li><li><strong>输出值</strong>：FST的每条边（或每个状态转换）不仅可以接受一个输入字符，还可以产生一个输出值（通常是一个权重或<strong>偏移量</strong>）。在倒排索引的应用中，这些输出值最终会累积起来，指向词项对应的倒排列表在文件中的存储位置。</li></ul><img src="/img/CMU15-445-Bustub-project-课程学习笔记1/fst.png" alt="倒排索引--FST" style="display: block; margin: 0 auto; width: 50%; height:50%;"><p>如上图所示，当查询词项 “pav” 时，FST会沿着路径 p -&gt; a -&gt; v进行状态转换。在遍历过程中，路径上各边的输出值（权重）会被累加。这个最终的累加值（例如 3）可能就是 “pav” 这个词项其倒排列表在索引文件中的起始偏移量。</p><h3 id="向量索引"><a href="#向量索引" class="headerlink" title="向量索引"></a>向量索引</h3><p>用于语义相似性搜索（如基于LLM生成的嵌入向量），支持最近邻查询。</p><ul><li><p>倒排文件：通过聚类将向量分组，查询时搜索最近簇（如IVFFlat）。可结合量化技术降维加速。</p></li><li><p>可导航小世界：构建向量近邻图，通过贪婪遍历逼近查询向量（如FAISS、HNSWlib）。</p></li><li><p>挑战：查询结果无绝对正确性，且常需结合过滤条件。</p></li></ul><h2 id="课程第十讲：索引并发控制"><a href="#课程第十讲：索引并发控制" class="headerlink" title="课程第十讲：索引并发控制"></a>课程第十讲：索引并发控制</h2><h3 id="锁（locks）与门闩-latches-的区别"><a href="#锁（locks）与门闩-latches-的区别" class="headerlink" title="锁（locks）与门闩(latches)的区别"></a>锁（locks）与门闩(latches)的区别</h3><ul><li><p>锁(<strong>locks</strong>)：高级逻辑原语，保护数据库逻辑内容（如<strong>元组、表</strong>），事务会在其整个持续期间持有锁，系统有死锁检测和回滚机制。</p></li><li><p>门闩(<strong>latches</strong>)：低级保护原语，保护DBMS内部数据结构（如<strong>数据结构、内存区域</strong>），持有时间极短，由开发者负责避免死锁。门闩有两种模式：</p><ul><li><p>读门闩：允许多个线程同时获取。</p></li><li><p>写门闩：具有排他性，只允许一个线程获取。</p></li></ul></li></ul><h3 id="门闩的实现方式"><a href="#门闩的实现方式" class="headerlink" title="门闩的实现方式"></a>门闩的实现方式</h3><table><thead><tr><th align="left">实现方式</th><th align="left">描述</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">测试并设置自旋门闩</td><td align="left">基于CPU原子指令（如CAS，示例：std::atomic），线程在无法获取门闩时循环尝试或让出CPU。</td><td align="left">由DBMS控制，操作高效（单条指令）。</td><td align="left">高并发下不具扩展性，大量CAS指令导致缓存一致性风暴。</td></tr><tr><td align="left">阻塞式OS互斥锁</td><td align="left">直接使用操作系统提供的互斥锁（如std::mutex）。</td><td align="left">简单易用，无需额外编码。</td><td align="left">开销大，不可扩展（约25ns&#x2F;次），受OS调度影响。</td></tr><tr><td align="left">读写者门闩</td><td align="left">在基础门闩上增加逻辑，区分读&#x2F;写模式，管理等待队列（如std::shared_mutex）。</td><td align="left">允许并发读取，适合读多写少场景。</td><td align="left">需管理队列以防饥饿，元数据存储开销大于自旋门闩。</td></tr></tbody></table><ul><li><strong>std::atomic</strong>:硬件级别的原子性<ul><li>本质：是C++11引入的一个模板类，用于在多线程环境中对数据进行<strong>原子操作</strong>，确保线程安全，避免数据竞争。<strong>这意味着这些操作在一个线程中看起来是瞬间完成的，不会被其他线程的操作打断</strong>。</li><li>工作方式：它直接利用现代CPU的原子指令（如Compare-And-Swap, Fetch-And-Add）。例如，i++这个操作在非原子情况下是“读取-修改-写入”三步，可能被中断。而 atomic_int i; i++；则通过一条原子指令完成。</li><li>优点：速度最快，没有锁的争用和调度开销。</li><li>缺点：只能保护单个变量或非常简单的数据结构。无法保护一个需要多步更新才能保持逻辑一致性的代码块。例如，它无法保证“从链表A中取出一个节点，再放入链表B”这个过程的原子性。</li></ul></li></ul><p>简单示例：计数器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::atomic&lt;<span class="hljs-type">int</span>&gt; counter&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">// 要读取std::atomic变量的值，可以使用load函数</span><br>counter.<span class="hljs-built_in">load</span>();<br><span class="hljs-comment">// 要修改std::atomic变量的值，可以使用store函数</span><br>counter.<span class="hljs-built_in">store</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 多个线程同时执行是安全的</span><br>counter.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>);<br>counter.<span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><ul><li><p><strong>std::mutex</strong>：通用的互斥锁</p><ul><li><p>本质：<strong>互斥锁，用于保护临界区——一段需要独占访问的代码</strong>。线程在进入临界区前必须先锁定互斥锁，如果锁已被其他线程持有，则该线程会被阻塞（进入睡眠状态），直到锁被释放。</p></li><li><p>工作方式：当争用发生时，会涉及操作系统的调度，导致线程挂起和唤醒，这带来较大的性能开销。</p></li><li><p>优点：通用性强，可以保护任何复杂的代码段和数据结构。</p></li><li><p>缺点：性能开销大。即使没有实际争用，加锁解锁操作本身也有成本。并且，不区分读写操作，即使是只读操作也需要串行进行，在高并发读场景下效率低下。</p></li></ul></li></ul><p>简单示例：保护一个向量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; shared_data;<br>std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">safe_push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">// 锁定，离开作用域自动解锁</span><br>    shared_data.<span class="hljs-built_in">push_back</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>std::shared_mutex</strong>（C++17）：读写锁<ul><li><p>本质：是 std::mutex的增强版，引入了两种锁模式：</p><ul><li><p>共享锁：用于读取操作。多个线程可以同时获得共享锁。</p></li><li><p>独占锁：用于写入操作。一旦一个线程获得了独占锁，其他任何线程（无论是读还是写）都无法再获得锁。</p></li></ul></li><li><p>工作方式：<strong>当只有读者时，所有读者并行工作。一旦有写者申请锁，它会等待现有的所有读者完成，然后独占访问，并阻塞后续所有的读者和写者，直到写操作完成</strong>。</p></li><li><p>优点：在读多写少的场景下，极大地提高了程序的并行性和吞吐量。</p></li><li><p>缺点：实现比 std::mutex复杂，本身有稍大的开销。如果写操作频繁，由于写锁的排他性，性能可能反而不如简单的 std::mutex，因为需要管理更复杂的队列。</p></li></ul></li></ul><p>简单示例：保护一个配置表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::map&lt;std::string, <span class="hljs-type">int</span>&gt; config;<br>std::shared_mutex rw_mtx;<br><br><span class="hljs-comment">// 读操作：使用 shared_lock</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_config</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key)</span> </span>&#123;<br>    <span class="hljs-function">std::shared_lock <span class="hljs-title">lock</span><span class="hljs-params">(rw_mtx)</span></span>; <span class="hljs-comment">// 获取共享锁</span><br>    <span class="hljs-keyword">return</span> config[key];<br>&#125;<br><br><span class="hljs-comment">// 写操作：使用 unique_lock</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_config</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(rw_mtx)</span></span>; <span class="hljs-comment">// 获取独占锁</span><br>    config[key] = value;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="具体索引结构的并发控制"><a href="#具体索引结构的并发控制" class="headerlink" title="具体索引结构的并发控制"></a>具体索引结构的并发控制</h3><h4 id="哈希表的门闩控制"><a href="#哈希表的门闩控制" class="headerlink" title="哈希表的门闩控制"></a>哈希表的门闩控制</h4><ul><li><p>静态哈希表：并发控制简单，因为线程访问路径一致，不会出现死锁。调整大小时只需一个全局门闩。</p></li><li><p>动态哈希表：更复杂，但思路类似。</p></li><li><p>门闩粒度：</p><ul><li><p>页级门闩：每个页一个读写门闩。并行性较低，但单个线程访问同一页内多个槽时速度快。</p></li><li><p>槽级门闩：每个槽一个门闩。并行性高，但存储和计算开销大。可使用轻量自旋门闩平衡开销。</p></li><li><p>无门闩实现：可通过CAS指令直接构建无锁的线性探测哈希表。</p></li></ul></li></ul><h4 id="B-树的并发控制（重点与难点）"><a href="#B-树的并发控制（重点与难点）" class="headerlink" title="B+树的并发控制（重点与难点）"></a>B+树的并发控制（重点与难点）</h4><p>B+树并发的主要挑战是防止线程同时修改节点，以及防止遍历线程遇到正在分裂&#x2F;合并的节点。解决方案是门闩攀爬协议。</p><ul><li><p>基本门闩攀爬协议：</p><ul><li><p>核心思想：沿树向下遍历时，先锁住父节点，再锁住子节点。如果子节点是“安全”的，即可释放所有祖先节点的门闩。</p></li><li><p>安全节点定义：</p><ul><li><p>插入时：节点未满。</p></li><li><p>删除时：节点超过半满。</p></li></ul></li><li><p>操作流程：</p><ul><li><p>查找：使用读门闩，从根节点开始，层层攀爬（锁子节点，释放父节点）。</p></li><li><p>插入&#x2F;删除：使用写门闩，向下攀爬。遇到“安全”子节点后，释放所有祖先门闩。</p></li></ul></li></ul></li><li><p>改进的门闩攀爬协议：</p><ul><li><p>目的：解决基本协议中每次插入&#x2F;删除都需写锁根节点，限制并行性的问题。</p></li><li><p>方法：假设分裂&#x2F;合并罕见，事务先使用读门闩（如同查找操作）到达叶子节点。然后尝试获取叶子节点的写门闩。</p></li><li><p>验证：若叶子节点是“安全”的，则直接操作。</p></li><li><p>重试：若叶子节点“不安全”，则释放所有门闩，重启事务并使用基本协议（从头获取写门闩）来执行。</p></li></ul></li><li><p>叶子节点扫描与死锁：</p><ul><li><p>门闩攀爬（自上而下）本身不会产生死锁。</p></li><li><p>但叶子节点扫描（横向遍历）可能引发死锁，因为线程可能从两个方向同时请求排他门闩。</p></li><li><p>解决方案：编码时采用 “不等待”模式。若无法立即获取兄弟节点的门闩，则操作应中止并重启，而不是等待。这需要由更高层次的系统调度器来处理高竞争场景。</p></li></ul></li></ul><h4 id="蟹行协议"><a href="#蟹行协议" class="headerlink" title="蟹行协议"></a>蟹行协议</h4><p>蟹行协议是一种基于锁的悲观并发控制方法。它的核心思想是：<strong>在向下遍历树的过程中，先获取子节点的锁，然后再释放父节点的锁</strong>。就像螃蟹走路一样，一只钳子（锁）先抓住前方，后面的钳子（锁）才松开。</p><p><strong>核心规则</strong>：</p><ol><li>搜索操作：</li></ol><ul><li><p>从根节点开始，对其加<strong>共享锁</strong>。</p></li><li><p>到正确的子节点后，对子节点加<strong>共享锁</strong>。</p></li><li><p>释放父节点（根节点）的锁。</p></li><li><p>重复此过程，直到叶子节点。这样，搜索路径上总是至少持有一个锁，防止遍历过程中树结构被修改</p></li></ul><ol><li>插入&#x2F;删除操作：</li></ol><ul><li>前半部分与搜索类似，但使用<strong>互斥锁</strong>：对父节点加互斥锁，然后对子节点加互斥锁，释放父节点，继续向下。</li><li>关键点：当线程到达叶子节点并加互斥锁后，它需要检查是否会触发结构修改（如分裂或合并）。</li><li>安全检查：如果不会触发（例如，插入后叶子节点仍有空间），则直接操作，释放锁。</li><li>如果会触发（最复杂的情况）：线程必须从根节点开始重新遍历，但这次在向下过程中，它对可能需要进行结构修改的所有路径上的节点都持有互斥锁。这确保了在修改叶子节点并向上递归分裂的过程中，没有其他线程能干扰这条路径。</li></ul><h4 id="B-Link-Tree-协议"><a href="#B-Link-Tree-协议" class="headerlink" title="B-Link Tree 协议"></a>B-Link Tree 协议</h4><p>B-Link Tree是对B+树的一种改进，它采用了更乐观的、锁耦合程度更低的方法。它通过在每个节点中增加一个“指向右兄弟节点”的指针（即 Link 指针）来避免在插入&#x2F;删除时长期持有高层节点的锁。</p><p><strong>核心设计</strong>：</p><ul><li><p>节点结构变化：每个节点包含一个 high-key（当前子树的最大键）和一个 pointer-to-next-right-sibling（指向右兄弟的指针）。</p></li><li><p>搜索优化：如果搜索时在当前节点找不到键，并且键值大于节点的 high-key，说明它可能被分裂到了右边的兄弟节点，于是顺着 Link 指针向右查找。这允许搜索操作在无需锁保护的情况下应对并发的分裂。</p></li></ul><p><strong>总结对比</strong></p><table><thead><tr><th align="left">特性</th><th align="left">蟹行协议</th><th align="left">B-Link Tree 协议</th></tr></thead><tbody><tr><td align="left">哲学</td><td align="left">悲观：假设冲突会发生，通过锁提前预</td><td align="left">防乐观：假设冲突不常发生，发生时再解决</td></tr><tr><td align="left">读操作</td><td align="left">需要获取共享锁</td><td align="left">完全无锁，性能极高</td></tr><tr><td align="left">写操作</td><td align="left">锁粒度大，可能需要重新遍历并锁定整条路径</td><td align="left">锁粒度小（仅叶子节点），操作局部化</td></tr><tr><td align="left">复杂度</td><td align="left">相对简单，易于理解</td><td align="left">实现复杂，需要处理链接指针和边界条件性能锁竞争可能成为瓶颈在高并发读场景下性能优异</td></tr></tbody></table><h2 id="第十一讲：排序与聚合算法"><a href="#第十一讲：排序与聚合算法" class="headerlink" title="第十一讲：排序与聚合算法"></a>第十一讲：排序与聚合算法</h2><h3 id="查询计划（query-plan）"><a href="#查询计划（query-plan）" class="headerlink" title="查询计划（query plan）"></a>查询计划（query plan）</h3><p>数据库系统将 SQL 编译成查询计划。<strong>查询计划是一棵操作符树</strong>。</p><p>对于面向磁盘的数据库系统，将使用缓冲池来实现需要溢出到磁盘的算法。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>数据库管理系统需要对数据进行排序，因为在关系模型中，表中的元组没有特定的顺序。排序（可能）用于 ORDER BY、GROUP BY、JOIN 和 DISTINCT 运算符中。</p><ul><li>如果需要排序的数据适合内存，那么数据库管理系统可以使用标准排序算法（例如<strong>快速排序</strong>）。</li><li>如果数据不适合内存，那么数据库管理系统需要使用<strong>外部排序</strong>，该排序能够根据需要溢出到磁盘，并倾向于顺序 I&#x2F;O 而不是随机 I&#x2F;O。</li></ul><h4 id="Top-N-堆排序"><a href="#Top-N-堆排序" class="headerlink" title="Top-N 堆排序"></a>Top-N 堆排序</h4><p><strong>一、概念</strong></p><p><strong>Top-N 堆排序</strong> 是一种用于快速找出数据集中<strong>最大或最小的 N 个元素的算法</strong>。它的核心思想是：</p><ul><li><p><strong>不需要</strong> 对全部数据进行完整的排序。</p></li><li><p>只需要在内存中维护一个大小为 <strong>N</strong> 的数据结构（通常是 <strong>堆</strong>，即优先级队列），通过单次扫描数据，不断更新这个结构，最终得到 Top-N 的结果。</p></li></ul><p><strong>二、原理</strong></p><p>数据库在处理类似 <code>SELECT ... FROM ... ORDER BY score DESC LIMIT N;</code> 的查询时，会使用此算法。</p><p><strong>数据结构：堆</strong></p><ul><li><p><strong>最大堆</strong>：堆顶元素是堆中最大的。用于快速获取最大值。</p></li><li><p><strong>最小堆</strong>：堆顶元素是堆中最小的。用于快速获取最小值。</p></li></ul><p><strong>关键选择：使用哪种堆取决于我们要找的是最大的 N 个还是最小的 N 个。</strong></p><p><strong>算法步骤</strong>（以查找 <strong>最大的 N 个元素</strong> 为例）</p><p>这种情况下，我们使用一个 <strong>最小堆</strong>。</p><ol><li><p><strong>初始化</strong>：创建一个空的、大小为 N 的最小堆。</p></li><li><p><strong>首次填充</strong>：从数据源（表扫描）中读取前 N 个元组，并将它们全部插入最小堆。此时，堆顶元素是这 N 个元素中最小的，也就是当前看到的“第 N 大”的候选者。</p></li><li><p><strong>扫描与比较</strong>：继续扫描剩余的每一个元组。</p><ul><li><p>将当前元组的排序键（如 <code>score</code>）与堆顶元素进行比较。</p></li><li><p><strong>如果当前元组比堆顶元素更小（或等于）</strong>：说明它不可能进入最大的 N 个之列，直接丢弃。</p></li><li><p><strong>如果当前元组比堆顶元素更大</strong>：说明它应该进入 Top-N。此时我们：</p><p>  a. 将当前的堆顶元素（当前最小的 Top-N 元素）移除。</p><p>  b. 将新的、更大的元组插入堆中。</p><p>  c. 堆会重新调整结构，新的堆顶元素会成为新的“门槛”（即新的“第 N 大”的候选者）。</p></li></ul></li><li><p><strong>最终结果</strong>：当整个表扫描完毕后，堆中剩下的 N 个元素就是整个数据集中最大的 N 个元素。</p></li><li><p><strong>输出</strong>：如果需要按从大到小输出，可以将堆中的元素依次弹出（或反向排序）。</p></li></ol><p><strong>为什么使用最小堆？</strong></p><p>因为最小堆的堆顶是“守门员”，它代表了当前 Top-N 集合中的最小值。任何新来的元素，只有能打败这个“守门员”，才有资格进入集合。这保证了集合中始终是迄今为止看到的最大的 N 个元素。</p><p><strong>（反之亦然）</strong>：如果要找 <strong>最小的 N 个元素</strong>，则需要使用一个 <strong>最大堆</strong>。堆顶是当前 Top-N 集合中的最大值，作为“门槛”。新元素只有比这个门槛更小，才能进入。</p><p><strong>三、优势</strong></p><ul><li><p><strong>极低的内存占用</strong>：内存中只需要维护一个大小为 N 的堆。只要 N 不大，整个操作可以在内存中完成，完全避免了昂贵的磁盘溢出（Spill to Disk）。</p></li><li><p><strong>高效的时间复杂度</strong>：</p><ul><li><p>构建初始堆：<code>O(N)</code></p></li><li><p>处理剩余每个元素（最坏情况）：<code>O((M-N) * log N)</code>，其中 M 是总元组数。</p></li><li><p>总复杂度约为 <code>O(M log N)</code>，这比全排序的 <code>O(M log M)</code> 要高效得多，尤其是当 M 远大于 N 时（这是最常见的情况）。</p></li></ul></li><li><p><strong>I&#x2F;O 优势</strong>：只需要对数据进行 <strong>单次顺序扫描</strong>，这对磁盘I&#x2F;O非常友好。</p></li></ul><h4 id="外部归并排序"><a href="#外部归并排序" class="headerlink" title="外部归并排序"></a>外部归并排序</h4><p>外部归并排序是数据库系统中处理无法一次性装入内存的大数据集排序问题的核心算法。<br><a href="https://www.bilibili.com/video/BV1V94y1q7cC/?spm_id_from=333.337.search-card.all.click">外部归并排序</a></p><p><strong>一、基本概念</strong></p><p><strong>问题背景</strong></p><ul><li><p><strong>内存限制</strong>：当需要排序的数据量远大于可用内存时，无法使用快速排序等内存排序算法</p></li><li><p><strong>磁盘I&#x2F;O特性</strong>：磁盘顺序读写远快于随机读写，算法设计要最大化顺序I&#x2F;O</p></li><li><p><strong>缓冲区管理</strong>：数据库有固定数量的缓冲页（如B个），算法需要在此约束下工作</p></li></ul><p><strong>核心思想</strong></p><p><strong>分而治之</strong>：将大数据集分解为能放入内存的小块，分别排序后再合并。</p><p><strong>二、算法原理与步骤</strong></p><p><strong>两阶段设计</strong></p><p><strong>阶段1：排序阶段</strong></p><ol><li><p><strong>分块读取</strong>：每次从磁盘读取恰好能填满内存缓冲区的数据页（B页）</p></li><li><p><strong>内部排序</strong>：在内存中使用快速排序等算法对这批数据排序</p></li><li><p><strong>写入运行</strong>：将排序后的数据作为一个<strong>有序运行</strong>写回磁盘</p></li><li><p><strong>重复</strong>：直到所有数据都被处理完，生成M个有序的运行文件</p></li></ol><p><strong>关键点</strong>：每个运行内部有序，但运行之间无序。</p><p><strong>阶段2：合并阶段</strong></p><ol><li><p><strong>多路合并</strong>：同时从K个运行中各读入一页到内存缓冲区</p></li><li><p><strong>归并比较</strong>：比较各缓冲区的当前最小元素，选择最小的输出</p></li><li><p><strong>缓冲区管理</strong>：某个缓冲区的数据用完后，从对应运行读入下一页</p></li><li><p><strong>生成新运行</strong>：合并结果写回磁盘，形成更大的有序运行</p></li><li><p><strong>递归合并</strong>：重复此过程，直到所有数据合并成一个完整有序数据集</p></li></ol><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>查询计划中的聚合操作符将一个或多个元组的值聚合成单个标量值。实现聚合有两种方法：(1) 排序和 (2) 哈希。</p><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p>数据库管理系统（DBMS）首先根据 GROUP BY 键对元组进行排序。如果所有数据都能适应缓冲池（例如，快速排序），则可以使用内存中的排序算法；如果数据量超过内存，则使用外部归并排序算法。DBMS 随后对排序后的数据进行顺序扫描以计算聚合。该操作器的输出将按键排序。</p><p>在进行排序聚合时，重要的是对查询操作进行排序以最大化效率。例如，如果查询需要过滤，最好先执行过滤，然后再对过滤后的数据进行排序，以减少需要排序的数据量。</p><img src="/img/CMU15-445-Bustub-project-课程学习笔记1/sort.png" alt="排序聚合" style="display: block; margin: 0 auto; width: 50%; height:50%;"><h4 id="哈希-散列"><a href="#哈希-散列" class="headerlink" title="哈希(散列)"></a>哈希(散列)</h4><p>对于计算聚合而言，哈希的效率可能比排序更高，尤其是在输出顺序不重要的情况下。数据库管理系统（DBMS）在扫描表时会动态生成一个临时哈希表。对于每条记录，检查哈希表中是否已存在条目，并执行相应的修改。如果哈希表的大小超出内存容量，DBMS 需要将其溢写到磁盘上。当数据不适合内存时，通常采用分治策略来计算聚合，这个过程包含两个阶段：</p><ul><li><strong>处理大数据（外部哈希聚合）</strong>：当哈希表太大无法放入内存时，采用两阶段法：<ul><li><strong>阶段1：分区</strong>：使用哈希函数 <strong>h1</strong> 将元组分割到磁盘上的多个分区中。保证同一组的元组进入同一分区。</li><li><strong>阶段2：重哈希</strong>：对于每个分区，将其读入内存，并使用另一个哈希函数 <strong>h2</strong> 构建一个内存哈希表。然后在这个哈希表内计算每个分组的聚合值。此阶段假设每个分区都能放入内存。</li></ul></li></ul><img src="/img/CMU15-445-Bustub-project-课程学习笔记1/hash1.png" alt="哈希聚合1" style="display: block; margin: 0 auto; width: 50%; height:50%;"><img src="/img/CMU15-445-Bustub-project-课程学习笔记1/hash2.png" alt="哈希聚合2" style="display: block; margin: 0 auto; width: 50%; height:50%;"><h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table><thead><tr><th align="left">特性</th><th align="left">排序法</th><th align="left">哈希法</th></tr></thead><tbody><tr><td align="left"><strong>输出</strong></td><td align="left">结果有序</td><td align="left">结果无序</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">数据已排序或需要有序输出时</td><td align="left">默认选择，尤其当顺序不重要时</td></tr><tr><td align="left"><strong>大数据处理</strong></td><td align="left">外部归并排序</td><td align="left">外部哈希聚合（分区+重哈希）</td></tr><tr><td align="left"><strong>一般效率</strong></td><td align="left">通常比哈希法慢</td><td align="left"><strong>通常更高效</strong>，除非数据已预先排序</td></tr></tbody></table><p>总而言之，这份文档详细阐述了数据库在执行查询时，如何在受限的内存条件下，通过精巧的算法设计（主要是外部归并排序和外部哈希聚合）高效地完成排序和聚合任务。</p><p>下面是一份<strong>根据你提供的 PDF 内容整理的 Markdown（MD）格式笔记</strong>。<br>内容经过结构化整理，但<strong>不会改变原始内容含义</strong>，你可以直接复制到你的编辑器中使用。</p><h2 id="第十二讲：连接"><a href="#第十二讲：连接" class="headerlink" title="第十二讲：连接"></a>第十二讲：连接</h2><p>数据库设计的目标之一：<strong>减少重复信息</strong>。<br>因此使用规范化理论将数据拆分为多个表，查询时需要通过 <strong>JOIN</strong> 恢复原始数据。</p><p>本节主要关注 <strong>inner equijoin（等值内连接）</strong> 的实现算法。<br>在执行 join 时通常让 <strong>较小的表作为 outer table</strong>（外表）。<br>多路 join（multi-way joins）主要出现在研究领域（如 WCOJ）。</p><h3 id="Join-Operators"><a href="#Join-Operators" class="headerlink" title="Join Operators"></a>Join Operators</h3><p>查询计划是一个<strong>自底向上的树结构</strong>, join 输出是连接两个匹配元组。</p><img src="/img/CMU15-445-Bustub-project-课程学习笔记1/joinOperator.png" alt="树结构" style="display: block; margin: 0 auto; width: 30%; height:30%;"><h3 id="Join-输出方式"><a href="#Join-输出方式" class="headerlink" title="Join 输出方式"></a>Join 输出方式</h3><p>DBMS 设计 join 输出时有两种主要策略：</p><h4 id="早物化（Early-Materialization）"><a href="#早物化（Early-Materialization）" class="headerlink" title="早物化（Early Materialization）"></a>早物化（Early Materialization）</h4><ul><li>将 outer 与 inner 中需要的所有属性复制到中间结果。</li><li>优点：后续操作无需再次访问底表。</li><li>缺点：需要更多内存。</li></ul><h4 id="晚物化（Late-Materialization）"><a href="#晚物化（Late-Materialization）" class="headerlink" title="晚物化（Late Materialization）"></a>晚物化（Late Materialization）</h4><ul><li>只复制 join key 和 record ids。</li><li>特别适合 <strong>列存储（column store）</strong>。</li></ul><blockquote><p>现实中 DBMS 往往混合使用早物化与晚物化。</p></blockquote><h3 id="Cost-Model（成本模型）"><a href="#Cost-Model（成本模型）" class="headerlink" title="Cost Model（成本模型）"></a>Cost Model（成本模型）</h3><p>I&#x2F;O 是最主要的成本（忽略计算与网络代价）。<br>成本包含：</p><ul><li>从磁盘读取页面</li><li>写出中间结果</li></ul><p>不包含：</p><ul><li>输出最终结果的 I&#x2F;O（不同算法输出一致，相互没差别）</li></ul><p>假设：</p><ul><li>R（outer table）有 M pages，m tuples</li><li>S（inner table）有 N pages，n tuples</li></ul><p>JOIN 通常是自然连接：R ▷◁ S。</p><h3 id="Nested-Loop-Join（嵌套循环连接）"><a href="#Nested-Loop-Join（嵌套循环连接）" class="headerlink" title="Nested Loop Join（嵌套循环连接）"></a>Nested Loop Join（嵌套循环连接）</h3><p>最基本的想法：双层循环比较所有元组。</p><h4 id="Naive-Nested-Loop-Join"><a href="#Naive-Nested-Loop-Join" class="headerlink" title="Naive Nested Loop Join"></a>Naive Nested Loop Join</h4><p>对 outer 中每一个元组，扫描 inner 全表。</p><p><strong>Cost:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">M + (m × <span class="hljs-built_in">N</span>)<br></code></pre></td></tr></table></figure><h4 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested Loop Join"></a>Block Nested Loop Join</h4><p>按 block 处理，而不是单个 tuple。</p><p>如果 buffer 有 B 页可用：</p><ul><li>B-2 页用于 outer</li><li>1 页用于 inner</li><li>1 页用于结果输出</li></ul><p><strong>Cost:</strong></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">M + (<span class="hljs-name">ceil</span>(<span class="hljs-name">M</span> / (<span class="hljs-name">B-2</span>)) × N)<br></code></pre></td></tr></table></figure><h4 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested Loop Join"></a>Index Nested Loop Join</h4><p>如果 inner table 上有 join key 的索引：</p><ul><li>outer 无索引</li><li>inner 有索引（或临时构建）</li></ul><p>每个元组进行索引 probe，成本为 C。</p><p><strong>Cost:</strong></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">M + (<span class="hljs-name">m</span> × C)<br></code></pre></td></tr></table></figure><p>索引 greatly reduces cost。</p><h3 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort-Merge Join"></a>Sort-Merge Join</h3><p>流程：</p><ol><li>对 R 与 S 按 join key 排序（常用外部归并排序）</li><li>像 merge sort 一样线性扫描两个表进行匹配</li></ol><p>优势：</p><ul><li>如果已有 clustered index，则无需排序</li><li>或者结果本身需要按 join key 排序</li></ul><p>代价（假设 B 页 buffer）：</p><ul><li>排序成本（R）：</li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-number">2</span><span class="hljs-variable">M</span> × (<span class="hljs-number">1</span> + <span class="hljs-function"><span class="hljs-title">ceil</span>(<span class="hljs-variable">log_</span>&#123;<span class="hljs-variable">B</span>-<span class="hljs-number">1</span>&#125;(<span class="hljs-title">ceil</span>(<span class="hljs-variable">M</span> / <span class="hljs-variable">B</span>))))</span><br></code></pre></td></tr></table></figure><ul><li>排序成本（S）：</li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-number">2</span><span class="hljs-variable">N</span> × (<span class="hljs-number">1</span> + <span class="hljs-function"><span class="hljs-title">ceil</span>(<span class="hljs-variable">log_</span>&#123;<span class="hljs-variable">B</span>-<span class="hljs-number">1</span>&#125;(<span class="hljs-title">ceil</span>(<span class="hljs-variable">N</span> / <span class="hljs-variable">B</span>))))</span><br></code></pre></td></tr></table></figure><ul><li>merge 成本：<code>M + N</code></li></ul><h3 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h3><p>hash join 使用哈希函数将元组组织成多个桶，当 join key 相等时，必然落入同一个桶。</p><p>适用范围：<strong>等值连接(equi-join)</strong>。</p><h4 id="Basic-Hash-Join"><a href="#Basic-Hash-Join" class="headerlink" title="Basic Hash Join"></a>Basic Hash Join</h4><h5 id="Phase-1：Build"><a href="#Phase-1：Build" class="headerlink" title="Phase 1：Build"></a>Phase 1：Build</h5><ul><li>使用 outer 建立哈希表（h1）</li></ul><h5 id="Phase-2：Probe"><a href="#Phase-2：Probe" class="headerlink" title="Phase 2：Probe"></a>Phase 2：Probe</h5><ul><li>对 inner 使用相同 h1 并查找对应记录</li></ul><p>优化：<br>可在 build 阶段构建 <strong>Bloom Filter</strong> 避免不必要的 I&#x2F;O。</p><h4 id="Grace-Hash-Join-（分区哈希连接）"><a href="#Grace-Hash-Join-（分区哈希连接）" class="headerlink" title="Grace Hash Join （分区哈希连接）"></a>Grace Hash Join （分区哈希连接）</h4><p>适合数据放不进内存的情况。</p><h5 id="Phase-1：Partition"><a href="#Phase-1：Partition" class="headerlink" title="Phase 1：Partition"></a>Phase 1：Partition</h5><ul><li>outer 和 inner 都按 h1 分区</li><li>分区写回磁盘（必要时递归分区）</li></ul><h5 id="Phase-2：Probe-1"><a href="#Phase-2：Probe-1" class="headerlink" title="Phase 2：Probe"></a>Phase 2：Probe</h5><ul><li>对每个分区执行嵌套循环连接（小规模，因此是 in-memory）</li></ul><p><strong>Cost:</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Partition</span><span class="hljs-operator">:</span> <span class="hljs-number">2</span> × <span class="hljs-punctuation">(</span><span class="hljs-variable">M</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><br><span class="hljs-variable">Probe</span><span class="hljs-operator">:</span>     <span class="hljs-variable">M</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">N</span><br><span class="hljs-built_in">Total</span><span class="hljs-operator">:</span>     <span class="hljs-number">3</span> × <span class="hljs-punctuation">(</span><span class="hljs-variable">M</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>矩阵倾斜（skew）情况下可采用 Hybrid Hash Join，但难以实现。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>不同 join 算法性能总结：</p><table><thead><tr><th>Algorithm</th><th>Cost</th><th>Example Time</th></tr></thead><tbody><tr><td>Simple Nested Loop</td><td>M + m·N</td><td>1.4h</td></tr><tr><td>Block Nested Loop</td><td>M + (M·N)</td><td>50s</td></tr><tr><td>Index Nested Loop</td><td>M + m·C</td><td>depends</td></tr><tr><td>Sort-Merge Join</td><td>M + N + sort cost</td><td>0.75s</td></tr><tr><td>Hash Join</td><td>3(M+N)</td><td>0.45s</td></tr></tbody></table><p>结论：</p><ul><li><p>Hash Join 通常最快</p></li><li><p>Sort-Merge 在以下情况更好：</p><ul><li>key 分布不均匀</li><li>数据已排序</li><li>输出需要排序</li></ul></li><li><p>DBMS 通常会动态选择排序或哈希 join</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CMU15-445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Bustub</tag>
      
      <tag>B+Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15-445(Bustub):project1实现笔记</title>
    <link href="/2025/09/04/CMU15-445-Bustub-project1%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/09/04/CMU15-445-Bustub-project1%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库储存原理"><a href="#数据库储存原理" class="headerlink" title="数据库储存原理"></a>数据库储存原理</h2><p>如今储存设备可以大致分为<strong>易失性设备</strong>和<strong>非易失性设备</strong>：</p><ol><li>易失性设备(Volatile Devices)​​:</li></ol><ul><li>断电后数据丢失</li><li>支持快速随机访问，字节寻址</li><li>在本课程中统称为”内存”</li></ul><ol start="2"><li>非易失性设备(Non-Volatile Devices)​​:</li></ol><ul><li>断电后数据保留</li><li>块&#x2F;页寻址(通常4KB)</li><li>更适合顺序访问</li><li>在本课程中统称为”磁盘”(包括SSD和HDD)</li></ul><p>本课程实现的Bustub数据库是<strong>磁盘导向的DBMS</strong>：</p><ul><li>数据库全部存储在磁盘上</li><li>数据组织为页(page)</li><li>通过缓冲池(buffer pool)管理数据在磁盘和内存间的移动</li><li>执行引擎通过缓冲池获取特定页进行操作</li></ul><img src="/img/CMU15-445-Bustub-project1实现笔记/interactionProcessesDBMS.png" alt="关键交互流程（DBMS视角）" style="display: block; margin: 0 auto; width: 70%; height:70%;"><h3 id="日志结构存储"><a href="#日志结构存储" class="headerlink" title="日志结构存储"></a>日志结构存储</h3><p>日志结构合并树(Log-Structured Merge-Tree,<strong>LSM-Tree</strong>)是一种高性能的磁盘存储数据结构，专门为​​写入密集型​​工作负载设计，广泛应用于现代数据库系统如LevelDB、RocksDB、Cassandra等。<br>它的设计理念是<strong>将随机写入转化为顺序写入</strong>，以提高写入性能。因为在传统的磁盘存储中，顺序写入的速度要比随机写入快得多。</p><h4 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h4><ul><li><strong>MemTable（内存表）</strong>：这是 LSM - Tree 存储结构的最上层。新的数据首先会被写入到 MemTable 中。MemTable 通常是一个基于内存的有序数据结构，比如红黑树或者跳表。</li><li><strong>SSTables（Sorted String Tables）</strong>：当 MemTable 达到一定的大小后，其数据会被刷新（flush）到磁盘上的 SSTables。SSTables 是存储在磁盘中的有序键值对集合，其内部的数据是按照键（key）进行排序的。SSTables 并不是单个的大文件，而是一系列的文件，每个文件都有自己的范围（key 的区间）。例如，在一个存储用户信息的数据库中，可能会有一个 SSTable 负责存储姓名以 A - F 开头的用户信息，另一个 SSTable 存储姓名以 G - L 开头的用户信息等。</li></ul><img src="/img/CMU15-445-Bustub-project1实现笔记/LogStructuredStorage.png" alt="日志结构存储" style="display: block; margin: 0 auto; width: 70%; height:70%;"><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>不直接存储元组，而是存储变更日志记录</li><li>先在内存数据结构(MemTable)中应用变更</li><li>然后顺序写入磁盘(SSTable)</li><li>记录包含：元组唯一ID、操作类型(PUT&#x2F;DELETE)、元组内容(对于PUT)</li></ul><h3 id="索引组织存储"><a href="#索引组织存储" class="headerlink" title="索引组织存储"></a>索引组织存储</h3><p>索引组织存储(IOS, Index-Organized Storage)是一种将​<strong>​表数据直接存储在索引结构​</strong>​中的数据库存储方式，与传统堆文件(Heap File)存储形成鲜明对比。常用索引结构为<strong>B+树</strong>。</p><img src="/img/CMU15-445-Bustub-project1实现笔记/IOS.png" alt="与传统堆文件对比" style="display: block; margin: 0 auto; width: 60%; height:60%;"><h2 id="Bustub的缓存池结构"><a href="#Bustub的缓存池结构" class="headerlink" title="Bustub的缓存池结构"></a>Bustub的缓存池结构</h2><p><img src="/img/CMU15-445-Bustub-project1%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/bpm.png" alt="缓冲池管理"></p><ul><li><strong>page对象</strong>：内存中的页表示，包含脏位标记</li><li><strong>​​LRU-K替换器</strong>：改进的LRU算法，考虑最近K次访问历史，用于刷新不常用的内存页</li></ul><h2 id="Project-1"><a href="#Project-1" class="headerlink" title="Project #1"></a>Project #1</h2><p>实验一是要实现一个缓存池管理器，主要包括三个程序，分别是：</p><ul><li>LRU-K更新策略</li><li>磁盘管理</li><li>缓存池管理</li></ul><p><a href="https://15445.courses.cs.cmu.edu/fall2024/project1/">要完成的任务详情</a></p><h3 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task #1 - LRU-K Replacement Policy"></a>Task #1 - LRU-K Replacement Policy</h3><p><strong>​LRU-K​​</strong>（Least Recently Used-K）是传统LRU算法的改进版本，通过记录最近K次访问的历史信息，更准确地判断数据的”冷热”程度，从而减少缓冲池的”缓存污染”问题。</p><img src="/img/CMU15-445-Bustub-project1实现笔记/LRU_K.png" alt="LRU-K算法" style="display: block; margin: 0 auto; width: 50%; height:50%;"><p><strong>1) 以下为LRU—K算法的工作流程</strong></p><p>记录各个frame的访问次数</p><img src="/img/CMU15-445-Bustub-project1实现笔记/LRURecordAccess.png" alt="记录访问" style="display: block; margin: 0 auto; width: 70%; height:70%;"><p>驱逐访问距离大于等于K的一个frame</p><img src="/img/CMU15-445-Bustub-project1实现笔记/LRUEvict.png" alt="淘汰界面" style="display: block; margin: 0 auto; width: 50%; height:50%;"><p><strong>2) LRUKNode和LRUKReplacer</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUKNode</span> &#123;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/** History of last seen K timestamps of this page. Least recent timestamp stored in front. */</span><br>  <span class="hljs-comment">// Remove maybe_unused if you start using them. Feel free to change the member variables as you want.</span><br><br>  [[maybe_unused]] std::list&lt;<span class="hljs-type">size_t</span>&gt; history_;<br>  [[maybe_unused]] <span class="hljs-type">size_t</span> k_;<br>  [[maybe_unused]] <span class="hljs-type">frame_id_t</span> fid_;<br>  [[maybe_unused]] <span class="hljs-type">bool</span> is_evictable_&#123;<span class="hljs-literal">false</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>LRUKNode</strong>负责​​跟踪单个帧的访问历史​​，是LRU-K算法的基本数据单元。</p><table><thead><tr><th align="left">变量名</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="left">history_</td><td align="center">std::list<size_t></td><td align="center">按时间顺序存储最近K次访问的时间戳，最早的时间戳在列表前端</td></tr><tr><td align="left">k_</td><td align="center">size_t</td><td align="center">记录该节点使用的K值（历史访问次数阈值）</td></tr><tr><td align="left">fid_</td><td align="center">frame_id_t</td><td align="center">该节点对应的缓冲池帧ID</td></tr><tr><td align="left">is_evictable_</td><td align="center">bool</td><td align="center">标记该帧是否可被淘汰，初始为false</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * LRUKReplacer implements the LRU-k replacement policy.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The LRU-k algorithm evicts a frame whose backward k-distance is maximum</span><br><span class="hljs-comment"> * of all frames. Backward k-distance is computed as the difference in time between</span><br><span class="hljs-comment"> * current timestamp and the timestamp of kth previous access.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A frame with less than k historical references is given</span><br><span class="hljs-comment"> * +inf as its backward k-distance. When multiple frames have +inf backward k-distance,</span><br><span class="hljs-comment"> * classical LRU algorithm is used to choose victim.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUKReplacer</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LRUKReplacer</span><span class="hljs-params">(<span class="hljs-type">size_t</span> num_frames, <span class="hljs-type">size_t</span> k)</span></span>;<br><br>  <span class="hljs-built_in">DISALLOW_COPY_AND_MOVE</span>(LRUKReplacer);<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P1): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Destroys the LRUReplacer.</span><br><span class="hljs-comment">   */</span><br>  ~<span class="hljs-built_in">LRUKReplacer</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Evict</span><span class="hljs-params">()</span> -&gt; std::optional&lt;<span class="hljs-type">frame_id_t</span>&gt;</span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RecordAccess</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id, AccessType access_type = AccessType::Unknown)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetEvictable</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id, <span class="hljs-type">bool</span> set_evictable)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Remove</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Size</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">size_t</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// TODO(student): implement me! You can replace these member variables as you like.</span><br>  <span class="hljs-comment">// Remove maybe_unused if you start using them.</span><br>  [[maybe_unused]] std::unordered_map&lt;<span class="hljs-type">frame_id_t</span>, LRUKNode&gt; node_store_;<br>  [[maybe_unused]] <span class="hljs-type">size_t</span> current_timestamp_&#123;<span class="hljs-number">0</span>&#125;;<br>  [[maybe_unused]] <span class="hljs-type">size_t</span> curr_size_&#123;<span class="hljs-number">0</span>&#125;;<br>  [[maybe_unused]] <span class="hljs-type">size_t</span> replacer_size_;<br>  [[maybe_unused]] <span class="hljs-type">size_t</span> k_;<br>  [[maybe_unused]] std::mutex latch_;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/img/CMU15-445-Bustub-project1%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/LRUUse.png" alt="LRUKReplacer组件的作用"></p><h3 id="Task-2-Disk-Scheduler"><a href="#Task-2-Disk-Scheduler" class="headerlink" title="Task #2 - Disk Scheduler"></a>Task #2 - Disk Scheduler</h3><p>该组件负责对DiskManager进行读写操作调度。磁盘调度器可以被其他组件（在本例中为任务#3中的BufferPoolManager）使用，以对磁盘请求进行排队，这些请求由一个DiskRequest结构体表示。磁盘调度器将维护一个后台工作线程，该线程负责处理已调度的请求。</p><p><strong>1) 整体架构</strong><br><strong>Disk Scheduler采用了生产者-消费者模型：</strong></p><ul><li><strong>​​生产者​</strong>​：数据库系统中的其他组件（如 Buffer Pool Manager）通过Schedule()方法提交磁盘 I&#x2F;O 请求</li><li><strong>消费者​​</strong>：后台工作线程从队列中取出请求并执行实际的磁盘操作</li></ul><p><strong>2) 核心组件</strong></p><ul><li>请求队列 (request_queue_):是线程安全的阻塞队列，用于在生产者和消费者之间传递请求</li><li>后台工作线程 (background_thread_):在构造函数中启动，运行StartWorkerThread()方法,持续从队列中取出请求并处理，直到收到终止信号。</li><li>磁盘管理器 (disk_manager_):实际执行磁盘 I&#x2F;O 操作的核心组件,供 ReadPage()和 WritePage()方法。</li></ul><p><strong>3) 工作流程</strong></p><img src="/img/CMU15-445-Bustub-project1实现笔记/DiskSch.png" alt="Disk Scheduler的工作流程" style="display: block; margin: 0 auto; width: 50%; height:50%;"><h3 id="Task-3-Buffer-Pool-Manager"><a href="#Task-3-Buffer-Pool-Manager" class="headerlink" title="Task #3 - Buffer Pool Manager"></a>Task #3 - Buffer Pool Manager</h3><p>最后实现缓冲池管理器（ BufferPoolManager ）。BufferPoolManager 负责使用 DiskScheduler 从磁盘获取数据库页面，并将它们存储在内存中。 BufferPoolManager还可以在收到明确指示或需要驱逐页面以腾出空间时，调度脏页面的写入到磁盘。</p><p>LRUKReplacer 将跟踪页面访问时间，以便在需要为新页面腾出空间时决定要驱逐哪个帧。DiskScheduler 将在 DiskManager 上调度对磁盘的写入和读取。</p><p>同时，还要实现 ReadPageGuard 和 WritePageGuard 。这些类是 RAII 对象，提供对底层页面的线程安全读写访问。​<strong>RAII（Resource Acquisition Is Initialization）​​</strong>的核心思想是：将资源（内存、文件句柄、锁、数据库连接等）的生命周期与一个对象的生命周期绑定。​​​​获取资源​​：在​​对象的构造函数​​中获取资源；​​释放资源​​：在​​对象的析构函数​​中释放资源。</p><p><strong>1) page_guard</strong></p><p>PageGuard 是 BusTub 数据库系统中基于 ​​RAII（Resource Acquisition Is Initialization）​​ 思想设计的智能指针，用于安全地管理缓冲池页面的访问。其核心目标是：</p><img src="/img/CMU15-445-Bustub-project1实现笔记/page_guard1.png" alt="page_guard的RAII设计" style="display: block; margin: 0 auto; width: 50%; height:50%;"><p>page_guard的生命周期管理如下：</p><img src="/img/CMU15-445-Bustub-project1实现笔记/page_guard2.png" alt="生命周期管理" style="display: block; margin: 0 auto; width: 60%; height:60%;"><p>除了完成资源自动分配，最重要的是page_guard的线程安全。</p><img src="/img/CMU15-445-Bustub-project1实现笔记/page_guard3.png" alt="线程安全保证" style="display: block; margin: 0 auto; width: 50%; height:50%;"><p><strong>2) buffer_pool_manager</strong></p><p>BufferPoolManager实现展示了数据库系统核心组件的典型设计方法，其分层设计、资源管理策略和并发控制机制尤其值得学习，是构建高性能存储系统的优秀范例。</p><img src="/img/CMU15-445-Bustub-project1实现笔记/bpm1.png" alt="页面获取流程" style="display: block; margin: 0 auto; width: 70%; height:70%;"><p>在完成buffer_pool_manager时，需要用到许多关键的设计思想：</p><ul><li><strong>RAII (Resource Acquisition Is Initialization)</strong></li><li><strong>分层设计</strong></li></ul><img src="/img/CMU15-445-Bustub-project1实现笔记/bpm2.png" alt="分层设计" style="display: block; margin: 0 auto; width: 50%; height:50%;"><ul><li><strong>线程安全设计</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferPoolManager</span> &#123;<br>    ...<br>    std::shared_ptr&lt;std::mutex&gt; bpm_latch_;<br>    ...<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameHeader</span> &#123;<br>    ...<br>    <span class="hljs-comment">/** @brief The readers / writer latch for this frame. */</span><br>    std::shared_mutex rwlatch_;<br>    ...<br>&#125;<br><span class="hljs-comment">// 使用组合锁策略</span><br><span class="hljs-function">std::scoped_lock <span class="hljs-title">lock</span><span class="hljs-params">(*bpm_latch_)</span></span>;  <span class="hljs-comment">// 粗粒度锁</span><br><span class="hljs-function">std::scoped_lock <span class="hljs-title">frame_lock</span><span class="hljs-params">(frame-&gt;rwlatch_)</span></span>;  <span class="hljs-comment">// 细粒度锁</span><br>frame-&gt;pin_count_.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 无锁原子操作,查看是否存在引用</span><br></code></pre></td></tr></table></figure><img src="/img/CMU15-445-Bustub-project1实现笔记/result.png" alt="测试结果" style="display: block; margin: 0 auto; width: 50%; height:50%;">]]></content>
    
    
    <categories>
      
      <category>CMU15-445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Bustub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用</title>
    <link href="/2025/08/07/git%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/08/07/git%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git"></a>什么是git</h2><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><p><img src="/img/git%E4%BD%BF%E7%94%A8/git%E5%8E%9F%E7%90%86.png" alt="git原理"></p><h2 id="git的基本使用操作"><a href="#git的基本使用操作" class="headerlink" title="git的基本使用操作"></a>git的基本使用操作</h2><h3 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h3><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的<strong>工作目录</strong>，它持有实际文件；第二个是<strong>暂存区（Index）</strong>，它像个缓存区域，临时保存你的改动；最后是<strong>HEAD</strong>，它指向你最后一次提交的结果。</p><p><img src="/img/git%E4%BD%BF%E7%94%A8/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png" alt="本地仓库"></p><p>你可以提出更改（把它们添加到暂存区），使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;filename&gt;<br>git add .<br></code></pre></td></tr></table></figure><p>这是 git 基本工作流程的第一步；<br>使用如下命令以实际提交改动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;提交信息&quot;</span><br></code></pre></td></tr></table></figure><p>现在，你的改动已经提交到了HEAD，但是还没到你的远端仓库。</p><h3 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h3><p>执行如下命令以将这些改动提交到远端仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master<br></code></pre></td></tr></table></figure><p>可以把 master 换成你想要推送的任何分支。<br>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin &lt;server&gt;<br></code></pre></td></tr></table></figure><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p><ul><li><p>server：<br>HTTPS：<a href="https://github.com/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D.git">https://github.com/用户名/仓库名.git</a><br>SSH：<a href="mailto:&#x67;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;">git@github.com</a>:用户名&#x2F;仓库名.git</p></li><li><p>origin：<br>远程仓库的默认别名（可自定义，但通常用origin）。</p></li></ul><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<strong>master</strong>是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p><img src="/img/git%E4%BD%BF%E7%94%A8/%E5%88%86%E6%94%AF.png" alt="分支"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个叫做“feature_x”的分支，并切换过去：</span><br>git checkout -b feature_x<br><span class="hljs-comment"># 切换回主分支：</span><br>git checkout master<br><span class="hljs-comment"># 再把新建的分支删掉：</span><br>git branch -d feature_x<br><span class="hljs-comment"># 除非你将分支推送到远端仓库，不然该分支就是不为他人所见的：</span><br>git push origin &lt;branch&gt;<br></code></pre></td></tr></table></figure><h3 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h3><p>要更新你的本地仓库至最新改动，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure><p>以在你的工作目录中<strong>获取（fetch）</strong> 并 <strong>合并(merge)</strong> 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge &lt;branch&gt;<br></code></pre></td></tr></table></figure><p>在这两种情况下，git都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。<br>改完之后，你需要执行如下命令以将它们标记为合并成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>在合并改动之前，你可以使用如下命令预览差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff &lt;source_branch&gt; &lt;target_branch&gt;<br></code></pre></td></tr></table></figure><h3 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h3><p>假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -- &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>丢弃对指定文件的未提交修改​​将工作区中的文件恢复到最近一次提交（HEAD）或暂存区（如果已 git add）的状态，​​不可逆​​。<br>​适用场景​​</p><ul><li>修改了文件但未 git add（未暂存）→ 恢复到 HEAD版本。</li><li>修改了文件且已 git add（已暂存）→ 恢复到暂存区版本。</li><li>误删了文件 → 恢复文件到版本库中的状态。</li><li></li></ul><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从远程仓库（origin）下载最新的提交记录和分支信息，但​​不会自动合并或修改本地代码​​。</span><br>git fetch origin<br><span class="hljs-comment"># 强制将当前分支重置到 origin/master的提交。</span><br><span class="hljs-comment"># --hard：彻底重置工作区和暂存区，匹配远程分支。</span><br>git reset --hard origin/master<br></code></pre></td></tr></table></figure><h2 id="本地仓库git初始化"><a href="#本地仓库git初始化" class="headerlink" title="本地仓库git初始化"></a>本地仓库git初始化</h2><h3 id="使用ssh登陆"><a href="#使用ssh登陆" class="headerlink" title="使用ssh登陆"></a>使用ssh登陆</h3><ol><li>先生成ssh密钥（如果没有的话）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br><br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><ul><li>私钥：~&#x2F;.ssh&#x2F;id_rsa（​​切勿泄露​​）</li><li>公钥：~&#x2F;.ssh&#x2F;id_rsa.pub（需上传到 Git 服务商）</li></ul><ol start="2"><li>将公钥添加到远程仓库</li><li>测试ssh连接</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com  <span class="hljs-comment"># GitHub</span><br>ssh -T git@gitlab.com  <span class="hljs-comment"># GitLab</span><br></code></pre></td></tr></table></figure><p>连接成功返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hi TARScn! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树构造和遍历程序</title>
    <link href="/2025/07/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9E%84%E9%80%A0%E5%92%8C%E9%81%8D%E5%8E%86%E7%A8%8B%E5%BA%8F/"/>
    <url>/2025/07/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9E%84%E9%80%A0%E5%92%8C%E9%81%8D%E5%8E%86%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>二叉树构造如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;                <span class="hljs-comment">// 节点值</span><br>    TreeNode *left;         <span class="hljs-comment">// 左子树</span><br>    TreeNode *right;        <span class="hljs-comment">// 右子树</span><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>顺序为<strong>根-&gt;左子树-&gt;右子树</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>    cout &lt;&lt; node-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preorder</span>(node-&gt;left);<br>    <span class="hljs-built_in">preorder</span>(node-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs"> 构造如下二叉树：       1      / \     2   3    / \   4   5</code></pre><p>遍历结果为<strong>1 2 4 5 3</strong></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>顺序为<strong>左子树-&gt;根-&gt;右子树</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-built_in">inorder</span>(node-&gt;left);                 <span class="hljs-comment">// 先遍历左子树</span><br>    std::cout &lt;&lt; node-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;       <span class="hljs-comment">// 再访问根节点</span><br>    <span class="hljs-built_in">inorder</span>(node-&gt;right);                <span class="hljs-comment">// 最后遍历右子树</span><br>&#125;<br></code></pre></td></tr></table></figure><p>遍历结果为<strong>4 2 5 1 3</strong></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>顺序为<strong>左子树-&gt;右子树-&gt;根</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-built_in">postorder</span>(node-&gt;left);      <span class="hljs-comment">// 先遍历左子树</span><br>    <span class="hljs-built_in">postorder</span>(node-&gt;right);     <span class="hljs-comment">// 再遍历右子树</span><br>    std::cout &lt;&lt; node-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 最后访问根节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>遍历结果为<strong>4 5 2 3 1</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100练习</title>
    <link href="/2025/07/09/hot100%E7%BB%83%E4%B9%A0/"/>
    <url>/2025/07/09/hot100%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="相交链表-160"><a href="#相交链表-160" class="headerlink" title="相交链表(160)"></a>相交链表(160)</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。(题目数据 保证 整个链式结构中不存在环)</p><p>依次遍历所有节点<br>假设链表A长度为<strong>m+c</strong>，链表Bw长度为<strong>n+c</strong>，所以遍历长度为<strong>m+n+c</strong>就可完成所有链表节点遍历。<br>对链表A，遍历m+c+n<br>对链表B，遍历n+c+m</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *a = headA;<br>        ListNode *b = headB;<br>        <br>        <span class="hljs-keyword">while</span>(a != b)<br>        &#123;<br>            a = a?a-&gt;next:headB;<br>            b = b?b-&gt;next:headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>暴力手撕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *a = headA;<br>        ListNode *b = headB;<br>        <br>        <span class="hljs-keyword">while</span>(a != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(b != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(a == b)  <span class="hljs-keyword">return</span> a;<br>                b = b-&gt;next;<br>            &#125;<br>            a = a-&gt;next;<br>            b = headB;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先（236）（递归）"><a href="#二叉树的最近公共祖先（236）（递归）" class="headerlink" title="二叉树的最近公共祖先（236）（递归）"></a>二叉树的最近公共祖先（236）（递归）</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><pre><code class="hljs"> 构造如下二叉树：        1      /   \     2     3    / \   / \   4   5 6   7   </code></pre><p>如4，5的公共祖先为2； 1，6的公共祖先为1。</p><p>思路：使用递归<br>某个根节点，左子树中是否有孩子，右子树中是否有孩子。<br>若左右子树都有孩子，那这个根节点是公共祖先；<br>若单侧有孩子，那单侧的某个孩子为公共祖先。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 根为空则向上返回</span><br>        <span class="hljs-comment">// 当前根节点是孩子，返回上一层，且这侧有孩子；</span><br>        <span class="hljs-keyword">if</span>(p == root || q == root) <span class="hljs-keyword">return</span> root; <br>        <span class="hljs-comment">// 遍历左子树，看是否有孩子</span><br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>        <span class="hljs-comment">// 判断当前根节点是否是公共祖先，是则一直返回上层直到解除递归</span><br>        <span class="hljs-keyword">if</span>(left &amp;&amp; right) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">// 不是祖先则向上返回非空侧</span><br>        <span class="hljs-keyword">return</span> left?left:right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="回文链表（234）-双指针"><a href="#回文链表（234）-双指针" class="headerlink" title="回文链表（234）(双指针)"></a>回文链表（234）(双指针)</h2><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p><p>暴力手撕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        ListNode* p = head;<br>        <br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p)<br>        &#123;<br>            st.<span class="hljs-built_in">push</span>(p-&gt;val);<br>            p = p-&gt;next;<br>            i++;<br>        &#125;<br>        p = head;<br>        i /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;l&lt;i;l++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(p-&gt;val == st.<span class="hljs-built_in">top</span>())&#123;<br>                    p = p-&gt;next;<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>采用数组加双指针的思想</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vt;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">nullptr</span>)&#123;<br>            vt.<span class="hljs-built_in">emplace_back</span>(head-&gt;val);<br>            head = head-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=(<span class="hljs-type">int</span>)vt.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&lt;j; i++,j--)&#123;<br>            <span class="hljs-keyword">if</span>(vt[i] != vt[j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="每日温度（739）（单调栈）"><a href="#每日温度（739）（单调栈）" class="headerlink" title="每日温度（739）（单调栈）"></a>每日温度（739）（单调栈）</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>暴力手撕，时间复杂度为$O(N^2)$，超时无法通过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; answer;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = temperatures.<span class="hljs-built_in">begin</span>(); i != temperatures.<span class="hljs-built_in">end</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j = i<span class="hljs-number">+1</span>; j != temperatures.<span class="hljs-built_in">end</span>(); j++)&#123;<br>                n++;<br>                <span class="hljs-comment">// 后续出现更高温度</span><br>                <span class="hljs-keyword">if</span>(*i &lt; *j)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//后续没有最高温度</span><br>                <span class="hljs-keyword">if</span>(j == temperatures.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>)&#123;<br>                    n = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            answer.<span class="hljs-built_in">emplace_back</span>(n);<br>            n = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用<strong>单调栈</strong></p><p>单调栈（Monotonic Stack）是一种特殊的栈结构，它保持栈内元素的单调递增（Increasing）或单调递减（Decreasing）性质。它常用于解决 ​​“下一个更大&#x2F;更小元素”​​ 类问题，时间复杂度通常为 $O(N)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 只需存储索引</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">// 维护单调递减栈（栈顶最小）</span><br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                ans[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 计算等待天数</span><br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>单调栈的其它例题</p><h2 id="柱状图中的最大矩形（84）-单调栈"><a href="#柱状图中的最大矩形（84）-单调栈" class="headerlink" title="柱状图中的最大矩形（84）(单调栈)"></a>柱状图中的最大矩形（84）(单调栈)</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="/img/hot100%E7%BB%83%E4%B9%A0/84.png" alt="示例"></p><p>利用单调栈找两边更低的左右边界</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxS;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stkr,stkl;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftSmaller</span><span class="hljs-params">(heights.size(),<span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSmaller</span><span class="hljs-params">(heights.size(),heights.size())</span></span>;<br><br>        <span class="hljs-keyword">if</span>(heights.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> heights[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;heights.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">while</span>(!stkr.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[i]&lt;heights[stkr.<span class="hljs-built_in">top</span>()])<br>            &#123;<br>                rightSmaller[stkr.<span class="hljs-built_in">top</span>()] = i;<br>                stkr.<span class="hljs-built_in">pop</span>(); <br>            &#125;<br>            stkr.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=heights.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">while</span>(!stkl.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[i]&lt;heights[stkl.<span class="hljs-built_in">top</span>()])<br>            &#123;<br>                leftSmaller[stkl.<span class="hljs-built_in">top</span>()] = i;<br>                stkl.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            stkl.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;heights.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-type">int</span> nowS = heights[i]*(rightSmaller[i]-leftSmaller[i]<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">if</span>(nowS&gt;maxS) maxS = nowS;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxS;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="盛最多水的容器（11）-双指针"><a href="#盛最多水的容器（11）-双指针" class="headerlink" title="盛最多水的容器（11）(双指针)"></a>盛最多水的容器（11）(双指针)</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><img src="/img/hot100%E7%BB%83%E4%B9%A0/11.png" alt="示例"></p><p>暴力求解，但是提交超时，复杂度$O(N^2)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>,now=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span>;j&lt;height.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(height[j]&gt;height[i])&#123;<br>                    now = height[i]*(j-i);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    now = height[j]*(j-i);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(now&gt;ret) ret = now;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>采用双指针，从两边向中间遍历，复杂度$O(N)$<br>在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 −1​ 变短：</p><p>若向内 移动短板 ，水槽的短板 min(h[i],h[j]) 可能变大，因此下个水槽的面积 可能增大 。<br>若向内 移动长板 ，水槽的短板 min(h[i],h[j])​ 不变或变小，因此下个水槽的面积 一定变小 。<br>因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>,h;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            h = height[left]&lt;height[right] ? height[left]:height[right];<br>            ret = ret&gt;(h*(right-left)) ? ret:h*(right-left);<br>            <span class="hljs-keyword">if</span>(height[left]&lt;height[right])<br>                left++;<br>            <span class="hljs-keyword">else</span><br>                right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="最大正方形（221）（动态规划）"><a href="#最大正方形（221）（动态规划）" class="headerlink" title="最大正方形（221）（动态规划）"></a>最大正方形（221）（动态规划）</h2><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。<br>这题主要是想到dp的递推公式。</p><p><img src="/img/hot100%E7%BB%83%E4%B9%A0/221.png" alt="计算dp"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">dp</span><span class="hljs-params">(i,j)</span></span>=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">dp</span>(i−<span class="hljs-number">1</span>,j),<span class="hljs-built_in">dp</span>(i−<span class="hljs-number">1</span>,j−<span class="hljs-number">1</span>),<span class="hljs-built_in">dp</span>(<span class="hljs-selector-tag">i</span>,j−<span class="hljs-number">1</span>))+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">empty</span>() || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> max_side = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;<br>                        dp[i][j] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 第一行或第一列，边长最大为 1</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                    &#125;<br>                    max_side = <span class="hljs-built_in">max</span>(max_side, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> max_side * max_side;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVL树和红黑树介绍</title>
    <link href="/2025/07/02/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/"/>
    <url>/2025/07/02/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="AVL树介绍"><a href="#AVL树介绍" class="headerlink" title="AVL树介绍"></a>AVL树介绍</h1><h2 id="什么是AVL树？"><a href="#什么是AVL树？" class="headerlink" title="什么是AVL树？"></a>什么是AVL树？</h2><p><strong>AVL树</strong>（Adelson-Velsky and Landis Tree）是一种<strong>自平衡二叉搜索树</strong>（Self-Balancing Binary Search Tree）。<br>它由苏联数学家 <strong>G.M. Adelson-Velsky</strong> 和 <strong>E.M. Landis</strong> 于1962年发明，是最早提出的自平衡二叉查找树之一。</p><p><strong>特点：</strong></p><ul><li>任何一个节点的左子树和右子树的高度差（平衡因子）最多为1。</li><li>保证树的高度始终为O(log n)，插入、删除和查找操作都可以在对数时间内完成。</li></ul><h2 id="AVL树的定义"><a href="#AVL树的定义" class="headerlink" title="AVL树的定义"></a>AVL树的定义</h2><p>对于树中的每一个节点，定义：</p><ul><li><strong>高度（Height）</strong>：从该节点到叶子节点的最长路径长度（叶子高度为0）。</li><li><strong>平衡因子（Balance Factor, BF）</strong>：<br>[<br>BF &#x3D; \text{左子树高度} - \text{右子树高度}<br>]</li><li>AVL树要求：所有节点的平衡因子必须满足：<br>[<br>BF \in {-1, 0, +1}<br>]</li></ul><h2 id="旋转示意图"><a href="#旋转示意图" class="headerlink" title="旋转示意图"></a>旋转示意图</h2><p>以下示意展示两种最常用的旋转：</p><p><strong>右旋 (Right Rotation)：</strong></p><p><img src="/img/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/youxuan.jpg" alt="右旋"></p><blockquote><p>左旋为右旋的镜像</p></blockquote><h2 id="AVL树的基本操作"><a href="#AVL树的基本操作" class="headerlink" title="AVL树的基本操作"></a>AVL树的基本操作</h2><h3 id="1-插入"><a href="#1-插入" class="headerlink" title="1. 插入"></a>1. 插入</h3><p>插入节点后，可能破坏树的平衡性。需要沿插入路径向上回溯，并进行**旋转（Rotation）**修复。</p><p>常见的四种情况：</p><ul><li><strong>LL型（左-左）：</strong> 对不平衡节点进行<strong>右旋</strong>。</li><li><strong>RR型（右-右）：</strong> 对不平衡节点进行<strong>左旋</strong>。</li><li><strong>LR型（左-右）：</strong> 先对左子节点进行<strong>左旋</strong>，再对不平衡节点进行<strong>右旋</strong>。</li><li><strong>RL型（右-左）：</strong> 先对右子节点进行<strong>右旋</strong>，再对不平衡节点进行<strong>左旋</strong>。</li></ul><h3 id="2-删除"><a href="#2-删除" class="headerlink" title="2. 删除"></a>2. 删除</h3><p>删除节点后也可能导致平衡性破坏，需要从删除位置往上回溯，并进行相应的旋转修复。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://www.bilibili.com/video/BV1uuFpeKEGd?spm_id_from=333.788.videopod.sections&vd_source=1a88fb46407c6a5cc8a52eb1ea305721">AVL树插入示例</a><br><a href="https://www.bilibili.com/video/BV1rufJYyEms/?spm_id_from=333.337.search-card.all.click&vd_source=1a88fb46407c6a5cc8a52eb1ea305721">AVL树删除示例</a></p><h1 id="红黑树介绍"><a href="#红黑树介绍" class="headerlink" title="红黑树介绍"></a>红黑树介绍</h1><h2 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h2><p><strong>红黑树（Red-Black Tree）</strong> 是一种自平衡的<strong>二叉搜索树（BST）</strong>。<br>它在插入和删除节点后，通过特定的规则进行调整，使得整棵树保持“近似平衡”，从而保证查找、插入、删除操作的时间复杂度为 <strong>O(log n)</strong>。</p><h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><p>红黑树每个节点上附加一个颜色属性：<strong>红色（Red）<strong>或</strong>黑色（Black）</strong>，并满足以下五条性质：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL节点）是黑色。</li><li>如果一个节点是红色的，则它的两个子节点都是黑色的（不会出现连续的红色节点）。</li><li>从任一节点到其所有后代叶子节点的路径上，<strong>黑色节点数量相同</strong>。</li></ol><p><strong>红黑树的实质是黑色节点的高度平衡</strong></p><h2 id="红黑树的基本操作"><a href="#红黑树的基本操作" class="headerlink" title="红黑树的基本操作"></a>红黑树的基本操作</h2><h3 id="1-插入（Insert）"><a href="#1-插入（Insert）" class="headerlink" title="1. 插入（Insert）"></a>1. 插入（Insert）</h3><p>插入节点初始为<strong>红色</strong>，然后根据红黑树性质进行修复：</p><ul><li>情况1：新节点的叔叔是红色 → 变色 + 向上递归</li><li>情况2：叔叔是黑色，且当前节点是“外侧” → 变色 + 旋转</li><li>情况3：叔叔是黑色，且当前节点是“内侧” → 旋转 + 变色 + 旋转</li></ul><p><strong>需要注意的是红黑树的叶子是黑色的NIL</strong><br>因为插入节点为红色，所以<strong>插入会破坏的性质只可能是性质2和性质4</strong>。</p><p>关注点在于<strong>红红冲突</strong>，然后考虑叔叔节点是红色还是黑色。</p><p>如果<strong>叔叔节点是红色</strong>则符合情况1，直接将<strong>叔叔节点和父节点染黑，祖父节点染红，接着检查祖父节点如果是根节点则染黑</strong>，递归向上。</p><p>如果<strong>叔叔节点是黑色</strong>则考虑情况2、3，其实情况3可以通过选择转换为情况2。</p><p><img src="/img/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/ranse.jpg" alt="叔叔节点为黑色的处理"></p><p>依次插入1，2，3，4，5，6，7，8生成的红黑树步骤如下</p><p><img src="/img/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/exp1.jpg" alt="例子1"></p><h3 id="2-删除（Delete）"><a href="#2-删除（Delete）" class="headerlink" title="2. 删除（Delete）"></a>2. 删除（Delete）</h3><p>删除一个节点可能破坏黑色平衡，需要使用“<strong>双重黑色</strong>”处理机制，并通过：</p><ul><li>兄弟变色</li><li>旋转</li><li>传递双黑等方式进行修复</li></ul><p><img src="/img/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/rbtRe.png" alt="红黑树删除节点的情况"></p><p>第三种情况是<strong>有左孩子和右孩子</strong>，可以通过<strong>直接后继</strong>（直接前继）替代，再删除后继（前继）的方式，转换 成其他情况。</p><h4 id="只有左孩子或者右孩子"><a href="#只有左孩子或者右孩子" class="headerlink" title="只有左孩子或者右孩子"></a><strong>只有左孩子或者右孩子</strong></h4><blockquote><p>直接删去后，孩子染黑替换</p></blockquote><p><img src="/img/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/re1.jpg" alt="处理方式"></p><h4 id="没有孩子"><a href="#没有孩子" class="headerlink" title="没有孩子"></a><strong>没有孩子</strong></h4><ol><li>自身是红节点</li></ol><blockquote><p>直接删除即可</p></blockquote><ol start="2"><li>自身是黑节点（删除后变双黑），兄弟是红色。</li></ol><blockquote><p>兄父变色，朝双黑旋转。保持双黑，继续消除。</p></blockquote><p><img src="/img/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/re2.jpg" alt="处理方式"></p><ol><li>自身是黑节点（删除后变双黑），兄弟是黑色，兄弟存在红孩子。</li></ol><blockquote><p>如果兄弟外侧是红孩子。r-&gt;s，s-&gt;p，p变黑，旋转</p></blockquote><p><img src="/img/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/re3.jpg" alt="处理方式"></p><blockquote><p>如果兄弟只有内侧有孩子，且是红孩子。r-&gt;p，p变黑，旋转孩子，旋转。</p></blockquote><p><img src="/img/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/re4.jpg" alt="处理方式"></p><ol start="4"><li>自身是黑节点（删除后变双黑），兄弟是黑色，兄弟都是黑孩子。</li></ol><blockquote><p>兄弟变红，双黑上移（遇红遇根变黑）。</p></blockquote><p><a href="https://www.bilibili.com/video/BV16m421u7Tb?spm_id_from=333.788.videopod.sections&vd_source=1a88fb46407c6a5cc8a52eb1ea305721">红黑树删除示例</a></p><p>依次从红黑树删除18，25，15，6，13，37，27，17，34，9，10</p><p><img src="/img/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/re5.png" alt="示例"></p><p><img src="/img/AVL%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8B%E7%BB%8D/re6.png" alt="示例"></p><h3 id="3-查找（Search）"><a href="#3-查找（Search）" class="headerlink" title="3. 查找（Search）"></a>3. 查找（Search）</h3><p>和普通的二叉搜索树一样，查找过程为从根节点出发，逐层比较关键字。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树</tag>
      
      <tag>AVL树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis设计与实现读书笔记二--单机数据库</title>
    <link href="/2025/06/27/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2025/06/27/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">redisServer</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 数据库数组，保存服务器中的所有数据库</span><br>    redisDb *db;<br>    <span class="hljs-comment">// 服务器中的数据库数量</span><br>    <span class="hljs-type">int</span> dbnum;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>dbnum的值有服务器配置的database选项决定，默认为16。</p><p>客户端状态redisClient结构的db属性记录了客户端当前的目标数据库：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">redisClient</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 记录客户端当前使用的数据库</span><br>    redisDb *db;<br>    <span class="hljs-comment">// ...</span><br>&#125; redisClient;<br></code></pre></td></tr></table></figure><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/redisDb.png" alt="客户端的目标数据库为1号数据库"></p><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>redis是一个键值对数据库服务器，服务器中的数据器结构redisDb中的<strong>dict</strong>字典保存了数据库中的所有键值对，这个字典被称为<strong>键空间</strong>（key space）。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/keySpace.png" alt="键空间例子"></p><p>数据库的操作如添加、删除、更新、取值等都是键空间操作。</p><h3 id="键的过期机制"><a href="#键的过期机制" class="headerlink" title="键的过期机制"></a>键的过期机制</h3><p>redisDb中的<strong>expires</strong>字典保存了数据库中所有键的过期时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">redisDb</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 数据键空间，保存键空间所有的键值对</span><br>    dict *dict;<br>    <span class="hljs-comment">// 过期字典，保存键值对的过期时间</span><br>    dict *expires;<br>    <span class="hljs-comment">// ...</span><br>&#125;redisDb;<br></code></pre></td></tr></table></figure><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/expires.png" alt="带过期字典的数据库例子"></p><ul><li>过期字典的键是一个指针，指向键空间中的某个键对象</li><li>过期字典的值是一个long long类型的整数，过期时间–一个毫秒精度的UNIX时间戳</li></ul><h3 id="过期键的删除"><a href="#过期键的删除" class="headerlink" title="过期键的删除"></a>过期键的删除</h3><p>redis过期键的删除策略为<strong>定期删除</strong>和<strong>惰性删除</strong>。</p><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>定期删除策略每隔一段固定时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少对CPU时间的影响。</p><p>redis周期性操作进行时，activaExpireCycle函数会在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的<strong>expires</strong>字典中随机检查部分键的过期时间，并删除其中的过期键。</p><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>惰性删除是指程序只会在取出键时才会对键进行过期检查，删除的目标仅限于当前操作键，避免了浪费CPU时间，但是redis是内存服务器，这一策略会造成内存浪费。</p><blockquote><p>redis同时采用了<strong>定期删除和惰性删除并结合</strong>。</p></blockquote><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>redis是一个内存数据库，当服务器进程退出时，数据库状态也会消失。redis提供了RDB持久化功能，可以手动开启，也可以定期保存。RDB持久化功能生成的文件是一个经过压缩的二进制文件，可通过这个文件还原数据库状态。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/RDB.png" alt="数据库和RDB文件互相转换"></p><blockquote><p>RDB文件通过演进，老版本的redis无法兼容新版本的RDB，因为有部分数据结构不匹配。</p></blockquote><h3 id="保存与载入"><a href="#保存与载入" class="headerlink" title="保存与载入"></a>保存与载入</h3><p>当AOF持久化功能开启时，redis会优先使用AOF，因为AOF更新频率更高。<br>创建RDB文件创建RDB文件有<strong>SAVE</strong>和<strong>BGSAVE</strong>两个命令。</p><ul><li><strong>SAVE</strong><br>直接创建RDB文件，会中断服务器程序</li><li><strong>BGSAVE</strong><br>父程序会fork一个子程序，由子程序创建RDB文件，不会中断服务器程序。</li></ul><p>保存的RDB文件名字叫做<strong>dump.rdb</strong>，存放位置需要通过<strong>redis.conf</strong>设置，否则默认当前的工作目录下。<br>开启redis时，自动载入<strong>dump.rdb</strong>，载入RDB文件时，服务器程序会出于阻塞状态，直到载入工作完成。</p><p>保存条件设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只要满足以下三个条件中的任何一个，BGSAVE都会执行</span><br><span class="hljs-comment"># 服务器在900秒内，对数据库进行了至少1次修改</span><br>save 900 1<br><span class="hljs-comment"># 服务器在300秒内，对数据库进行了至少10次修改</span><br>save 300 10<br><span class="hljs-comment"># 服务器在60秒内，对数据库进行了至少10000次修改</span><br>save 60 10000<br></code></pre></td></tr></table></figure><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p>下图为一个完整的RDB文件结构：</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/rdbfile.png" alt="RDB文件结构"></p><p>database结构如下：</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/rdbDatabase.png" alt="database结构"></p><p>key_value_pairs结构如下：</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/key_value_pairs.png" alt="带过期时间的key_value_pairs结构"></p><p>无过期时间的结构只有TYPE、key、value。</p><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF持久化是通过redis服务器所执行的写命令来记录数据库状态的。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/AOF.png" alt="AOF持久化"></p><h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>AOF持久化分为命令追加、文件写入、文件同步。</p><ol><li><strong>命令追加</strong></li></ol><p>AOF持久化开启后，如果redis执行完一个写命令后，会将写命令以协议格式追加到服务器状态的<strong>aof_buf</strong>缓冲区末尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">redisServer</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// AOF缓冲区</span><br>    sds aof_buf;<br>    <span class="hljs-comment">// ..</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>文件写入与同步</strong></li></ol><p>redis程序是一个<strong>事件循环</strong>，循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，循环中还包括定时运行的函数。开启AOF持久化后，服务器在结束一次事件循环之前，程序会调用<strong>flushAppendOnlyFile</strong>函数，选择是否将aof_buf中的内容写入和保存到AOF文件里面。</p><p><strong>flushAppendOnlyFile</strong>函数的行为由服务器配置的appendfsync选项决定：</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/appendfsync.png" alt="appendfsync配置不同的持久化行为"></p><blockquote><p>写入（<strong>write</strong>）在linux中只是把数据写入到内核页缓存，并未真正落盘。只有同步到硬盘才是落盘。</p></blockquote><h3 id="AOF文件载入和数据库还原"><a href="#AOF文件载入和数据库还原" class="headerlink" title="AOF文件载入和数据库还原"></a>AOF文件载入和数据库还原</h3><p>关键点在于创建一个不联网的伪客户端，利用伪客户端写入命令。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/aofLoad.png" alt="AOF文件载入过程"></p><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>为了避免记录过多写命令导致的AOF文件庞大，redis重新生成新的AOF文件替代旧AOF文件被称为<strong>AOF重写</strong>。</p><p><strong>AOF重写是通过读取当前的数据库状态来实现的</strong>，而不用分析旧AOF文件。数据库中存在什么键值对，就写入什么，所以没有一句命令多余。</p><blockquote><p>为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序会检查多元素的数量，超过固定值则通过执行多条命令记录键的值。</p></blockquote><p>为了保证执行AOF重写时，服务器依然可以正常工作，redis使用<strong>AOF后台重写</strong>技术。</p><p>redis会创建一个带有当前数据库所有数据的<strong>子进程</strong>，父进程依旧正常处理客户端命令，子进程执行AOF重写程序。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/aofRewrite.png" alt="AOF重写"></p><p>要让子进程重写结束后的AOF文件与当前父进程中的数据库状态一致，redis服务器在创建子进程之前，会维护一个<strong>AOF重写缓冲区</strong>。这个缓冲区会在子进程执行AOF重写期间，记录服务器执行的所有命令，当子进程完成所有工作之后，服务器将缓冲区中的所有内容添加到重写AOF文件的末尾，最后用这个新AOF文件替代旧文件。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>redis是一个事件驱动程序。服务器处理以下两类事件：<strong>文件事件</strong>、<strong>时间事件</strong>。</p><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>redis使用的网络事件处理器被称为<strong>文件事件处理器</strong>。</p><p>文件事件处理器使用<strong>I&#x2F;O多路复用程序</strong>同时监听多个套接字，为套接字目前执行的不同任务<strong>关联不同的事件处理器</strong>。被监听的套接字准备<strong>执行连接应答、读取、写入、关闭等操作</strong>时，产生对应的文件事件，<strong>文件处理器会调用之前关联的事件处理器</strong>。</p><blockquote><p><strong>I&#x2F;O多路复用是指一个线程同时监听多个I&#x2F;O流</strong>，是redis支持高并发的关键<br>原理是将所有关注的套接字注册到内核，内核</p></blockquote><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/FEH.png" alt="文件事件处理器的四个部分"></p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/cAndS.png" alt="客户端和服务器的通信过程"></p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><ul><li>时间事件分为以下两类：</li></ul><p><strong>定时事件</strong>：让程序在指定的时间之后执行一次。</p><p><strong>周期性事件</strong>：让程序每隔指定时间就执行一次。</p><ul><li>时间事件主要由以下三个属性组成：</li></ul><p><strong>id</strong>：全局唯一ID，新事件ID比旧事件ID大。<br><strong>when</strong>：毫秒精度UNIX时间戳，记录到达时间。<br><strong>timeProc</strong>：时间事件处理器，时间事件到达时，服务器调用相应处理器。</p><p>事件处理器返回返回ae.h&#x2F;<strong>AE_NOMORE</strong>，则事件为定时事件：事件到达一次之后被删除。如果是一个<strong>非AE_NOMORE</strong>的数，则为周期性事件，根据返回的值对<strong>when</strong>进行更新，让事件在这段时间之后到达。</p><h3 id="事件的调度和执行"><a href="#事件的调度和执行" class="headerlink" title="事件的调度和执行"></a>事件的调度和执行</h3><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/eventProc.png" alt="事件处理角度下的服务器运行流程"></p><p>服务器轮流处理文件事件和时间事件，处理事件的过程中<strong>不会进行抢占</strong>，因此事件处理器会尽可能减少阻塞时间，必要时主动<strong>让出执行权</strong>，时间事件也会把耗时的持久化操作放在子线程或子进程执行。<br>因为服务器先处理文件事件，所以<strong>时间事件的实际处理时间通常比设定的到达时间晚一些</strong>。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">redisClient</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">int</span> fd;<br>    ...<br>    <span class="hljs-type">int</span> flags;<br>    ...<br>    sds querybuf;<br>    ...<br>    robj **argv;<br>    <span class="hljs-type">int</span> argc;<br>    ...<br>    redisCommand *cmd;<br>    <span class="hljs-comment">// ...</span><br>&#125;redisClient;<br></code></pre></td></tr></table></figure><ul><li><strong>套接字描述符</strong></li></ul><p>客户端状态的<strong>fd</strong>属性记录客户端正在使用的套接字描述符，fd属性为-1则是<strong>伪客户端</strong>（AOF持久化、Lua脚本），普通客户端的fd为大于-1的值。</p><ul><li><strong>标志</strong></li></ul><p>客户端状态的标志属性<strong>flags</strong>记录客户端的<strong>角色（role）</strong>，以及客户端所处的状态。</p><ul><li><strong>输入缓冲区</strong></li></ul><p>客户端状态的<strong>querybuf</strong>输入缓存区用于保存客户端发来的命令请求。输入缓存区的大小会根据输入内容动态地缩小放大，最大<strong>不超过1GB，否则服务器关闭这个客户端</strong>。</p><ul><li><strong>命令与命令参数</strong></li></ul><p>服务器对输入缓存区中的命令请求进行分析，并将得出的<strong>命令参数</strong>和<strong>参数个数</strong>保存在客户端状态的argv和argc属性中。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/cmdClient.png" alt="argv和argc示例"></p><p>服务器根据argv[0]的值在<strong>命令表</strong>中查找命令所对应的<strong>命令实现函数</strong>。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/cmdTable.png" alt="命令表"></p><p><strong>redisCommand</strong>结构保存了命令的实现函数、命令的标志、命令应给定的参数个数和执行次数、执行时间等统计信息。</p><p>服务器找到对应redisCommand之后，会将客户端状态的<strong>cmd</strong>指针指向它。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/cmdSet.png" alt="查找命令并设置cmd属性"></p><p>之后，服务器可以通过cmd调用命令实现函数，执行客户端请求命令。</p><ul><li><strong>输出缓冲区</strong></li></ul><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区。<br>每个客户端有<strong>两个输出缓冲区可用</strong>，一个<strong>大小固定</strong>（16KB），另一个<strong>大小可变</strong>的。</p><h3 id="客户端的创建和关闭"><a href="#客户端的创建和关闭" class="headerlink" title="客户端的创建和关闭"></a>客户端的创建和关闭</h3><h4 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h4><p>客户端通过网络连接服务器，客户端使用connect函数连接服务器时，服务器调用<strong>连接事件处理器</strong>，为客户端创建相应的<strong>客户端状态</strong>，并将新客户端状态添加到服务器状态结构<strong>clients</strong>链表的末尾。</p><h4 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h4><ul><li>客户端进程退出或被杀死，客、服之间的网络连接将被关闭，造成客户端被关闭</li><li>客户端向服务器发送了带有不符合协议格式的命令请求，客户端也会被关闭</li><li>用户为服务器设置了timeout配置选项，客户端空转时间超过之后被关闭（存在一些例外：主服务器、从服务器、BLPOP命令阻塞、执行订阅命令中）。</li><li>客户端发送命令请求大小超过输入缓冲区的大小（默认1GB）</li><li>要发送给客户端的命令回复大小超过了输出缓冲区的限制大小（硬性限制、软件限制）</li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><ol><li>客户端将命令请求发送给服务器</li><li>服务器读取命令，并分析命令参数</li><li>命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复</li><li>服务器将命令回复返回给客户端</li></ol><h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><p>默认每隔100毫秒执行一次，主要用于更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，执行持久化操作等等。</p><h3 id="服务器初始化"><a href="#服务器初始化" class="headerlink" title="服务器初始化"></a>服务器初始化</h3><ol><li>初始化服务器状态</li><li>载入服务器配置</li><li>初始化服务器数据结构</li><li>还原数据库状态</li><li>执行事件循环</li></ol>]]></content>
    
    
    <categories>
      
      <category>redis设计与实现读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis设计与实现读书笔记一--数据结构</title>
    <link href="/2025/06/22/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2025/06/22/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>这本书采用redis为2.8，现在（2025年）redis更新版本到了7.x，作者下载redis源码版本为7.0.15。但是询问GPT得到的答案为基本数据结构没有大变动，但是新版本新添加了一些数据结构。</p><h2 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h2><h3 id="SDS实现"><a href="#SDS实现" class="headerlink" title="SDS实现"></a>SDS实现</h3><p>书中sds结构体定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sdshdr</span> &#123;<br>    <span class="hljs-comment">// 记录 buf 数组中已使用字节的数量</span><br>    <span class="hljs-comment">// 等于SDS 所保存字符串的长度</span><br>    <span class="hljs-type">int</span> len:<br>    <span class="hljs-comment">// 记录 buf 数组中未使用字节的数量</span><br>    <span class="hljs-type">int</span> free;<br>    <span class="hljs-comment">// 字节数组,用于保存字符串</span><br>    <span class="hljs-type">char</span> buf [];<br>&#125;;<br></code></pre></td></tr></table></figure><p>redis（7.0.15）中的定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__attribute__</span> ((__packed__)) sdshdr8 &#123;<br>    <span class="hljs-comment">// 实际使用的字节数</span><br>    <span class="hljs-type">uint8_t</span> len; <br>    <span class="hljs-comment">// 分配的总字节数，不包括头和\0结尾</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-comment">// 记录SDS类型（8、16、32）</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="SDS特性"><a href="#SDS特性" class="headerlink" title="SDS特性"></a>SDS特性</h3><ul><li><strong>字符串长度快速查询</strong></li></ul><p>C语言中字符串查询长度复制度$O(n)$，而SDS中查询字符串长度的复杂度为$O(1)$，因为SDS中可以直接查字长len。记录字长也为SDS避免了后续修改字符串导致缓冲溢出的问题。</p><ul><li><strong>预分配与惰性空间</strong></li></ul><p>为了避免多次字符串修改导致的<strong>反复内存重分配</strong>，SDS使用了预分配与惰性空间的策略。<br>具体体现为：对SDS做拼接等增加字符的操作时，SDS会多分配一些内存空间；对SDS做截断等删除字符的操作时，SDS并不会把free的空间全部回收，而是做保留。<br>这种策略可以视为以空间换时间，提高了SDS的操作速度性能。</p><ul><li><strong>二进制安全</strong></li></ul><p>C语言的字符串默认以’\0’作为结尾标志，所以无法支持具有中间’\0’的数据，如<strong>图片、压缩包</strong>等。而SDS由于使用len记录字长，所以SDS中的数据可以包含任意个’\0’，而不用担心数据无法正常读取。</p><h2 id="链表-listNode"><a href="#链表-listNode" class="headerlink" title="链表(listNode)"></a>链表(listNode)</h2><h3 id="listNode-list实现"><a href="#listNode-list实现" class="headerlink" title="listNode&amp;list实现"></a>listNode&amp;list实现</h3><ul><li><strong>链表节点listNode结构</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">listNode</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">listNode</span> *prev;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">listNode</span> *next;<br>    <span class="hljs-type">void</span> *value;<br>&#125; listNode;<br></code></pre></td></tr></table></figure><ul><li><strong>链表list结构</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list</span> &#123;<br>    listNode *head;<br>    listNode *tail;<br>    <span class="hljs-comment">// 节点值复制函数</span><br>    <span class="hljs-type">void</span> *(*dup)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">// 节点值释放函数</span><br>    <span class="hljs-built_in">void</span> (*free)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">// 节点值对比函数</span><br>    <span class="hljs-built_in">int</span> (*match)(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br>    <span class="hljs-comment">// 链表所包含的节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br>&#125; list;<br></code></pre></td></tr></table></figure><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/list.png" alt="list和listNode组成的链结构"></p><h3 id="listnode-list特性"><a href="#listnode-list特性" class="headerlink" title="listnode&amp;list特性"></a>listnode&amp;list特性</h3><ul><li><strong>双端</strong></li></ul><p>链表节点带有<strong>prev</strong>和<strong>next</strong>指针,获取某个节点的前置节点和后置节点的复杂度都是$O(1)$。</p><ul><li><strong>表头表尾</strong></li></ul><p>链表list带有<strong>head</strong>和<strong>tail</strong>指针,获取链表的表头节点和表尾节点的复杂度都是$O(1)$。</p><ul><li><strong>节点计数器</strong></li></ul><p>链表list带有节点计数器<strong>len</strong>,获取链表中的节点数量复杂度是$O(1)$。</p><ul><li><strong>多态</strong></li></ul><p>链表节点中的<strong>value</strong>的指针类型是*<strong>void</strong>,所以链表可以保存各类不同类型的值。</p><h2 id="字典（dictionary-dict）"><a href="#字典（dictionary-dict）" class="headerlink" title="字典（dictionary&#x2F;dict）"></a>字典（dictionary&#x2F;dict）</h2><h3 id="哈希表-hash-table"><a href="#哈希表-hash-table" class="headerlink" title="哈希表 hash table"></a>哈希表 hash table</h3><p>哈希表又称散列表，是根据关键值来访问数据的一种数据结构。哈希表通过将关键键值映射为一个地址索引，加快数据的查找速度。做个比喻，学生学号和学生姓名分别对应关键键值（<strong>key</strong>）和数据（<strong>value</strong>），且存在一个数组（<strong>hash table</strong>），而<strong>key</strong>可以通过哈希算法得到一个数字索引（假设为1），则可以把数据放在数组索引为1的储存空间。下次我们要查找value，只需要通过key即可知道数据储存位置，而且理想情况下，查找复杂度为一个常数。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hashTable.png" alt="哈希表"></p><p>redis的字典本质是一个哈希表，redis中定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dict</span> &#123;<br>    <span class="hljs-comment">// 哈希表数组</span><br>    dictEntry **table;<br>    dictType *type;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>    <span class="hljs-type">void</span> *privdata;<br>&#125; dict;<br></code></pre></td></tr></table></figure><p>哈希表节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictEntry</span> &#123;<br>    <span class="hljs-type">void</span> *key;<br>    <span class="hljs-type">void</span> *val;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictEntry</span> *next;<br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>面对两个及以上key映射到同一个索引的情况，redis使用单向链表解决。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/oneKeyOnIndex.png" alt="一个包含两个键值对的哈希表"></p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/twoKeyOnIndex.png" alt="使用链表解决k2和k1的冲突"></p><h2 id="整数集合（intset）"><a href="#整数集合（intset）" class="headerlink" title="整数集合（intset）"></a>整数集合（intset）</h2><h3 id="intset实现"><a href="#intset实现" class="headerlink" title="intset实现"></a>intset实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">intset</span> &#123;<br>  <span class="hljs-comment">// 编码方式</span><br>  <span class="hljs-type">uint32_t</span> encoding;<br>  <span class="hljs-comment">// 集合包含的元素数量</span><br>  <span class="hljs-type">uint32_t</span> length;<br>  <span class="hljs-comment">// 保存元素的数组</span><br>  <span class="hljs-type">int8_t</span> contents [];<br>&#125; intset;<br></code></pre></td></tr></table></figure><p>contents数组是整数集合的底层实现:整数集合的每个元素都是contents数组的一个数组项 (item)，各个项在数组中按值的大小从小到大<strong>有序排列</strong>,并且数组中不包含任何重复项。</p><p>length属性记录了整数集合包含的元素数量,也即是contents数组的长度。虽然intset结构将contents属性声明为int8_t类型的数组,但实际上contents数组并不保存任何int8_t类型的值,contents数组的真正类型取决于encoding属性的值。</p><h3 id="intset特性"><a href="#intset特性" class="headerlink" title="intset特性"></a>intset特性</h3><ul><li><strong>升级</strong></li></ul><p>每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有所有元素的类型都要长时,整数集合需要先进行升级(upgrade),然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行:</p><ol><li>根据新元素的类型,扩展整数集合底层数组的空间大小,并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型,并将类型转换后的元素放置到正确的位上,而且在放置元素的过程中,需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><p>相较于数组，intset有自动升级和有序排列的优势，能节约空间和加快查找。</p><ul><li><strong>降级</strong></li></ul><p>intset不支持降级操作。</p><h2 id="压缩列表（ziplist）"><a href="#压缩列表（ziplist）" class="headerlink" title="压缩列表（ziplist）"></a>压缩列表（ziplist）</h2><h3 id="ziplist实现"><a href="#ziplist实现" class="headerlink" title="ziplist实现"></a>ziplist实现</h3><p>压缩列表是 Redis 为了<strong>节约内存</strong>而开发的,是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构。一个压缩列表可以包含任意多个节点(entry),每个节点可以保存一个<strong>字节数组</strong>或者一个<strong>整数值</strong>。</p><p>一个ziplist的构成如下图。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ziplistEx.png" alt="压缩列表"></p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ziplistNt.png" alt="各个组成说明"></p><p>一个entry的构成如下图。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ziplistEntry.png" alt="ziplist中的节点"></p><ul><li><strong>previous_entry_length</strong></li></ul><p>节点的 previous_entry_length 属性以字节为单位,记录了压缩列表中<strong>前一个节点</strong>的长度。previous entry length 属性的长度可以是1字节或者5字节。</p><ol><li>小于254个字节，previous_entry_length长度为1字节。</li><li>大于等于254个字节，previous_entry_length最高位字节为0xFE，剩下四位字节记录长度（最多2^32-1，4G）。</li></ol><ul><li><strong>encoding</strong></li></ul><p>节点的encoding属性记录了节点的content属性所保存数据的类型以及长度。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ziplistEncode.png" alt="encoding说明"></p><ul><li><strong>content</strong></li></ul><p>节点的content属性负责保存节点的值,节点值可以是一个字节数组或者整数,值的类型和长度由节点的encoding属性决定。</p><h3 id="ziplist特性"><a href="#ziplist特性" class="headerlink" title="ziplist特性"></a>ziplist特性</h3><ul><li><strong>连锁更新</strong></li></ul><p>由于单个entry中<strong>previous_entry_length</strong>有1字节和5字节两次长度，所以由某个节点<strong>previous_entry_length</strong>改变导致的其他多个节点的<strong>previous_entry_length</strong>改变的现象，被称为连锁更新。<br>连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作,而每次空间重分配的最坏复杂度为$O(N)$,所以连锁更新的最坏复杂度为$O(N^2)$。</p><h3 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h3><p>由于ziplist存在连锁更新等一些其他缺点，在redis 3后逐步被listpack取代。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/listpack.png" alt="listpack结构"></p><ul><li>totalbytes：listpack 占用的字节数，4 字节</li><li>size：listpack 节点数量，2 字节</li><li>element：节点元素</li><li>end：结尾符 0xFF 1 字节</li></ul><p>由于listpack只记录自身节点的长度，所以节点之间独立不会互相影响。</p><h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>quicklist是listpack与双向链表的混合体，兼顾节省内存和插入效率。</p><h2 id="跳表（skiplist）"><a href="#跳表（skiplist）" class="headerlink" title="跳表（skiplist）"></a>跳表（skiplist）</h2><p>skiplist是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针达到快速访问其他节点的目的。<strong>其支持平均$O(log(N))$,最坏$O(N)$复杂度的节点查找</strong>。</p><h3 id="skiplist实现"><a href="#skiplist实现" class="headerlink" title="skiplist实现"></a>skiplist实现</h3><p>skiplist由<strong>zskiplist</strong>结构和<strong>zskiplistNode</strong>结构来定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplist</span> &#123;<br>    <span class="hljs-comment">// 指向跳表的表头和表尾节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *header, *tail;<br>    <span class="hljs-comment">// 记录跳表的长度，即表的总节点数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-comment">// 记录节点（表头除外）最大的层数</span><br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> &#123;<br>    <span class="hljs-comment">// 成员属性（书中为 robj *obj）</span><br>    sds ele;<br>    <span class="hljs-comment">// 跳表中的节点按此分值排列</span><br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-comment">// 节点后退指针</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *backward;<br>    <span class="hljs-comment">// 层数组，每个元素包含一个指向其他节点的指针</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistLevel</span> &#123;<br>        <span class="hljs-comment">// 指向其他节点</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *forward;<br>        <span class="hljs-comment">// 跨度，记录两个节点之间的距离</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/skiplist.png" alt="跳表结构"></p><p>各个跳表节点的最底层是一个完整的有序链表，每往上一层，都会<strong>跳过</strong>一些节点，形成“<strong>快捷通道</strong>”。</p><h2 id="对象（redisObject）"><a href="#对象（redisObject）" class="headerlink" title="对象（redisObject）"></a>对象（redisObject）</h2><p>redis并没有直接使用以上提到的数据结构实现键值对数据库，而是基于其构建了一个对象系统。</p><h3 id="对象的编码和类型"><a href="#对象的编码和类型" class="headerlink" title="对象的编码和类型"></a>对象的编码和类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">redisObject</span> &#123;<br>    <span class="hljs-comment">// 对象类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 对象编码</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 记录对象最后一次的命令时间，用于得到空转时长</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">/* LRU time (relative to global lru_clock) or</span><br><span class="hljs-comment">                            * LFU data (least significant 8 bits frequency</span><br><span class="hljs-comment">                            * and most significant 16 bits access time). */</span><br>    <span class="hljs-comment">// 引用计数，用于自动回收内存</span><br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-comment">// 指向对象的底层实现数据结构</span><br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><h4 id="类型-type"><a href="#类型-type" class="headerlink" title="类型-type"></a>类型-type</h4><p>redis的对象有以下五种类型：</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/objectType.png" alt="对象的类型"></p><h4 id="编码-encoding"><a href="#编码-encoding" class="headerlink" title="编码-encoding"></a>编码-encoding</h4><p>以下为不同类型的对象以及他们会采用的编码方式：</p><table><thead><tr><th>对象类型</th><th>编码方式</th><th>是否默认 &#x2F; 特殊情况</th></tr></thead><tbody><tr><td>String</td><td>embstr &#x2F; raw &#x2F; int</td><td>embstr 是短字符串优化；int 为整数</td></tr><tr><td>List</td><td>quicklist</td><td>Redis 3.2+ 默认</td></tr><tr><td>Set</td><td>intset &#x2F; hashtable</td><td>小整数集合 → intset</td></tr><tr><td>Hash</td><td>listpack &#x2F; hashtable</td><td>小型哈希 → listpack</td></tr><tr><td>ZSet</td><td>listpack &#x2F; skiplist</td><td>大型集合或范围查询 → skiplist</td></tr></tbody></table><p>通过encoding属性来设定对象的底层编码，而不为某一类型对象使用特定的数据编码，使得redis能在特定情况下设置encoding来提高该情景中的redis性能。</p><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象底层采用的编码一般为<strong>embstr</strong>和<strong>raw</strong>，其实这两种编码的实现方式原理都是<strong>SDS</strong>。但是，embstr更适合于短字符串，raw则用于长字符串。而一个字符串对象保存的是一个整数值时，ptr类型变为long，编码方式为<strong>int</strong>。<br>区别如下：</p><ul><li><strong>embstr</strong></li></ul><ol><li>一次性分配内存，一次性释放内存。</li><li>对象头和SDS字符串在同一块内存。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 内存结构">[ robj | sds结构 | 字符串内容 ]<br> ↑全在一块 malloc 内存中<br></code></pre></td></tr></table></figure><ul><li><strong>raw</strong></li></ul><ol><li>两次分配内存，两次释放内存。</li><li>对象头和SDS字符串分开，两个指针内存。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 内存结构">[ robj ]     -&gt;     [ sds结构 | 字符串内容 ]<br>（分开 malloc 两块内存）<br></code></pre></td></tr></table></figure><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>从 Redis 3.2 开始，列表对象的底层统一使用<strong>quicklist</strong>编码，取代了老版本的ziplist和linkedlist。</p><blockquote><p>quicklist &#x3D; 多个<strong>ziplist</strong>节点组成的双向链表结构</p></blockquote><p>它结合了 ziplist（紧凑、连续）和 linkedlist（快速插入&#x2F;删除）的优点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs quicklist">[ziplist1] &lt;-&gt; [ziplist2] &lt;-&gt; [ziplist3] ...<br></code></pre></td></tr></table></figure><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码方式为<strong>listpack</strong>或者<strong>hashtable</strong>，listpack用于小型哈希表，而hashtable则用于大型哈希表。</p><p>listpack编码实现的哈希对象原理与ziplist编码相同。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hashByziplist.png" alt="ziplist编码的哈希对象"></p><p>添加顺序如下：</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hashByziplist2.png" alt="ziplist编码的哈希对象的底层实现"></p><p>hashtable编码底层使用字典实现哈希对象。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hashBydict.png" alt="hashtable编码的哈希对象"></p><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象可以使用<strong>intset</strong>或<strong>hashtable</strong>编码实现。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/set.png" alt="两种编码的集合对象"></p><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合对象编码可以是<strong>listpack</strong>或<strong>skiplist</strong>。</p><p>listpack编码的有序对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨着的节点保存，第一个节点为元素成员，第二个节点为元素分值。<strong>压缩列表内的元素按照分值从小到大进行排列</strong>。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/zsetByzl.png" alt="ziplist编码的有序集合对象"></p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/zlInzset.png" alt="有序集合中的元素"></p><p>skiplist编码的有序集合对象为了保证各个命令的操作性能不下降，所以实际使用了<strong>字典</strong>和<strong>跳表</strong>共同构建。</p><p><img src="/img/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/zsetBysl.png" alt="skiplist编码的有序集合对象"></p>]]></content>
    
    
    <categories>
      
      <category>redis设计与实现读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上传文章</title>
    <link href="/2025/06/20/%E4%B8%8A%E4%BC%A0%E6%96%87%E7%AB%A0/"/>
    <url>/2025/06/20/%E4%B8%8A%E4%BC%A0%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录上传博客的操作步骤————第一篇文章</p></blockquote><h2 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h2><p>博客网站是借用<strong>github、hexo、fluid</strong>搭建的静态网页，其中github相当于提供服务器服务（github pages），但是只能存放静态网页，所以博客的发布需要作者从本地更新整个网站再上传到github，其他人才能看到。之所以选择这套方案，主要是作者现在作为学生米还是不够多🤣，再者该方案作为笔记系统已经足够满足我的需求了😊。</p><p>所以本地操作基于<strong>hexo</strong>创建一个本地网页，网页语言使用markdown即可。首先进入网站工作目录，终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post 文章名<br></code></pre></td></tr></table></figure><p>该操作会在<code>/source/_posts/</code>目录下生成一个md文件，在该文件中即可编写文章内容。md文件中的图片插入则使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;img src=<span class="hljs-string">&quot;/img/CMU15-445-Bustub-project1实现笔记/bpm2.png&quot;</span> alt=<span class="hljs-string">&quot;分层设计&quot;</span> style=<span class="hljs-string">&quot;display: block; margin: 0 auto; width: 50%; height:50%;&quot;</span>&gt;<br><br>![缓冲池管理](/img/CMU15-445-Bustub-project1实现笔记/bpm.png)<br></code></pre></td></tr></table></figure><p>图片放入该目录下的文章同名目录下。</p><p>写完文章后，使用以下命令更新本地的静态网站：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g -d<br><span class="hljs-comment"># 使用该命令可以通过https://localhost:4000访问本地网站</span><br>hexo s <br></code></pre></td></tr></table></figure><h2 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h2><p>可以把文件目录直接push到github，也可以安装<strong>hexo-deployer-git</strong>自动化上传。安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
